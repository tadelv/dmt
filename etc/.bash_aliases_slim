#!/bin/bash

#                 _
#             .__(.)< (ðŸ’¡DMT ALIASES v1.0.86 â–  2019-08-24)
#              \___)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~ WARNING: CHANGES TO THIS FILE WILL BE LOST (FILE IS COMPILED) ~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#!/bin/bash

# DEFINE COLORS
YELLOW='\033[0;33m'
GREEN='\033[0;32m'
RED='\033[0;31m'
BLUE='\033[0;94m'
CYAN='\e[0;36m'
MAGENTA='\033[0;35m'
GRAY='\e[1;30m'
WHITE='\e[33;97m'
NC='\033[0m' # No Color

# http://stackoverflow.com/a/17805088/458177
# Ultimate bash debugging
# just "set -x" and you will get all this additional info printed:
export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'

function macos {
  if [[ $OSTYPE == darwin* ]]; then
    return 0 # true
  fi

  return 1 # false
}

function is_rpi {
  if [ -f /etc/issue ] && [[ $(cat /etc/issue) =~ Raspbian ]]; then
    return 0 # true
  fi

  return 1 # false
}

function dev_machine {
  if [ -f "$DMT_THIS_DEVICE/.dev-machine" ]; then
    return 0 # true
  fi

  return 1 # false
}

# info: https://mharrison.org/post/bashfunctionoverride/
save_function() {
  local ORIG_FUNC=$(declare -f $1)
  local NEWNAME_FUNC="$2${ORIG_FUNC#$1}"
  eval "$NEWNAME_FUNC"
}

function array_contains_element {
  local e match="$1"
  shift
  for e; do [[ "$e" == "$match" ]] && return 0; done
  return 1
}

function opts_matcher_helper {
  local pattern="$2"
  local ARGS=("$@")
  local opts=("${ARGS[@]:2}")

  local min_size=1000
  local match

  for entry in "${opts[@]}"
  do
    shopt -s nocasematch # case insensitive regex
    if [[ "$entry" == "$pattern"* ]] && [ -n "$pattern" ]; then
      local size=${#entry}
      if [[ $size -lt $min_size ]]; then
        match=$entry
        min_size=$size
      fi
    fi
    shopt -u nocasematch
  done

  if [ -n "$match" ]; then
    eval "$1='${match}'"
  else
    return 1
  fi
}

function opts_matcher {
  local __matching_opt=''

  local no_warning
  if [ "$2" == "no_warning" ]; then
    no_warning="true"

    local pattern="$3"
    local ARGS=("$@")
    local opts=("${ARGS[@]:3}")
  else
    local pattern="$2"
    local ARGS=("$@")
    local opts=("${ARGS[@]:2}")
  fi



  opts_matcher_helper __matching_opt "$pattern" "${opts[@]}"
  if [ $? -ne 0 ]; then # error
    if [ -n "$pattern" ] && [ -z "$no_warning" ]; then
      printf "${RED}Unknown option:${NC} ${pattern}\n\n"
    fi
    return 1
  elif [ "$pattern" != "$__matching_opt" ]; then
    printf "${MAGENTA}Matched: ${GREEN}${__matching_opt}${NC}\n\n"
  fi

  eval "$1='${__matching_opt}'"
}

# Priority for executable binary scripts:
#
# ~/.dmt/bin
# ~/.dmt/user/bin
# ~/.dmt/user/devices/this/bin
#
# TODO:
# DEV_BIN=true [command] [args]
# when true, it goes directly to core/rust/target/release example or bin... searches everything
function platform_bin_command {
  local __result=''

  shift

  local _device_script="${DMT_DEVICE_PLATFORM_BIN}/$@"
  local _user_script="${DMT_USER_PLATFORM_BIN}/$@"
  local _fw_script="${DMT_PLATFORM_BIN}/$@"

  if [ -f "$_fw_script" ]; then
    __result="$_fw_script"
  elif [ -f "$_user_script" ]; then
    __result="$_user_script"
  elif [ -f "$_device_script" ]; then
    __result="$_device_script"
  else
    printf "${GRAY}Script $@ not found among device, user or fw scripts.${NC}\n"
    return 1
  fi

  eval "$1='${__result}'"
}

# very simple parsing... scan all the lines until "parent_key" is found,
# then search for the first occurence of "key" and return its "value"
function def_reader {
  local file="$2"
  local parent_key="$3"
  local key="$4"

  local parent_key_matched=false

  IFS=$'\n' read -d '' -r -a lines < "$file"

  local _result=''

  IFS=$'\n'

  for line in ${lines[@]}; do
    unset IFS

    line=$(echo "${line}" | xargs) # trim whitespace

    # Handle comments

    if [[ $line =~ ^\s*"#" ]]; then # comment is a whole line, ignore
      continue
    fi

    # if not, ignore after # character

    local fillInToken="%@@%" # string that is unlikely to occur

    line=$(echo "$line" | sed "s/ /${fillInToken}/g")
    local arr=(${line/\#/ }) # split on \#
    line=$(echo ${arr[0]} | sed "s/${fillInToken}/ /g")

    # ---- end comment handing

    if [[ $line =~ ^${parent_key}\: ]]; then
      parent_key_matched=true

      if [ -z "$key" ]; then
        local arr=($(echo "$line" | tr ":" "\n"))
        _result=$(echo "${arr[@]:1}" | xargs) # trim whitespace
        break
      fi
    elif [[ $line =~ ^${key}\: ]] && $parent_key_matched; then
      local arr=($(echo "$line" | tr ":" "\n"))
      _result=$(echo "${arr[@]:1}" | xargs) # trim whitespace
      break
    fi
  done

  eval "$1='$_result'"
}

# calls nodejs parser and outputs nicely formatted json --
# good for testing the correctness .def files syntax
function parsedef {
  which node > /dev/null 2>&1

  if [ ! $? -eq 0 ]; then
    printf "${MAGENTA}nodejs not installed, please install it and try again${NC}\n"
    return
  fi

  local DEF_PARSER_PATH="$DMT_NODE_CORE/dmt-bridge/cli/parseDef.js"

  if [ ! -f "$DEF_PARSER_PATH" ]; then
    printf "${RED}Missing dmt-bridge nodejs package${NC}\n"
    return
  fi

  local pattern="$1"

  if [ -z "$pattern" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}parsedef [file.def]${NC} ${GRAY}converts .def file to json and shows the parsed results if successful${NC}\n"
    return
  fi

  local matching_file=''
  get_matching_file matching_file "$pattern" "*.def"
  matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

  if [ ! -f "$matching_file" ]; then
    printf "${RED}No matching file for pattern $1${NC}\n"
    return
  fi

  node "$DEF_PARSER_PATH" "$matching_file"
}

function def {
  parsedef "$@"
}
#!/bin/bash

LOGNAME_HOME="$HOME"

DMT_PATH="$LOGNAME_HOME/.dmt"

DMT_USER_PATH="$LOGNAME_HOME/.dmt/user"
DMT_THIS_DEVICE="$LOGNAME_HOME/.dmt/user/devices/this"

DMT_DEVICE_FILE="$DMT_THIS_DEVICE/def/device.def"

DMT_STATE="$DMT_PATH/state"

DMT_CORE="$LOGNAME_HOME/.dmt/core"
DMT_NODE_CORE="$DMT_CORE/node"
DMT_RUST_CORE="$DMT_CORE/rust"

LOCAL_DMT_SOURCE_MAC="62:38:e0:cc:f7:80"
LOCAL_DMT_SOURCE_ENDPOINT="192.168.0.10:1111"

DMT_RUNTIMES=(node rust)

# for runtime in "${DMT_RUNTIMES[@]}"
# do
#   if [ ! -f "$DMT_CORE/${runtime}" ]; then
#     mkdir -p "$DMT_CORE/${runtime}"
#   fi
# done

# if [ ! -f "$DMT_CORE/static" ]; then
#   mkdir -p "$DMT_CORE/static"
# fi

DMT_SCRIPTS="$DMT_PATH/etc/scripts"

DMT_PLATFORM=""
if macos; then
  DMT_PLATFORM="darwin"
elif [ "$OSTYPE" == "linux-gnu" ]; then
  DMT_PLATFORM="linux-x64"
elif [ "$OSTYPE" == "linux-gnueabihf" ]; then
  DMT_PLATFORM="linux-arm"
fi

DMT_PLATFORM_BIN="${DMT_PATH}/bin/${DMT_PLATFORM}"
DMT_USER_PLATFORM_BIN="${DMT_USER_PATH}/bin/${DMT_PLATFORM}"
DMT_DEVICE_PLATFORM_BIN="${DMT_THIS_DEVICE}/bin/${DMT_PLATFORM}"
DMT_AP_DEFAULT_HOST="root@192.168.1.1"
#!/bin/bash

function f {

  local walksearch=''
  platform_bin_command walksearch "walksearch"
  if [ -z "$walksearch" ]; then
    printf "${YELLOW}Using bash find instead ...${NC}\n"
    # not completelly sure why I used uniq filter here....
    local pattern=$(echo "$1" | sed 's/\[/\\[/g' | sed 's/\]/\\]/g') # grep really doesn't like unescaped [ or ]
    find . -name '.git' -prune -o -print -name 'node_modules' -prune -o -print -name 'Godeps' -prune -o -print -name 'elm-stuff' -prune -o -print -name 'bower_components' -prune -o -print | uniq | grep -i -- "$pattern"
    return
  fi

  "$walksearch" "$@" | grep -v ".git$" | grep -v ".git/" | grep -v ".node_modules$" | grep -v "node_modules/" | grep -v "Godeps$" | grep -v "Godeps/" | grep -v ".elm-stuff$" | grep -v ".elm-stuff/" | grep -v ".bower_components$" | grep -v ".bower_components/"

  # not completelly sure why I used uniq filter here....
  #local pattern=$(echo "$1" | sed 's/\[/\\[/g' | sed 's/\]/\\]/g') # grep really doesn't like unescaped [ or ]
  #find . -name '.git' -prune -o -print -name 'node_modules' -prune -o -print -name 'Godeps' -prune -o -print -name 'elm-stuff' -prune -o -print -name 'bower_components' -prune -o -print | uniq | grep -i -- "$pattern"
}

# finds just files in current directory
function ff {
  local pattern=$(echo "$1" | sed 's/\[/\\[/g' | sed 's/\]/\\]/g') # grep really doesn't like unescaped [ or ]
  find . -maxdepth 1 -type f | grep -i -- "$pattern"
  #find . -type f -maxdepth 1 | grep -i -- "$1"
}

# finds just directories in current directory
function ffd {
  local pattern=$(echo "$1" | sed 's/\[/\\[/g' | sed 's/\]/\\]/g') # grep really doesn't like unescaped [ or ]
  find . -maxdepth 1 -type d | grep -i -- "$pattern"
  #find . -type f -maxdepth 1 | grep -i -- "$1"
}

# deps: ggrep -> brew install grep (GNU grep, newer versions which support -z option, paring by null)
function ffm {
  if [ -z "$1" ]; then
    printf "${GREEN}Move files to destination directory${NC}\n"
    echo "Usage: ffm [filter] [dir]"
  else
    if [ -z "$2" ]; then
      printf "${MAGENTA}-- Dry run -- Files that would be moved:${NC}\n"
      ff "$1"
      printf "\n${YELLOW}Usage reminder: ffm [filter] [dir]${NC}\n"
    else
      if [ -d "$2" ]; then
        printf "${GREEN}Moved to${NC} ${YELLOW}$2${NC}:\n"
        ff "$1"
        local pattern=$(echo "$1" | sed 's/\[/\\[/g' | sed 's/\]/\\]/g') # grep really doesn't like unescaped [ or ]
        if macos; then
          find . -maxdepth 1 -type f -print0 | ggrep -z -i -- "$pattern" | xargs -0 -I{} mv '{}' "$2"
        else
          find . -maxdepth 1 -type f -print0 | grep -z -i -- "$pattern" | xargs -0 -I{} mv '{}' "$2"
        fi
      else
        printf "${RED}Target directory doesn't exist${NC}\n"
      fi
    fi
  fi
}

# deps: ggrep -> brew install grep (GNU grep, newer versions which support -z option, paring by null)
function ffc {
  if [ -z "$1" ]; then
    printf "${GREEN}Copy files to destination directory${NC}\n"
    echo "Usage: ffc [filter] [dir]"
  else
    if [ -z "$2" ]; then
      printf "${MAGENTA}-- Dry run -- Files that would be copied:${NC}\n"
      ff "$1"
      printf "\n${YELLOW}Usage reminder: ffc [filter] [dir]${NC}\n"
    else
      if [ -d "$2" ]; then
        printf "${GREEN}Copied to${NC} ${YELLOW}$2${NC}:\n"
        ff "$1"
        local pattern=$(echo "$1" | sed 's/\[/\\[/g' | sed 's/\]/\\]/g') # grep really doesn't like unescaped [ or ]

        if macos; then
          find . -maxdepth 1 -type f -print0 | ggrep -z -i -- "$pattern" | xargs -0 -I{} cp '{}' "$2"
        else
          find . -maxdepth 1 -type f -print0 | grep -z -i -- "$pattern" | xargs -0 -I{} cp '{}' "$2"
        fi
      else
        printf "${RED}Target directory doesn't exist${NC}\n"
      fi
    fi
  fi
}

function fa {
  find . -name '.git' -prune -o -print | uniq | grep -i -- "$1"
}

# ~~~~~~~~~~~~
# Jump around!
# p proj -> cd ~/Projects/project
# works best (fastest) if your projects are lower-case and you refer to them as such
# if not, then for best performance (no lag) you have to call "p Proj" (if ~/Projects/Project exists)
function awesome_cd {
  local base=$1
  local pattern=$2
  local arg=$3
  local origin
  if [ "$4" != 'subdir' ]; then
    local origin="`pwd`"
  fi

  if [ ! -d "$base" ]; then
    return 1
  fi

  cd "$base"

  if [ -z "$pattern" ]; then
    return
  fi

  # optimization, todo!
  # if [ -d "$pattern" ]; then
  #   cd "$pattern"
  #   return
  # fi
  # ==> above is not good enough because:
  # suppose there is a directory called AAA, you type "c aaa", then just "cd aaa" will cause command line to show $/aaa instead of real name- $/AAA
  #cd $(find . -maxdepth 1 -type d -iname "$1" | head -1) # this works correctly but has other problems -- find reports some unrelated error if for example some directory is not valied anymore (unmounted etc).. also "c dir/" (with slash) caused problems

  local subdir

  if [[ "$pattern" =~ \/ ]] ; then
    arr=(${pattern//\// })
    pattern=${arr[0]}
    subdir=${arr[1]}
  else
    unset subdir
  fi

  local IFS=$'\n' # default is " " and then array is not correctly constructed when there is spaces in filenames
  local dirlist=($(find . -maxdepth 1 -type d ! -path . -or -type l | sed "s/^\.\///" | grep -i ${pattern}))
  # will return symlinks that are files (not dirs) as well, that's why we have additional check [ -d "$d" ] below

  local match
  if [ -n "$pattern" ]; then
    local min_size=1000
    if [ "$arg" == "fuzzy" ]; then
      shopt -s nocasematch # case insensitive regex
      for d in ${dirlist[@]} ; do
        if [[ "$d" =~ $pattern ]] && [ -d "$d" ]; then
          local size=${#d}
          if [[ $size -lt $min_size ]]; then
            match="$d"
            min_size=$size
          fi
        fi
      done
      shopt -u nocasematch
    else
      # first try only directories that start exactly with our input
      for d in ${dirlist[@]} ; do
        if [[ "$d" == $pattern* ]] && [ -d "$d" ]; then
          local size=${#d}
          if [[ $size -lt $min_size ]]; then
            match="$d"
            min_size=$size
          fi
        fi
      done
    fi
    if [ -z "$match" ]; then
      #local proj=`echo $pattern | tr '[:upper:]' '[:lower:]'`
      local min_size=1000
      # search case-insensitive now
      shopt -s nocasematch # case insensitive regex
      for d in ${dirlist[@]} ; do
        if [[ "$d" == $pattern* ]] && [ -d "$d" ]; then
          local size=${#d}
          if [[ $size -lt $min_size ]]; then
            match="$d"
            min_size=$size
          fi
        fi
      done
      shopt -u nocasematch
    fi
  fi

  if [ -n "$match" ]; then
    cd "$match"
    if [ -n "$subdir" ]; then
      awesome_cd . "$subdir" "$arg" 'subdir'
      if [ $? -gt 0 ]; then
        cd "$origin"
        return 1
      fi
    fi
  elif [ "$arg" != "fuzzy" ]; then
    awesome_cd . "$pattern" 'fuzzy'
    if [ $? -gt 0 ]; then
      cd "$origin"
      return 1
    elif [ -n "$subdir" ]; then
      awesome_cd . "$subdir"
      if [ $? -gt 0 ]; then
        cd "$origin"
        return 1
      fi
    fi
  else
    if [ -z "$AWESOME_SILENCE" ]; then
      printf "${RED}Directory not found${NC}\n"
    fi
    cd "$origin"
    return 1
  fi
}

function p {
  if macos; then

    AWESOME_SILENCE=true awesome_cd ~/.dmt/core/node/dmt-controller "$1"

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/Projects/node "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/Projects/rust "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/Projects "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd /var/projects "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/Projects/node/dcrypt "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/.dmt/core/node "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/.dmt/core/rust "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/Projects/ethereum "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/Projects/music "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd $GOPATH/src "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/Documents/Arduino "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/Documents/Arduino/libraries "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/Install "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/Projects/playground "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/Projects/node/archive "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/Library/Application\ Support/Sublime\ Text\ 3/Packages "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/Projects/archive "$1"
    fi

    if [ $? -gt 0 ]; then
      awesome_cd ~/Misc "$1"
    fi

  else
    # nice side effect:
    # p -> /var/projects
    # p (second time) -> /var/www
    AWESOME_SILENCE=true awesome_cd ~/.dmt/core/node/dmt-controller "$1"

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd /var/projects "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/.dmt/core/node "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/.dmt/core/rust "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd /var/www "$1"

      if [ $? -gt 0 ]; then
        awesome_cd ~/Install "$1"
      elif [ -d "current" ]; then
        cd current
      fi
    fi
  fi
}

function app {
  awesome_cd /Applications "$1"
  if [ $? -eq 0 ] && [ -d "Contents" ]; then
    cd Contents
  fi
}

# TREE:
# red
#   blue
# green
#
# c r â†’ cd red
# c re/bl â†’ cd red/blue
# c â†’ cd to first directory
function c {
  # c â†’ cd to first directory
  if [ -z "$1" ]; then
    cd "`find . -maxdepth 1 -type d ! -path '*/\.*' ! -path . | sed "s/^\.\///" | sort | sed "1q;d"`"
  else
    # absolute paths
    if [[ "$1" =~ ^\/ ]]; then
      cd "$1"
      return
    fi
    awesome_cd . "$1"
  fi
}

function h {
  str="$1"
  str="$(tr '[:lower:]' '[:upper:]' <<< ${str:0:1})${str:1}" # upcase first letter for performance, most subdirs of interest here have first letter upcased and comparison will be faster

  local cwd=`pwd`

  AWESOME_SILENCE=true awesome_cd ~/ "$str"

  if [ $? -gt 0 ]; then
    if macos; then
      if [ -d ~/Misc ]; then
        AWESOME_SILENCE=true awesome_cd ~/Misc "$str"
        if [ $? -gt 0 ]; then
          if [ "$cwd" == "`pwd`" ]; then
            printf "${RED}Directory not found${NC}\n"
          fi
        fi
      fi
    else

      AWESOME_SILENCE=true awesome_cd ~/Storage "$1"

      if [ $? -gt 0 ]; then
        AWESOME_SILENCE=true awesome_cd ~/System "$1"
      fi

      if [ $? -gt 0 ]; then
        AWESOME_SILENCE=true awesome_cd ~/Media "$1"
      fi

      if [ $? -gt 0 ]; then
        AWESOME_SILENCE=true awesome_cd ~/Helper "$1"
      fi

      if [ $? -gt 0 ]; then
        printf "${RED}Directory not found${NC}\n"
      fi
    fi
  fi
}

function l {
  local pattern=$1

  if [ -f "$pattern" ]; then
    printf "File ${YELLOW}${pattern}:${NC}\n"
    ls -lah "$pattern"
    return
  fi

  # search for extensions
  # l .sol
  if [[ "$1" =~ ^\. ]]; then
    printf "Files with ${YELLOW}${pattern}${NC} extension:\n"
    echo
    ls -la *"$1"
    # ls -1
    return
  fi

  # absolute paths
  if [[ "$1" =~ ^\/ ]]; then
    ls -la "$1"
    return
  fi

  if [ -z "$pattern" ]; then
    ls -lah
    return
  fi

  # split on slash
  if [[ "$pattern" =~ \/ ]]; then
    arr=($(echo $pattern | tr "/" "\n"))
    pattern=${arr[0]}
    local subdir=${arr[1]}
  fi

  return_match=''
  dir_match return_match "$pattern"
  local match=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$return_match")

  if [ -n "$match" ] && [ -n "$subdir" ]; then
    local dir="`pwd`"
    cd "$match"
    local subdir
    return_match=''
    dir_match return_match "$subdir"
    subdir=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$return_match")

    cd "$dir"
    if [ -z "$subdir" ]; then
      printf "${RED}${match}${arr[1]} not found${NC}\n"
      return
    fi
  fi

  if [ -n "$match" ]; then
    if [ -z "$subdir" ]; then
      printf "Subdirectory ${YELLOW}${match}:${NC}\n"
      echo
      ls -lah "$match/" # end slash is for symlinks... without it, it doesn't show contents
    else
      printf "Subdirectory ${YELLOW}${match}/${subdir}:${NC}\n"
      echo
      ls -lah "$match/$subdir/"
    fi
  else
    printf "${YELLOW}No subdirectory matches the pattern and there is no file with that exact name${NC}\n"
  fi
}

# there is also simpler get_matching_folder

#WARNING: replace single quotes back after calling this function:
# return_match=''
# dir_match return_match "$pattern"
# THIS LINE IS IMPORTANT --->  local match=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$return_match")
function dir_match {
  local pattern=$2
  local match

  if [ -n "$pattern" ]; then
    local IFS=$'\n' # default is " " and then array is not correctly constructed when there is spaces in filenames
    local dirlist=($(find . -maxdepth 1 -type d ! -path . -or -type l | sed "s/^\.\///" | grep -i ${pattern}))
    # will return symlinks that are files (not dirs) as well, that's why we have additional check [ -d "$d" ] below
    local min_size=1000
    # first try only directories that start exactly with our input
    for d in ${dirlist[@]} ; do
      if [[ $d == $pattern* ]] && [ -d "$d" ]; then
        local size=${#d}
        if [[ $size -lt $min_size ]]; then
          match=$d
          min_size=$size
        fi
      fi
    done
    if [ -z "$match" ]; then
      local proj=`echo $pattern | tr '[:upper:]' '[:lower:]'`
      local min_size=1000
      # search all directories case-insensitive now
      for d in ${dirlist[@]} ; do
        local dir=`echo "$d" | tr '[:upper:]' '[:lower:]'`
        if [[ $dir == $proj* ]] && [ -d "$d" ]; then
          local size=${#d}
          if [[ $size -lt $min_size ]]; then
            match=$d
            min_size=$size
          fi
        fi
        # if exact match stop the loop to gain some performance
        if [[ $dir == $proj/ ]]; then
          match=$dir
          break
        fi
      done
    fi
    if [ -z "$match" ]; then
      for d in ${dirlist[@]} ; do
        shopt -s nocasematch # case insensitive
        if [[ $d =~ $pattern ]] && [ -d "$d" ]; then
          local size=${#d}
          if [[ $size -lt $min_size ]]; then
            match=$d
            min_size=$size
          fi
        fi
        shopt -u nocasematch # revert
      done
    fi
  fi

  match=$(sed "s/'/111SINGLE___QUOTE111/g" <<< "$match")
  eval "$1='$match'"
}

# expand hidden filenames for run_on_file (globally, actually)
shopt -s dotglob

# run_on_file prog elixir '*.ex' 'dummy' "$@"
# doesn't work with hidden files currently, they are not passed in bash
# TO TEST SEE ABOVE
function run_on_file {

  if [ -z "$1" ]; then # safety
    return
  fi

  local pattern="$1"
  shift
  local executable="$1"
  shift
  local files="$1"
  shift
  local flag="$1"
  shift
  local args="$@"

  local matching_file=''
  get_matching_file matching_file "$pattern" "$files"
  matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")
  if [ ! -f "$matching_file" ]; then
    return
  fi

  local match="$matching_file" # we were careful not to send $match to the function, because the same name is used locally there

  if [ -n "$match" ]; then

    if [ "$flag" == "local" ]; then

      if [ "$flag" != "silent" ] && [ "$matching_file" != "$pattern" ]; then
        printf "${YELLOW}$executable ./$match $args${NC}\n"
      fi

      if [ -z "$args" ]; then
        command $executable "./$match"
      else
        command $executable "./$match" "$args"
      fi

    else

      if [ "$flag" != "silent" ] && [ "$matching_file" != "$pattern" ]; then
        printf "${YELLOW}$executable $match $args${NC}\n"
      fi

      if [ -z "$args" ]; then
        command $executable "${match}"
      else
        command $executable "$match" "$args"
      fi
    fi

  else

    if [ "$flag" == "force" ]; then # run the executable on pattern even if actual file was not found by pattern
      if [ -z "$args" ]; then
        command $executable "$pattern"
      else
        command $executable "$pattern" "$args"
      fi
    else
      printf "${RED}File not recognized${NC}\n"
    fi

  fi
}

#WARNING: replace single quotes back after calling this function:
# local matching_folder=''
# get_matching_folder matching_folder ~/Install/npm "$1"
# THIS LINE IS IMPORTANT --->  matching_folder=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_folder")
function get_matching_folder() {
  local dir="$2"
  local pattern="$3"

  if [ ! -d "$dir" ]; then
    printf "${RED}$dir is not a directory${NC}\n"
    return
  fi

  # exact match
  for d in `ls -1 "$dir"` ; do
    if [[ $d == "$pattern" ]]; then
      d=$(sed "s/'/111SINGLE___QUOTE111/g" <<< "$d")
      eval "$1='${d}'"
      return
    fi
  done

  # begins with
  for d in `ls -1 "$dir"` ; do
    if [[ $d == "$pattern"* ]]; then
      d=$(sed "s/'/111SINGLE___QUOTE111/g" <<< "$d")
      eval "$1='${d}'"
      return
    fi
  done
}

#WARNING: replace single quotes back after calling this function:
# local matching_file=''
# get_matching_file matching_file "$pattern" "$files"
# THIS LINE IS IMPORTANT --->  matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")
function get_matching_file {

  local pattern="$2"
  local files="$3"

  if [ -z "$files" ]; then
    #command $executable
    files="*"
  fi

  # r compare.go
  # this called "get_matching_file matching_file "$pattern" "*.js"" (see function r)
  # and then it matched in following lines although it shoudln't because "*.js" was not taken into account
  #
  # OPTIONS:
  # - leave is at is (is it fast enough?)
  # - improve by checking if file with exact $pattern exists but also check for extenstion
  #
  if [ -f "$pattern" ] && [ "$files" == "*" ]; then
    pattern=$(sed "s/'/111SINGLE___QUOTE111/g" <<< "$pattern")
    eval "$1='${pattern}'"
    return
  fi

  local cwd="`pwd`"

  local subdir=''

  if [[ "$pattern" =~ \/ ]] ; then
    local arr=($(echo $pattern | tr "/" "\n"))
    subdir=${arr[0]}
    pattern=${arr[1]}
    AWESOME_SILENCE=true awesome_cd . "$subdir"
    if [ "$cwd" == "`pwd`" ]; then
      printf "${RED}There is no matches for ${subdir} folder pattern${NC}\n"
      return 1
    elif [ -z "$pattern" ]; then
      printf "${RED}You have to specify the file pattern${NC}\n"
      cd "$cwd"
      return 1
    fi
    subdir=${PWD##*/} # where we actually landed
  fi

  local min_size=1000
  local match
  local file
  # local extensions_arr=(${extensions/;/ })

  # local IFS=$'\n' # default is " " and then array is not correctly constructed when there is spaces in filenames

  # start with case sensitive
  #for extension in "${extensions_arr[@]}"
  for file in $files
  do
    #local files=($(find * -maxdepth 0 -type f))
    if [ -f "$file" ] && [[ $file == "$pattern"* ]]; then
      local size=${#file}
      if [[ $size -lt $min_size ]]; then
        match=$file
        min_size=$size
      fi
    fi
  done

  # case insensitive
  if [ -z "$match" ]; then
    shopt -s nocasematch # case insensitive regex

    for file in $files
    do
      if [ -f "$file" ] && [[ $file == "$pattern"* ]]; then
        local size=${#file}
        if [[ $size -lt $min_size ]]; then
          match=$file
          min_size=$size
        fi
      fi
    done

    shopt -u nocasematch
  fi

  # anywhere case sensitive
  if [ -z "$match" ]; then
    for file in $files
    do
      if [ -f "$file" ] && [[ $file == *"$pattern"* ]]; then
        local size=${#file}
        if [[ $size -lt $min_size ]]; then
          match=$file
          min_size=$size
        fi
      fi
    done
  fi

  # anywhere case insensitive
  if [ -z "$match" ]; then
    shopt -s nocasematch # case insensitive regex

    for file in $files
    do
      if [ -f "$file" ] && [[ $file == *"$pattern"* ]]; then
        local size=${#file}
        if [[ $size -lt $min_size ]]; then
          match=$file
          min_size=$size
        fi
      fi
    done

    shopt -u nocasematch
  fi

  if [ "$cwd" != "`pwd`" ]; then
    cd "$cwd"
  fi

  if [ -n "$match" ]; then
    if [ "$flag" == "mux" ]; then
      match=${match:2:${#match}-6}
    fi

    if [ -n "$subdir" ]; then
      match="$subdir/$match"
    fi

    if  [ "$match" == "$subdir/" ]; then
      printf "${RED}Folder $subdir has no matching file${NC}\n"
      return 1
    fi

    # single quotes don't make it through the return from the function
    match=$(sed "s/'/111SINGLE___QUOTE111/g" <<< "$match")
    eval "$1='${match}'"
  else
    return 1
  fi
}

function r {
  if [ -z "$1" ]; then
    if [ -f "index.js" ]; then
      r index.js
    elif [ -f "Cargo.toml" ]; then
      cargo run
    else
      printf "${RED}No index.js to run: need file pattern${NC}\n"
    fi
  else
    local executable=''

    local pattern=$1
    shift

    # javascript
    local matching_file=''
    get_matching_file matching_file "$pattern" "*.js"
    matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

    if [ -n "$matching_file" ]; then
      if [ -f "./truffle.js" ]; then
        executable="truffle exec"
      else
        executable=node
      fi
    fi

    # elixir
    if [ -z "$matching_file" ]; then
      matching_file=''
      get_matching_file matching_file "$pattern" "*.ex"
      matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

      if [ -n "$matching_file" ]; then
        executable=elixir
      fi
    fi

    # ruby
    if [ -z "$matching_file" ]; then
      matching_file=''
      get_matching_file matching_file "$pattern" "*.rb"
      matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

      if [ -n "$matching_file" ]; then
        executable=ruby
      fi
    fi

    # go
    if [ -z "$matching_file" ]; then
      matching_file=''
      get_matching_file matching_file "$pattern" "*.go"
      matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

      if [ -n "$matching_file" ]; then
        executable="go run"
      fi
    fi

    # python
    if [ -z "$matching_file" ]; then
      matching_file=''
      get_matching_file matching_file "$pattern" "*.py"
      matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

      if [ -n "$matching_file" ]; then
        executable=python3
      fi
    fi

    if [ -n "$executable" ]; then
      local args="$@"
      printf "${YELLOW}$executable $matching_file ${args}${NC}\n" # if using $@ directly here, only the first argument is printed :/
      command $executable "$matching_file" "$@"
    elif [ -d "cli" ]; then
      cli "$pattern" "$@"
    else
      printf "${RED}No match${NC}\n"
    fi
  fi
}

# runs scripts from util, utils or utilities
# u sc => node utils/scan.js
function ru {

  if [ -z "$1" ]; then
    return
  fi

  local pattern="$1"
  shift

  local matching_file=''
  get_matching_file matching_file "util/$pattern" "*.js"
  matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

  if [ ! -f "$matching_file" ]; then
    return
  fi

  printf "${YELLOW}node ${matching_file}${NC}\n"

  node "$matching_file" "$@"
}

function bn {
  run_on_file "$1" babel-node '*.js' force
}

function edit {
  # if [ -z "$1" ] && [ -f ".gitignore" ]; then
  #   nano .gitignore
  if [ -z "$1" ]; then
    exit
  elif [ -n "$1" ]; then
    run_on_file "$1" nano '*' force
  fi
}

function moc {
  run_on_file "tests/$1" mocha '*.js'
}

function ct {
  run_on_file "$1" cat '*'
}

function tt {
  tree -Ia 'test|node_modules|.git|Godeps|elm-stuff|deps|log|_build|vendor|bower_components|tmp|deploy|distroot|Deps'
}

# t -> tree
# t fil -> t file.txt
# t sc -> t script.js => with sytax highlighting
# t fil lala -> t file.txt | grep lala -i
function t {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}t [file] ${GRAY}shows file with syntax highlighting${NC}\n"
    printf "${GREEN}t [file] [term] ${GRAY}searches for lines with [term]${NC}\n"
  else

    local matching_file=''
    get_matching_file matching_file "$1"
    matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

    if [ ! -f "$matching_file" ]; then
      printf "${RED}File not found${NC}\n"
      return
    fi

    if [ "$matching_file" != "$1" ]; then
      printf "${YELLOW}${matching_file}${NC}\n"
    fi

    if [[ "$matching_file" == *".def" ]]; then
      parsedef "$matching_file"
    elif [[ "$matching_file" == *".json" ]]; then
      if [ "$2" == "hidden" ]; then
        cat "$matching_file"
      else
        if [ -n "$2" ]; then
          printf "${BLUE}${2}:${NC}\n"
        fi
        cat "$matching_file" | grep -v "^\s*//" | jq ".$2" # $2 can be empty.. if it's not, then it graps the specific key, more info: https://stedolan.github.io/jq/tutorial/
        # Python JSON validator
        # cat file.json | python -m json.tool
        if [ $? -ne 0 ]; then # parse error..
          cat "$matching_file"
          printf "${RED}"
          cat "$matching_file" | grep -v "^\s*//" | jq ".$2"
          printf "${NC}"
        fi
      fi
    elif [ -n "$2" ]; then
      run_on_file "$matching_file" cat '*' force | grep "$2" --color -in
    elif [[ "$(head -1 "$matching_file")" =~ \#\!\/bin\/(bash|sh) ]]; then
      run_on_file "$matching_file" "highlight -O xterm256 -s darkbone --syntax bash" '*' 'silent'
    else
      if [[ "$matching_file" == "Makefile" ]] || [[ "$matching_file" == *".js" ]] || [[ "$matching_file" == *".rb" ]] || [[ "$matching_file" == *".py" ]] ||
         [[ "$matching_file" == *".go" ]] || [[ "$matching_file" == *".html" ]] || [[ "$matching_file" == *".css" ]]; then  # this will not be true on incomplete file names
        run_on_file "$matching_file" "highlight -O xterm256 -s darkbone" '*' 'silent'
      else
        run_on_file "$matching_file" cat '*'
      fi
    fi
  fi
}

function uz {
  run_on_file "$1" unzip '*.zip'
}

function ir {
  if [ -z "$1" ]; then
    irb
  else
    #command irb -r "./$1"
    run_on_file "$1" "irb -r" '*.rb' 'local'
  fi
}

function oi {
  if [ -f "index.html" ]; then
    open "index.html"
  else
    printf "${RED}No index.html${NC}\n"
  fi
}

# open
function op {
  if [ -z "$1" ] || [ "$1" == "." ]; then
    open .
  elif [ "$1" == "xcode" ] && [ -d "ios" ]; then
    find ios -type d -depth 1 | grep xcodeproj | xargs open
  elif [[ "$1" =~ ^[0-9]+$ ]]; then
    open "http://localhost:${1}"
  else
    run_on_file "$1" "open" '*'
  fi
}

alias ox="o xcode"

function e {
  en "$@"
}

function es {
  local sublime_path="/usr/local/bin/subl" # warning: this symlink is not automatic after sublime install, user has to add it, pointing to: /Applications/Sublime Text.app/Contents/SharedSupport/bin/subl
  local sublime_path2="$HOME/bin/subl"

  if [ -f "${sublime_path}" ]; then
    local editor="${sublime_path}"
  elif [ -f "${sublime_path2}" ]; then
    local editor="${sublime_path2}"
  else
    printf "${RED}No SublimeText editor installed${NC}\n"
    return
  fi

  if [ -z "$1" ]; then
    command "${editor}" .
  else
    run_on_file "$1" "${editor}" '*' force
  fi
}

function ea {
  local atom_path="/Applications/Atom.app/Contents/Resources/app/atom.sh"
  if [ -f "${atom_path}" ]; then
    local editor="${atom_path}"

    if [ -z "$1" ]; then
      command "${editor}" .
    else
      run_on_file "$1" "${editor}" '*' force
    fi
  else
    printf "${RED}No atom editor installed${NC}\n"
    return
  fi
}

function en {
  if [ -z "$1" ]; then
    printf "${RED}Must specify file to edit with nano${NC}\n"
  else
    EDITOR=nano run_on_file "$1" "nano" '*' force
  fi
}

function ec {
  local cmd="/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code"
  local args="$@"
  if [ -z "$1" ]; then
    args="."
  fi
  command "$cmd" "$args"
}

function g {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    echo "z [file]"
  else
    run_on_file "$1" nano '*' force
  fi
}

function i {
  if [ "$1" == '-h' ] || [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}i [package] [package] ... ${GRAY}install packages${NC}\n"
    printf "${GREEN}i --check [package] ${GRAY}check if installed${NC}\n"
    printf "${GREEN}i --search [package] ${GRAY}check for available versions of similarly named packages${NC}\n"
    printf "${GREEN}i --info [package] ${GRAY}detailed info of exact match (faster)${NC}\n"
    printf "${GREEN}i --cmd [package] ${GRAY}which package does the command belong to${NC}\n"
  else
    if [[ "$1" == *--* ]]; then

      if [ -z "$2" ]; then
        printf "${RED}missing the rest of the command${NC}\n"
        return
      fi

      case "$1" in
        --check)
          shift
          ii "$@"
          ;;

        --search)
          shift

          printf "\n${YELLOW}Available packages:${NC}\n"
          aptitude search "$1" -F "%c %p %d %V"

          # apt-cache search *search term*
          ;;

        --info)
          shift

          printf "\n${YELLOW}Exact match info:${NC}\n"
          apt-cache show "$1"

          ;;

        --cmd)
          shift

          local cmd="$@"

          which "$cmd" > /dev/null 2>&1

          if [ $? -eq 0 ]; then
            dpkg -S `which ${cmd}`
          else
            printf "${RED}command${NC} ${YELLOW}${cmd}${NC} ${RED}not found${NC}\n"
          fi
          ;;

        *)
          printf "${RED}unknown flag ${1}${NC}\n"
          ;;

      esac

    else
      sudo apt-get install -y "$@"
    fi
  fi
}

function ii {
  printf "${MAGENTA}Installed versions:${NC}\n"
  #dpkg-query -s "$@" | grep "Version"
  dpkg-query -l "$@" | grep "ii"
}

alias ll='ls -l'
alias la='ls -A'
alias pu='pushd'
alias po='popd'

alias to='touch'
alias wg='wget'

#alias .='l' bad idea
alias ..='cd ..'
alias ...='cd ../..'
alias ..3="cd ../../.."
alias ..4="cd ../../../.."
alias ..5="cd ../../../../.."
alias cd..='cd ..'

function cop {
  if ! macos; then
    printf "${MAGENTA}Warning: not copied to clipboard because in remote shell${NC}\n"
  fi

  local path

  if [ -z "$1" ]; then
    path=$(pwd)
  else
    if [ -f "$1" ]; then
      if macos; then
        path=$(greadlink -f "$1")
      else
        path=$(readlink -f "$1")
      fi
    else
      local matching_file=''
      get_matching_file matching_file "$1"
      matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

      if [ ! -f "$matching_file" ]; then
        return
      fi

      if macos; then
        local path=$(greadlink -f "$matching_file")
      else
        path=$(readlink -f "$matching_file")
      fi
    fi
  fi

  if [ -e "${path}" ]; then
    path=$(sed "s/ /\\\ /g" <<< "$path")
    path=$(sed "s/\!/\\\\!/g" <<< "$path")
    path=$(sed "s/(/\\\(/g" <<< "$path")
    path=$(sed "s/)/\\\)/g" <<< "$path")
    path=$(sed "s/'/\\\'/g" <<< "$path")
    path=$(sed "s/\"/\\\\\"/g" <<< "$path")
    path=$(echo $path | tr -d '\n')

    if macos; then
      printf "Clipboard: ${YELLOW}${path}${NC}\n"
      echo "$path" | tr -d '\n' | pbcopy
    else
      echo "$path"
    fi
  else
    printf "${RED}No such file${NC}\n"
  fi
}

function cli_helper() {
  local MAGENTA='\033[0;35m'
  local NC='\033[0m' # No Color
  local text=$(echo "$1" | sed "s/cli\///g" | sed "s/.js//g")
  printf "${MAGENTA}${text}${NC} >>> "
  node "$1" -h
  echo
}

function cli {
  if [ -z "$1" ] || [ "$1" == "-h" ]; then
    if [ -d "cli" ]; then
      if [ -z "$1" ]; then
        find cli -type f | sort | sed "s/cli\///g" | sed 's/.js//g'
        echo
        printf "${YELLOW}Tip:${NC} use ${CYAN}cli -h${NC} for more info\n"
        return
      elif [ -d "cli" ] && [ -n "$1" ]; then
        #hardcore ;P --
        find cli/*.js -type f | sort | xargs -I@ bash -c "$(declare -f cli_helper) ; cli_helper @ "
        return
      fi
    elif [ -d "lib" ]; then
      printf "${YELLOW}lib:${NC}\n"
      find lib -type f | sort | sed "s/lib\///g" | sed 's/.js//g'
      return
    fi
  fi

  local dirname=$(pwd | xargs basename)

  # first option for "cli" to be active: existence of ./cli directory
  if [ -d "cli" ]; then
    local cmd="$1"
    cd cli
    local matching_file=''
    get_matching_file matching_file "$cmd" "*.js"
    matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")
    cd ..

    if [ -n "$matching_file" ]; then
      shift
      local fileName=$(echo $matching_file | sed 's/.js//g')
      >&2 printf "cli/${MAGENTA}${fileName}${NC} \n" # output to stderr so that piping the output to file doesn't contain this header
      node "cli/$matching_file" "$@"
      found=true
    else
      printf "${RED}Unknown cli command${NC}\n"
    fi
  elif [ -d "lib" ]; then # second option: existence of .lib directory (very similar to above)
    local cmd="$1"
    cd lib
    local matching_file=''
    get_matching_file matching_file "$cmd" "*.js"
    matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")
    cd ..

    if [ -n "$matching_file" ]; then
      shift
      >&2 node "lib/$matching_file" "$@"
      found=true
    else
      printf "${RED}Unknown cli command${NC}\n"
    fi
  elif [ "$dirname" == "packages" ]; then
    printf "${GREEN}We are inside packages.${MAGENTA} TODO - should report something about each package (subdirectory) ... at least report basic description of a package.. should probably not be in bash, but delegate this to superlib (which has to get extended functionality)${NC}\n"
  else
    printf "${RED}Not in the right kind of directory for ${MAGENTA}cli${RED} to work ${NC}\n"
  fi
}

function tape {
  declare -a opts=(
    "status"
    "rewind"
    "look"
    "eject"
    "eom"
    "goto"
    "fwd"
    "prev"
    "backup"
    "copy"
    "copy_rewind"
    "restore"
  )

  if [ -z "$1" ] || [ "$1" == "-h" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    echo "${opts[@]}"
    return
  fi

  local matching_opt=''
  opts_matcher matching_opt "$1" "${opts[@]}"
  if [ $? -ne 0 ]; then # error
    printf "${YELLOW}Use ${GREEN}-h ${YELLOW}to see valid options${NC}\n\n"
    return
  fi

  shift

  case "$matching_opt" in
    status)
      sudo mt -f /dev/nst0 status
      ;;

    rewind)
      time sudo mt -f /dev/st0 rewind
      ;;

    eject)
      time sudo mt -f /dev/st0 offline
      ;;

    look)
      sudo tar -b 2048 -tf /dev/nst0
      ;;

    eom)
      time sudo mt -f /dev/nst0 eom
      ;;

    goto)
      if [ -z "$1" ]; then
        printf "${RED}Must specify which archive number to seek to${NC}\n"
      else
        time sudo mt -f /dev/nst0 asf "$1"
        sudo mt -f /dev/nst0 status
      fi
      ;;

    fwd)
      local steps="1"
      if [ -n "$1" ]; then
        steps="$1"
      fi

      time sudo mt -f /dev/nst0 fsf "$steps"
      sudo mt -f /dev/nst0 status
      ;;

    prev)
      local steps="1"
      if [ -n "$1" ]; then
        steps="$1"
      fi

      time sudo mt -f /dev/nst0 bsfm "$steps"
      sudo mt -f /dev/nst0 status
      ;;

    backup)
      local script="$DMT_SCRIPTS/tape_backup"
      if [ -f "$script" ]; then
        sudo "$script" "$@"
      else
        printf "${RED}missing ${script}${NC}\n"
      fi
      ;;

    copy)
      local dir="$1"
      time sudo tar -b 2048 -cf /dev/nst0 "$dir" --verbose --verbose
      ;;

    copy_rewind)
      local dir="$1"
      time sudo tar -b 2048 -cf /dev/st0 "$dir" --verbose --verbose
      ;;

    restore)
      local dir="$1" # optional! if we call tar -xf without the directory which we want to extract, we will extract the entire archive
      time sudo tar -b 2048 -xf /dev/nst0 "$dir" #--verbose --verbose
      #tar -b 2048 -xf /dev/nst0 "$dir"
      ;;
  esac
}
#!/bin/bash

# -- DMT ALIASES --
# SAVES YOU TIME AND MONEY. FREE SOFTWARE.

# INSTALL INSTRUCTIONS FOR Linux / macOS
# (Windows not supported, it has different philosophy)

# TODO: UPDATE!!!!!!!!

# 1.
# put this file into ~/.bash_aliases
# curl -o ~/.bash_aliases https://elm-research.com/projects/bash_aliases.txt
#
# Make the shell load it:
# type:
# sudo nano /etc/profile
#
# add this to the end:
#
# # Alias definitions.
# if [ -f /Users/[your name]/.bash_aliases ]; then
#   . /Users/[your name]/.bash_aliases
# fi
#
# You could also add this to ~/.bash_profile but it's better in /etc/profile because then you will have access to things defined here even when you are root
#
# To update in the future:
# update
#
# You can also check the changelog before each update:
# update_diff

# 2.
# place to put non-shareable stuff: /etc/.bash_aliases_custom

# YOU CAN add your custom aliases or changes here please...
# don't add them in this file for now, rather ask me (the author - davidhq) to update it, this is the only way to keep this file in sync for easy updates

# 3.
# ------------ TEST YOUR SETUP: ---------------
# Open a new terminal tab and type:
# l [enter]
# or
# count [enter]

# You can always terminate commands that are running too long (shouldn't happen often and almost always by your own fault - for example running count on a big folder!)
# with: CTRL+C

# If you make some changes to ~/.bash_aliases_custom, you can type: rel [enter] to reload the environment without closing the tab and opening a new one

# Learn about two useful metacommands for start: "rel" and "al"

# -------------------------------------------------------

# OPTIONAL:
#
# 4. DEPENDENCIES

# Install some other dependencies that some functions use:
# - Install "homebrew" awesome package manager for macOS based on the archaic Ruby language
#
# --- SSHRC
# brew install sshrc
#
# This turbocharges this file even more because now you'll take it with you to whatever linux server you ssh into!
# This file speeds up your command line in both, MacOS and Linux in the same exact way: it smoothes out the differences, vas majority of commands work the same on both
# types of systems.
#
# Step 2 - create symlink to this file:
# cd [this moves to home directory]
# ln -s

# -- coreutils (macOS)
# brew install coreutils
# provides gsort (used in "usage" for example) and other commands
# also provides "gshuf"
#
# --- GNU GREP
# brew install grep (gnu grep: install the command "ggrep")
#
# --- CLOC
# npm install -g cloc (code analysis in addition to "loc" which .dmt provides)
#
# --- ACK
# brew install ack
#
# Create ~/.ackrc with this contents:
#
# --type-add
# ruby=.builder,.feature
# --type-set
# rackup=.ru
# --type-set
# elm=.elm
# --type-set
# livescript=.ls
# --type-set
# haml=.haml
# --type-add
# php=.phtml
# --type-set
# jsx=.jsx
# --type-set
# vue=.vue
# --type-set
# markdown=.markdown,.md,.mdown
# --type-set=cache=.cache
# --ignore-dir=.idea
# --ignore-dir=tmp
# --ignore-dir=photos
# --ignore-dir=node_modules
# --ignore-dir=bower_components
# --ignore-dir=dist
# --ignore-dir=.git
# --ignore-dir=log
# --ignore-dir=Godeps
# --ignore-dir=elm-stuff
# --ignore-dir=deps
# --ignore-dir=build
# --ignore-dir=_build
# --ignore-dir=dist
# --ignore-dir=Deps
# --ignore-dir=vendor
# --nocache
#
# --- HIGHLIGHT: highlight code in terminal (when using "t" command instead of "cat")
# brew install highlight
#
# --- jq: parse .json in terminal
# brew install jq
#
# --- latest version of RSYNC (only needed for macOS Sierra+, linux already has the latest version)
# brew install rsync
# needed because of --protect-args (https://unix.stackexchange.com/a/137285/135062) - used in dirsync function
# if you want to rsync *to* macOS (rsync server is used), make sure to add /usr/local/bin to $PATH in ~/.bashrc so that it's loaded on ssh / rsync
#
# --- TREE: show directory and file structure
# brew install tree
#
# --- COLORDIFF: colors in diffs (example: update_diff command that shows what would be updated with "update")
# brew install colordiff
#
# --- GITSTATS
# Todo: automatic install - detect os, ask for confirmation and install!!!
# command: stats

# 5. SYNCBOX
#
# mkdir ~/Syncbox
# echo "pi@lab.local" > ~/.syncbox
#
# Commands:
# push
# pull

# ----------------======---------------

# + LOAD DMT DEPS

# LOGNAME=$(logname 2>/dev/null)

# # Returns error in two known occasions:
# # 1) after "dmt update [device]" which calls "./install" *via ssh -e*
# # 2) on linux machines when executing "se" (command in background screen)
# if [ $? -ne 0 ]; then # error
#   LOGNAME_HOME="$HOME"
# else
#   if macos; then
#     #LOGNAME_HOME="/Users/$(whoami)"
#     LOGNAME_HOME="$HOME"
#   else
#     LOGNAME_HOME="/home/$(logname)" # MAYBE IMPROVE??
#   fi
# fi

# LOGNAME_HOME="$HOME"
# DMT_PATH="$LOGNAME_HOME/.dmt"

# syncbox="pi@dmt.local"

# if [ -f ~/.syncbox ]; then
#   syncbox=`cat ~/.syncbox`
# fi

# cp with progress and speed of the transfer
alias cpp="rsync -ah --progress"

function compile {
  local cwd="`pwd`"
  cd "$DMT_PATH/shell"
  ./compile
  cd "$cwd"
}

# copies custom user javascript files which are loaded inside dmt-proc !
# each gets an instance of a "program"
## UPDATE: this (along with .scripts/copy_user_bootscripts was moved into node.js code -- inside dmt-user)
# function copy_core_bootscripts {
#   local script="$DMT_NODE_CORE/.scripts/copy_user_bootscripts"

#   if [ -f "$script" ]; then
#     local cwd="`pwd`"
#     cd "$DMT_NODE_CORE/.scripts"
#     ./copy_user_bootscripts
#     cd "$cwd"
#   fi
# }

function symlink_if_unlinked {
  local script="$DMT_NODE_CORE/.scripts/symlink_dmt_deps"

  if [ -f "$script" ]; then

    if [ ! -L "$DMT_NODE_CORE/dmt-bridge/node_modules" ]; then
      local cwd="`pwd`"
      cd "$DMT_NODE_CORE/.scripts"
      ./symlink_dmt_deps
      cd "$cwd"
    fi
  fi
}

function compile_gui_if_missing {
  if [ ! -f "$DMT_NODE_CORE/dmt-gui/gui-frontend-core/app/public/bundle.js" ]; then
    gui build
  fi
}

# Reload the environment
function rel {

  if [ -f "$DMT_PATH/shell/compile" ]; then
    compile
  fi

  if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
  fi
  if [ -f ~/.bashrc ]; then
    . ~/.bashrc
  fi
  if [ -f ~/.bash_profile ]; then
    . ~/.bash_profile
  fi
}

# Usage:
# "al [enter]" - opens Sublime editor on the ~/.dmt
# or "al [any function name]" to see the source for the function directly in terminal without having to open source files
function al {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}al [function]${NC} ${GRAY}show bash function source${NC}\n"
    return
  fi

  which highlight > /dev/null 2>&1

  if [ $? -eq 0 ]; then
    type "$1" | highlight -O xterm256 -s darkbone --syntax bash
  else
    type "$1"
  fi
}

function loop {
  while true; do "$@"; sleep 2; done
}

function latest {
  local num=5
  if [ -n "$1" ]; then
    num="$1"
  fi

  ls -tp | grep -v /$ | head -"$num"
}

function newscript {
  if [ -n "$1" ]; then
    if [ -f "$1" ]; then
      printf "${RED}File already exists${NC}\n"
    else
      echo "#!/usr/bin/env node" > "$1"
      echo '"use strict"' >> "$1"
      ux "$1"
    fi
  else
    echo "Usage: newscript [file]"
  fi
}

function os {
  cat /etc/os-release
}

# ---------------------------

# function gr {
#   if [ -z "$1" ]; then
#     printf "${YELLOW}Usage:${NC}\n"
#     echo "gr search_term [where]"
#     return
#   fi

#   local pattern="$1"
#   local where="."

#   if [ -n "$2" ]; then
#     where="$2"
#   fi
#   # http://www.computerhope.com/unix/ugrep.htm

#   grep -rI --exclude-dir="\.svn" --exclude-dir="\.git" "$pattern" "$where" --color -n
# }

function mac {
  system_profiler SPNetworkDataType | grep Wi-Fi -A10
  ifconfig en0
}

# dep for reload:
# sudo apt-get install -y xdotool
function kiosk {
  if macos; then
    printf "${RED}Cannot run on macOS${NC}\n"
    return
  fi

  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    echo

    printf "${GREEN}edit: ${GRAY}edit kiosk configuration file${NC}\n"
    printf "${GREEN}reload: ${GRAY}reload currently set url in kiosk browser${NC}\n"
    printf "${GREEN}restart: ${GRAY}restart kiosk browser (for example on configuration change)${NC}\n"

    if [ -f ~/.config/lxsession/LXDE-pi/autostart ]; then
      printf "\n${MAGENTA}Current kiosk setup:${NC}\n"
      cat ~/.config/lxsession/LXDE-pi/autostart | grep ^@/usr/bin/chromium-browser
    fi

    return
  fi

  case "$1" in

    edit)

      local loc1="/var/lib/dietpi/dietpi-software/installed/chromium-autostart.sh"
      local loc2=~/.config/lxsession/LXDE-pi/autostart
      local loc3=/home/pi/.config/lxsession/LXDE-pi/autostart

      if [ -f "$loc1" ]; then
        sudo nano "$loc1"
      elif [ -f "$loc2" ]; then
        nano "$loc2"
      elif [ -f "$loc3" ]; then
        nano "$loc3"
      fi

      ;;

    reload)

      # if [ ! -f ~/.config/lxsession/LXDE-pi/autostart ]; then
      #   printf "${YELLOW}Kiosk configuration missing...${NC}\n"
      #   return
      # fi

      #printf "${MAGENTA}Note: this only reloads the currently open url, if you changed it, you have to call [kiosk restart]${NC}\n"

      which xdotool > /dev/null 2>&1

      if [ $? -eq 0 ]; then
        export DISPLAY=":0"
        WID=$(xdotool search --onlyvisible --class chromium|head -1)
        xdotool windowactivate ${WID}
        xdotool key ctrl+F5
      else
        printf "${RED}xdotool missing, please install with: ${GRAY}sudo apt-get -y install xdotool${NC}\n"
      fi

      printf "${GREEN}Reloaded...${NC}\n"

      ;;

    restart)

      if [ ! -f ~/.config/lxsession/LXDE-pi/autostart ]; then
        printf "${YELLOW}Kiosk configuration missing...${NC}\n"
        return
      fi

      sudo killall chromium-browser
      printf "${MAGENTA}Please copy and execute this command:${NC}\n"
      echo "export DISPLAY=\":0\"; $(cat ~/.config/lxsession/LXDE-pi/autostart | grep ^@/usr/bin/chromium-browser | sed 's/^@//') &"

      ;;

    *)
      printf "${RED}Unknown request${NC}\n"
      ;;

  esac
}


#### systemd

function shut {

  if ! macos && [ -f "/etc/fstab" ] ; then
    which lsblk > /dev/null 2>&1

    # lsblk exists
    if [ $? -eq 0 ]; then
      local labels=()

      # read all present labels via lsblk
      while read label do
      do
        if [ -n "$label" ] && [ "$label" != "LABEL" ]; then
          labels+=("$label")
        fi
      done < <(lsblk -o LABEL)

      # read /etc/fstab
      while read line
      do
        local label=$(echo "$line" | awk '{print $1}' | sed 's/LABEL=//')
        local path=$(echo "$line" | awk '{print $2}')

        array_contains_element "$label" "${labels[@]}"

        if [ $? -eq 0 ]; then
          if [ ! -d "$path" ]; then
            printf "${YELLOW}/etc/fstab:${NC} ${CYAN}Directory ${path} ${RED}not found, system wouldn't boot, aborting ...${NC}\n"
            return
          fi
        else
          printf "${YELLOW}/etc/fstab:${NC} ${CYAN}Label ${label} ${RED}not found on the system with lsblk, system wouldn't boot, aborting ...${NC}\n"
          return
        fi
      done < <(cat /etc/fstab | grep '^LABEL')
    else
      printf "${YELLOW}lsblk missing${NC}, no additional safety checks performed on /etc/fstab ...\n"
      printf "${MAGENTA}Install lsblk${NC}\n"
    fi
  fi

  if [ "$1" == 'reboot' ] || [ "$1" == 'r' ]; then
    if is_rpi; then
      # fix: "This profile appears to be in use by another Chromium process (543)...""
      if [ -d /home/pi/.config/chromium ]; then
        rm /home/pi/.config/chromium/Singleton*
      fi
    fi

    save_dmt_state

    printf "${MAGENTA}Rebooting...${NC}\n"
    sudo reboot
  elif [ "$1" == 'rr' ]; then
    # https://unix.stackexchange.com/questions/183095/last-resort-linux-terminal-command-to-reboot-over-ssh-in-case-of-a-kernel-bu
    echo s > /proc/sysrq-trigger
    echo u > /proc/sysrq-trigger
    echo s > /proc/sysrq-trigger
    echo b > /proc/sysrq-trigger
  else
    if [ -n "$1" ]; then
      local seconds=0
      local val=0
      local desc=""
      local denom=""

      convert_to_seconds seconds val desc denom "$1"

      if [ "$denom" == "s" ]; then
        printf "${RED}Please specify shutdown delay in minutes or hours${NC}\n"
        return
      else
        echo
        printf "${CYAN}Shutting down in ${MAGENTA}${desc}${NC} ${CYAN}...${NC}\n"
        echo
        # sleep $seconds

        se -n shutdown_task "$1" execute_shutdown
      fi
    else
      read -r -p "Are you sure you want to shut the device down (instead of rebooting)? [Y/n] " response
      if [[ ! $response =~ ^([nN])$ ]]
      then
        execute_shutdown
      fi
    fi
  fi
}

function execute_shutdown {
  printf "${RED}Shutting down...${NC}\n"
  if macos; then
    off
  else
    save_dmt_state

    sudo shutdown -h now
  fi
}

function res {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}res [service] ${GRAY}= sudo systemctl restart [service]${NC}\n"
  else
    sudo systemctl restart "$@"
    printf "${GREEN}Done.${NC}\n"
  fi
}

function reb {
  printf "${MAGENTA}Rebooting...${NC}\n"
  shut reboot
}

function srv {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"

    printf "${GREEN}srv [service]${NC} ${GRAY}show status${NC}\n"
    printf "${GREEN}srv [service] [command]${NC} ${GRAY}run command, ex.: start|stop|reload|restart|enable|disable${NC}\n"
    printf "${GREEN}srv [service] cat${NC} ${GRAY}show service specification${NC}\n"
    printf "${GREEN}srv [service] edit${NC} ${GRAY}edit service specification${NC}\n"
    printf "${GREEN}srv [service] log${NC} ${GRAY}see service log${NC}\n"
    echo
    printf "${GREEN}srv ls${NC} ${GRAY}show services in /etc/systemd/system${NC}\n"
    printf "${GREEN}srv cd${NC} ${GRAY}move to /etc/systemd/system${NC}\n"
    printf "${GREEN}srv cd2${NC} ${GRAY}move to /lib/systemd/system${NC}\n"

    #printf "${GREEN}${NC} ${GRAY}${NC}\n"

    echo

    printf "Dir: ${MAGENTA}/etc/systemd/system${NC}\n"
    printf "Dir (system): ${MAGENTA}/lib/systemd/system${NC}\n"

    return
  fi

  if [ -z "$2" ]; then
    if [ "$1" == "ls" ]; then
      ls -la /etc/systemd/system/*.service
    elif [ "$1" == "cd" ]; then
      cd /etc/systemd/system
    elif [ "$1" == "cd2" ]; then
      cd /lib/systemd/system
    else
      sudo systemctl status "$1"
    fi
  elif [ "$2" == "cat" ]; then
    local loc1="/etc/systemd/system/${1}.service"
    local loc2="/lib/systemd/system/${1}.service"

    if [ -f "$loc1" ]; then
      printf "${YELLOW}Found${NC} ${GREEN}$loc1${NC}\n\n"
      cat "$loc1"
    elif [ -f "$loc2" ]; then
      printf "${YELLOW}Found${NC} ${GREEN}$loc2${NC}\n\n"
      cat "$loc2"
    else
      printf "${RED}unknown service $1${NC}\n"
    fi
  elif [ "$2" == "edit" ]; then
    local loc1="/etc/systemd/system/${1}.service"
    local loc2="/lib/systemd/system/${1}.service"

    if [ -f "$loc1" ]; then
      printf "${YELLOW}Found${NC} ${GREEN}$loc1${NC}\n\n"
      sudo nano "$loc1"
      sudo systemctl daemon-reload
    elif [ -f "$loc2" ]; then
      printf "${YELLOW}Found${NC} ${GREEN}$loc2${NC}\n\n"
      sudo nano "$loc2"
      sudo systemctl daemon-reload
    else
      printf "${RED}unknown service $1${NC}\n"
    fi
  elif [ "$2" == "log" ]; then
    journalctl -u "${1}.service"
  else
    sudo systemctl "$2" "$1"
  fi
}

function d {
  dmt "$@"
}

function de {
  local desk="$HOME/Desktop"
  # if [ ! -d $desk ]; then
  #   #printf "~/Desktop not found, using ${YELLOW}/tmp${NC}\n"
  #   #desk="/tmp"
  #   docker_cmd "$@"
  #   return
  # fi
  # if [ -z "$1" ]; then
  if [ -d "$desk" ]; then
    cd "$desk"
    local dir="`pwd`"
    AWESOME_SILENCE=true awesome_cd . "$1"
    if [ "`pwd`" == "$dir" ] && [ -n "$1" ]; then
      printf "Created ${YELLOW}~/Desktop/$1${NC}\n"
      mkdir "$1"
      cd "$1"
    fi
  else
    printf "${RED}${desk} not found${NC}\n"
  fi

  # "$1" is not present at this point, but we keep this code for possible change in the future
  # else
  #   dmt "$@"
  # fi
}

# moves file to desktop
function dm {
  local desk="$HOME/Desktop"

  local matching_file=''
  get_matching_file matching_file "$1"
  matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

  if [ ! -f "$matching_file" ]; then
    printf "${RED}No file matches the pattern ${YELLOW}$1${NC}\n"
  else # found file
    local target="$desk/$matching_file"
    if [ -f "$target" ]; then
      printf "Trying to move ${YELLOW}$matching_file${NC} to ${CYAN}~/Desktop${NC} ...\n"
      printf "${RED}Problem: ${YELLOW}~/Desktop/$matching_file ${NC}already exists - not overwriting${NC}\n"
      return
    else
      mv "$matching_file" "$target"
      printf "${GREEN}Moved ${YELLOW}$matching_file ${GREEN}to ${CYAN}~/Desktop${NC}\n"
    fi
  fi
}

###### Arduino

alias esp8266="cd ~/Library/Arduino15/packages/esp8266/hardware/esp8266"

function arduino {
  awesome_cd ~/Documents/Arduino/libraries "$1"
}

###### Deps management

function query {
  if [ -z "$1" ]; then
    for d in `ls -1 ~/Install/npm/` ; do
      do_query "$d"
    done
    # this is faster (done in parallel), but:
    # - we would need to move query out to ~/bin/query because xargs cannot work with functions
    # - results would be in random order
    #ls -1 ~/Install/npm | xargs -n 1 -P 10 query
  else
    local matching_folder=''
    get_matching_folder matching_folder ~/Install/npm "$1"
    matching_folder=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_folder")

    if [ -n "$matching_folder" ]; then
      do_query "$matching_folder"
    else
      printf "${RED}$1 doesn't match any package in ~/Install/npm${NC}\n"
    fi
  fi
}

function do_query {
  local matches=$(ls -l /usr/local/lib/node_modules | grep "$1" | wc -l)
  if [ ! $matches -eq 0 ]; then
    version=$(version "/usr/local/lib/node_modules/${1}")
    matches=$(ls -l /usr/local/lib/node_modules | grep "Install/npm" | grep "$1" | wc -l)

    if [ $matches == 0 ]; then
      printf "${YELLOW}${1} ${version} (unstable)${NC}\n"
    else
      printf "${GREEN}${1} ${version} (stable)${NC}\n"
    fi
  else
    printf "${RED}${1} (not linked)${NC}\n"
  fi
}



######

function message {
  if [ -z "$1" ]; then
    echo "Usage: message msg [title]"
  else
    local title=""
    if [ -n "$2" ]; then
      title="$2"
    fi
    osascript -e "display notification \"$1\" with title \"$title\""
  fi
}

function ctrl_c_trap() {
  CTRL_C=true # crap, still doesn't get called in time!!!
  echo "** Trapped CTRL-C in ~/.bash_aliases"
}

# warning: STAYS FOREVER INSIDE TERMINAL CONSOLE after first set
function set_ctrl_c_trap {
  CTRL_C=false
  trap ctrl_c_trap INT
}

function convert_to_seconds {
  local time_input="$5"
  local _seconds=0
  local _val=0
  local _desc=""
  local _denom=""

  # default is minutes!
  if [[ "$time_input" =~ [0-9]+$ ]] ; then
    #_seconds=$time_input
    _seconds=$time_input
    _val=$time_input
    _desc="${_seconds}s"
    _denom="s"
  else
    local number=${time_input:0:${#time_input}-1}
    if [[ "$time_input" =~ s$ ]] ; then
      _seconds=$number
      _val=$number
      _desc="${_seconds}s"
      _denom="s"
    elif [[ "$time_input" =~ m$ ]] ; then
      _seconds=$(( $number*60 ))
      _val=$number
      _desc="${number}m"
      _denom="m"
    elif [[ "$time_input" =~ h$ ]] ; then
      _seconds=$(( $number*3600 ))
      _val=$number
      _desc="${number}h"
      _denom="h"
    elif [[ "$time_input" =~ d$ ]] ; then
      _seconds=$(( $number*3600*24 ))
      _val=$number
      _desc="${number}d"
      _denom="d"
    fi
  fi

  eval "$1='$_seconds'"
  eval "$2='$_val'"
  eval "$3='$_desc'"
  eval "$4='$_denom'"
}

function timer {
  if [ -z "$1" ]; then
    echo "Usage: timer [1|1s|5min|2h|3d] [message]"
  else

    local seconds=0
    local val=0
    local desc=""
    local denom=""

    convert_to_seconds seconds val desc denom "$1"

    if [ -n "$desc" ]; then
      printf "${YELLOW}Waiting for ${desc} ...${NC}\n"

      case $denom in
        "s" )
          sleep $seconds
          # for (( i=$val; i>0; i-- ))
          # do
          #   printf "${GRAY}$(date +"%H:%M") ${MAGENTA}$i ${denom} to go ...${NC}\n"
          #   sleep 1
          # done
          printf "${GREEN}Time's up!${NC}\n"
          ;;
        "m" )
          for (( i=$val; i>0; i-- ))
          do
            printf "${GRAY}$(date +"%H:%M") ${MAGENTA}$i ${denom} to go ...${NC}\n"
            sleep 60
          done
          printf "${GREEN}Time's up!${NC}\n"
          ;;
        "h" )
          for (( i=$val; i>0; i-- ))
          do
            printf "${GRAY}$(date +"%H:%M") ${MAGENTA}$i ${denom} to go ...${NC}\n"
            sleep 3600
          done
          printf "${GREEN}Time's up!${NC}\n"
          ;;
        "d" )
          for (( i=$val; i>0; i-- ))
          do
            printf "${GRAY}$(date +"%H:%M") ${MAGENTA}$i ${denom} to go ...${NC}\n"
            sleep 86400
          done
          printf "${GREEN}Time's up!${NC}\n"
          ;;
      esac

      # following check won't matter because CTRL_C is not actually set to TRUE yet even if trap function ctrl_c_trap was supposedly called first (?)
      #if [ -z ${CTRL_C+x} ] || [ $CTRL_C] ; then
      #  echo $CTRL_C
      if macos; then
        shift
        local msg="$@"
        if [ -n "$msg" ]; then
          message "$msg" "${desc} is up"
        else
          message "${desc} is up" "Time's up"
        fi
      fi
    else
      printf "${RED}Error in argument${NC}\n"
    fi
  fi
}

function sleepmin {
  if [ -z "$1" ]; then
    echo "Usage:"
    echo "sleepmin [min]"
  else
    sleep $(( $1*60 ))
  fi
}

########

function repl {
  if [ -f "repl.js" ]; then
    printf "${YELLOW}Using local ./repl.js${NC}\n"
    node --use_strict ./repl.js
  else
    node --use_strict ~/Projects/scripts/repl.js
  fi
}

function get_npm_version() {
  npm --no-git-tag-version version patch
}

function npm_patch {
  local ver=$(get_npm_version)
  printf "Updated package.json to ${YELLOW}${ver}${NC}\n"
}

function publish_npm {
  local version=$(get_npm_version)
  printf "Updated package.json to ${YELLOW}${version}${NC}\n"

  git add package.json
  git commit --amend
  printf "\n${RED}Ammended to:${NC}\n"
  git log -n 1

  git tag $version
  printf "\n${BLUE}Tagged git repo with ${version}${NC}\n\n"

  npm publish
  printf "\n${MAGENTA}Published ${version}${NC}\n"
}

function tag {
  #get highest tag number
  VERSION=`git describe --abbrev=0 --tags`

  #replace . with space so can split into an array
  VERSION_BITS=(${VERSION//./ })

  #get number parts and increase last one by 1
  VNUM1=${VERSION_BITS[0]}
  VNUM2=${VERSION_BITS[1]}
  VNUM3=${VERSION_BITS[2]}
  VNUM3=$((VNUM3+1))

  #create new tag
  NEW_TAG="$VNUM1.$VNUM2.$VNUM3"

  echo "Updating $VERSION to $NEW_TAG"

  #get current hash and see if it already has a tag
  GIT_COMMIT=`git rev-parse HEAD`
  NEEDS_TAG=`git describe --contains $GIT_COMMIT`

  #only tag if no tag already (would be better if the git describe command above could have a silent option)
  if [ -z "$NEEDS_TAG" ]; then
      echo "Tagged with $NEW_TAG (Ignoring fatal:cannot describe - this means commit is untagged) "
      git tag $NEW_TAG
      git push --tags
  else
      echo "Already a tag on this commit"
  fi
}

# repl
# function re {
#   if [ -f ./mix.exs ]; then
#     printf "${YELLOW}mix console?${NC}\n"
#   elif [ -f ./package.json ]; then
#     printf "${YELLOW}node${NC}\n"
#     node
#   else
#     node
#   fi
# }

alias preety="prettier --write --print-width 160 --single-quote *.js"

function nd {
  run_on_file "$1" "node debug" '*.js'
}

# tip: install from github: npm install --save user/repo
function ni {
  if [ "`pwd`" == "/Users/${USER}/Projects/node" ]; then
    printf "${RED}Ups, get out of this directory${NC}\n"
    return
  fi

  if [ -z "$1" ]; then
    #echo "Usage: ni [npm_module]"
    if [ -f "package.json" ]; then
      npm install
    else
      node_init
    fi
  else
    if [ ! -f "package.json" ]; then
      node_init
    fi
    npm install "$@" --save
  fi
}

function node_init {
  if [ -f "package.json" ]; then
    printf "${RED}package.json already exists${NC}\n"
  else
    local name="$1"
    if [ -z "$name" ]; then
      name=$(basename "`pwd`")
    fi
    sed -e "s/<name>/${name}/g" "$DMT_PATH/etc/templates/node/package.json" > package.json
    if [ ! -f ".gitignore" ]; then
      #echo "node_modules" > .gitignore
      ignore_node
    fi
    printf "${YELLOW}package.json${NC} created with name ${CYAN}${name}${NC}\n"
  fi
}

function ignore_node {
  cp "$DMT_PATH/etc/templates/node/gitignore" .gitignore
}

function setup_linter {
  if [ ! -f "package.json" ]; then
    printf "${RED}Not in a npm project${NC}\n"
  else
    echo "Installing deps..."

    (
      export PKG=eslint-config-airbnb;
      npm info "$PKG@latest" peerDependencies --json | command sed 's/[\{\},]//g ; s/: /@/g' | xargs npm install --save-dev "$PKG@latest"
    )
    # source: https://www.npmjs.com/package/eslint-config-airbnb

    # had issues with eslint-plugin-jsx-a11y errors
    # npm install eslint-plugin-jsx-a11y --save-dev
    # npm install eslint --save-dev
    # npm install eslint-plugin-import --save-dev
    # npm install eslint-plugin-react --save-dev
    # npm install eslint-config-airbnb --save-dev

    echo
    update_linter
  fi
}

# function update_linter {
#   local conf="$DMT_PATH/etc/templates/node/.eslintrc.json"
#   if [ -f "$conf" ]; then
#     printf "${YELLOW}Copying ${conf} ...${NC}\n"
#     cp "$conf" .
#     printf "${GREEN}done${NC}\n"
#   else
#     printf "${RED}Cannot complete (or update) linter because file ${conf} is missing...${NC}\n"
#   fi
# }

function restart_airplay {
  sudo systemctl restart shairport-sync
}
alias airplay_restart="restart_airplay"

function nid {
  if [ -z "$1" ]; then
    echo "Usage: nid [npm_module]"
  else
    npm install "$1" --save-dev
  fi
}

function dn {
  doc npm "$@"
}

function linked {
  #ls -l $HOME/n/lib/node_modules | grep ^l
  find /usr/local/lib/node_modules -type l -d 1 -exec ls -lah {} \;
  #RECURSIVE and SLOWER: find $HOME/n/lib/node_modules -type l -exec ls -lah {} \;

  #find ~/Dropbox -type l -exec ls -lah {} \;

  #Recursive: ls -lR $HOME/n/lib/node_modules | grep ^l
  #find "$HOME/n/lib/node_modules" -type l -name '.git' -prune -o -print | uniq | grep "$1" -i
}

function global {
  #printf "${YELLOW}/usr/local/bin/n${NC}\n"
  #echo
  local n_direct_install=~/n/lib/node_modules
  local n_homebrew_install=/usr/local/lib/node_modules

  local global_node_modules

  if [ -d $n_direct_install ]; then # installed n directly
    global_node_modules=$n_direct_install
  elif [ -d $n_homebrew_install ]; then # installed via homebrew
    global_node_modules=$n_homebrew_install
  else
    printf "${RED}n installation not found...${NC}\n"
    return
  fi


  if [ -z "$1" ]; then
    ls -la $global_node_modules
    printf "${YELLOW}${global_node_modules}${NC}\n"
    if [ -d ~/n/lib/node_modules ]; then # installed n directly
      printf "${YELLOW}n installed directly...${NC}\n"
      global_node_modules=~/n/lib/node_modules
    elif [ -d /usr/local/lib/node_modules ]; then # installed via homebrew
      printf "${YELLOW}n installed via homebrew...${NC}\n"
      global_node_modules=/usr/local/lib/node_modules
    fi
  else
    awesome_cd $global_node_modules "$1"
  fi
}

############### NODE.JS -- END

alias psq="sudo -u postgres psql"

# fix permissions
function fixperm() {
  local dir="$1"
  if [ -z "$dir" ]; then
    dir="."
  fi
  chmod -R uog+r "$dir"
}

# fix permissions
function fixperm2() {
  local dir="$1"
  if [ -z "$dir" ]; then
    dir="."
  fi
  sudo chown -R 1000:1000 "$dir"
  chmod -R 644 "$dir"
}

function find_recent() {
  find . -type f -mmin -$1 -not -name .DS_Store -exec ls -lh {} \; | sed 's/\.\///' | awk '{print $5, substr($0,index($0,$9))}'
  #| cut -d' ' -f6-
}

alias min="find_recent 2"
alias hour="find_recent 60"
alias day="find_recent 1440"

alias mk="mkdir"
alias mkp="mkdir -p"
k () { mkdir -p "$@" && cd "$_"; }

# sum column of numbers...
# 1 lala
# 234 aaavdfv
# 54 sdfdsf
function total {
  cat $1 | awk '{s+=$1} END {printf "Sum: %.0f\n", s}'
}

alias aria="aria2c" # http://aria2.sourceforge.net/ - The next generation download utility.

function wh {

  if [[ "$1" =~ \.com$ ]]; then
    local match=$(whois "$1" | grep "No match for domain" | wc -l)
    if [ ! $match -eq 0 ]; then
      printf "${GREEN}${1} is available${NC}\n"
    else
      printf "${RED}${1} not available${NC}\n"
    fi
  elif [[ "$1" =~ \.io$ ]]; then
    local match=$(whois "$1" | grep "NOT FOUND" | wc -l)
    if [ ! $match -eq 0 ]; then
      printf "${GREEN}${1} is available${NC}\n"
    else
      printf "${RED}${1} not available${NC}\n"
    fi
  elif [[ "$1" =~ \.eu$ ]]; then
    local match=$(whois "$1" | grep "Status: AVAILABLE" | wc -l)
    if [ ! $match -eq 0 ]; then
      printf "${GREEN}${1} is available${NC}\n"
    else
      printf "${RED}${1} not available${NC}\n"
    fi
  else
    whois "$1"
  fi
}

function root {
  if macos; then
    sudo bash -l # makes process substitution (<) work: https://unix.stackexchange.com/questions/42973/bash-process-substitution-does-not-work-as-root-on-os-x
  else
    sudo -i
  fi
}

alias pb=pbcopy

alias fd="sudo fdisk -l"

# iterm2
alias normal='echo -e "\033]50;SetProfile=Default\a"'
alias large='echo -e "\033]50;SetProfile=LargeFont\a"'

#brew install highlight
#alias pcat="pygmentize -f terminal256 -O style=monokai -g"
function hcat {
  highlight -O xterm256 -s darkbone "$@"
}

# Save temporary command in ~/Desktop
#
function temp_cmd {
  local cmd=~/Desktop/temp_cmd

  if [ "$1" == "remove" ] && [ -f "$cmd" ]; then
    rm $cmd
    printf "${YELLOW}~/temp_cmd deleted${NC}\n"
    return
  fi

  if [ -f "$cmd" ]; then
    chmod u+x $cmd
    local contents=`cat $cmd`
    printf "${YELLOW}${contents}${NC}\n"
    $cmd
  else
    nano "$cmd"
    if [ -f "$cmd" ]; then
      chmod u+x $cmd
      local contents=`cat $cmd`
      printf "Command saved: ${YELLOW}${contents}${NC}\n\n"
      printf "You can run it with: ${MAGENTA}temp_cmd${NC}\n"
    fi
  fi
}

# themes: highlight -w
# in sublime there is SublimeHighlight plugin (use for Elixir since there is no Elixir syntax in highlight)
function code {
  if [ -z "$1" ]; then
    echo "Copies code in rtf format for slides"
    echo
    echo "code example.js"
    echo "code themes"
    echo "code example.js dark"
    echo "code example.js [theme]"
  else
    local theme="bright"
    if [ -n "$2" ]; then
      if [ "$2" == 'dark' ]; then
        theme="darkbone"
      else
        theme="$2"
      fi
    fi

    if [ "$1" == 'themes' ]; then
      highlight -w
    else
      highlight -O rtf -s $theme $1 | pb
    fi
    # moe, acid
  fi
}

function snip {
  snippet "$@"
}

function snippet {

  local sublime_snippets_folder="/Users/${USER}/Library/Application Support/Sublime Text 3/Packages/User/"

  if [ -z "$1" ] || [ "$1" == "-h" ]; then
    #printf "${YELLOW}Usage:${NC}\n"
    #echo "${opts[@]}"
    ls "$sublime_snippets_folder" | grep "snippet$"
    echo
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}snippet edit [keyword]${NC} ${GRAY}edit${NC}\n"
    printf "${GREEN}snippet create [keyword]${NC} ${GRAY}create and edit (ext is added automatically)${NC}\n"
    printf "${GREEN}snippet cd${NC} ${GRAY}move to directory with snippets${NC}\n"
    return
  fi

  declare -a opts=(
    "edit"
    "create"
    "cd"
  )

  local matching_opt=''
  opts_matcher matching_opt "$1" "${opts[@]}"
  if [ $? -ne 0 ]; then # error
    matching_opt="[DEFAULT]" # default ... will trigger *) case below
  fi

  shift

  case "$matching_opt" in
    edit)
       local dir="`pwd`"
       cd "$sublime_snippets_folder"
       run_on_file "$1" "subl" '*.sublime-snippet'
       cd "$dir"
      ;;

    create)
        local dir="`pwd`"
        cd "$sublime_snippets_folder"
        local snippet_file="${1}.sublime-snippet"
        cat > "${snippet_file}" <<EOF
<snippet>
  <content><![CDATA[
const \${1} = require('\${1}');
]]></content>
  <!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
  <tabTrigger>require</tabTrigger>
  <!-- Optional: Set a scope to limit where the snippet will trigger -->
  <scope>source.js</scope>
</snippet>
EOF
        subl "${snippet_file}"
        cd "$dir"
      ;;

    cd)
      cd "$sublime_snippets_folder"
      ;;

    *)
      ls -1 "$sublime_snippets_folder" | grep "snippet$" | grep "$@"
      ;;
  esac
}

# utility function
function current_usage {
  local output=$(du -sh | awk '{ print $1 }')
  printf "${YELLOW}${output}${NC}\n"
}

function freespace {
  printf "Free:\t ${GREEN}`df -h . | tail -1 | awk '{ print $4 }'`${NC}\n"
}

function space {
  local dir="`pwd`"
  if [ -n "$1" ]; then
    if [ -d "$1" ]; then
      dir="$1"
    else
      printf "${RED}No such directory${NC}\n"
      return
    fi
  fi

  if [ ! "$dir" == $HOME ] && [ ! "$dir" == '/' ]; then
    if [ "$dir" == "`pwd`" ]; then
      printf "Current: "
      current_usage
    else
      printf "${dir}: "
      local cwd="`pwd`"
      cd "$dir"
      current_usage
      cd "$cwd"
    fi
  fi
  freespace
}

# utility function
function usage_for {
  printf "${1} "
  if [ -d "${1}" ]; then
    cd "$1"
    current_usage
  else
    printf "${RED}No such directory${NC}\n"
  fi
}

function usage {
  if macos; then
    #ls -1d -- */ | xargs -I{} du -sh -- {} | gsort -hr # probably need: "brew install coreutils" for gsort
    find . -maxdepth 1 -type d -print0 | xargs -0 -I{} du -sh {} | gsort -hr # probably need: "brew install coreutils" for gsort
  else
    find . -maxdepth 1 -type d -print0 | xargs -0 -I{} du -sh {} | sort -hr
    #ls -1d */ | xargs -I{} du -sh {} | sort -hr
  fi
  #ls -1d */ | xargs -I{} du -sh {} && du -sh | sort -r
}

function count {

  local dir=""
  if [ -z "$1" ]; then
    dir="."
  else
    if [ -d "$1" ]; then
      dir="$1"
      printf "${YELLOW}${dir}:${NC}\n"
    else
      printf "${RED}No such directory${NC}\n"
      return
    fi
  fi

  printf "${CYAN}Directories: "
  find "$dir" -maxdepth 1 ! -path . ! -path "*/.git" -type d | wc -l | xargs
  printf "${GREEN}Files:       "
  find "$dir" -maxdepth 1 ! -path "*/.DS_Store" ! -path "*/.git" -type f | wc -l | xargs
  printf "${NC}"

  # echo
  # printf "${CYAN}Directories (Recursive): "
  # find "$dir/" ! -path . ! -path "*/.git/*" -type d | wc -l | xargs # "/" is needed if we use "count ~/path/to/symlinked_directory", it's changed to: "count ~/path/to/symlinked_directory/"
  # printf "${GREEN}Files: (Recursive):      "
  # find "$dir/" ! -path "*/.DS_Store" ! -path "*/.git/*" -type f | wc -l | xargs
  # printf "${NC}"
}

function countr {

  count "$@"

  local dir=""
  if [ -z "$1" ]; then
    dir="."
  else
    if [ -d "$1" ]; then
      dir="$1"
      printf "${YELLOW}${dir}:${NC}\n"
    else
      printf "${RED}No such directory${NC}\n"
      return
    fi
  fi

  echo
  printf "${CYAN}Directories (Recursive): "
  find "$dir/" ! -path . ! -path "*/.git/*" -type d | wc -l | xargs # "/" is needed if we use "count ~/path/to/symlinked_directory", it's changed to: "count ~/path/to/symlinked_directory/"
  printf "${GREEN}Files: (Recursive):      "
  # If you have issues here: for example mismatch in number of files in two directories where one is a copy of another,
  # it's almost certainly symlinks issue, find out like this:
  # Directory A) find . -type f > ~/Desktop/a.txt
  # Directory B) find . -type f > ~/Desktop/b.txt
  # Compare: diff ~/Desktop/a.txt ~/Desktop/b.txt
  find "$dir/" ! -path "*/.DS_Store" ! -path "*/.git/*" -type f | wc -l | xargs
  printf "${NC}"
}

function lines {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}lines [file.txt] ${GRAY}counts the number of lines in the file${NC}\n"
  else
    cat "$1" | wc -l
  fi
}

function space2rem {
  if [ "$EUID" -ne 0 ]; then
    echo "please run under root - execute: root"
    return
  fi
  find /var/folders -name "*.iscachebmp" -type f -exec rm -v "{}" \;
  find /private/var/folders -name "*.iscachebmp" -type f -exec rm -v "{}" \;
}

# swap files or directories
function swap {
  if [ -n "$1" ] && [ -n "$2" ]; then
    swap_once "$1" "$2"
  elif [ -f "config.json.sample" ] && [ -f "config.json" ]; then
    swap_once "config.json.sample" "config.json"
  elif [ -f "david_wallet" ] && [ -f "default_wallet" ]; then
    swap_once "david_wallet" "default_wallet"
  fi
}

function swap_once {
  mv "$1" /tmp/switch_temp
  mv "$2" "$1"
  mv /tmp/switch_temp "$2"
}

# rename file or directory by adding _ at the end
# or if _ is present, remove it
function ren {
  local subject
  if [[ "$1" == */ ]]; then
    subject=$(echo "$1" | sed 's/.$//')
  else
    subject="$1"
  fi

  local new
  if [[ "$subject" == *_ ]]; then
    new=$(echo "$subject" | sed 's/.$//')
  else
    new="${subject}_"
  fi

  mv "$subject" "$new"
}

# Example:
#
# $ find . | grep core_ext
# ./config/initializers/core_ext.rb
# ./spec/lib/core_ext_spec.rb
#
# $ grab 2
# ./spec/lib/core_ext_spec.rb ===> (also copied on clipboard)
#
# Without arguments the default is to grab the first line
grab() {
  local num=1
  if [ -n "$1" ]; then
    num=$1
  fi
  local line=`$(history | tail -2 | head -1 | cut -d" " -f4-) | sed "${num}q;d" | sed 's/commit //'`
  echo $line | tr -d "\n" | pbcopy
  echo $line
}

function chrome {
  "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome" --disable-new-avatar-menu &
}

function sleepin {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC} sleepin 10 (min)\n"
  else
    local delay=$(($1*60))
    sleep $delay && pmset sleepnow # with && - if you cancel with ctrl+c it works correctly (semicolon doesn't!)
  fi
}

alias pumar="kill -SIGUSR2 `ps aux | grep tcp://0.0.0.0:$port | grep puma | awk '{ print $2 }'`"
alias updatedb="sudo /usr/libexec/locate.updatedb"

alias blackie="cd /Volumes/BLACKIE/Backups.backupdb/eclipse/Latest/Macintosh\ HD$HOME"
alias sublime="cd '$HOME/Library/Application Support/Sublime Text 3/Packages/User'"

# ping server (ex. server.com) or "resource" (http://server.com/file)
function pi {
  local target="1.0.0.1"
  if [ -n "$1" ]; then
    if [[ "$1" =~ \/ ]]; then
      if [[ $(curl -I --write-out %{http_code} --silent --output /dev/null "$@") == "200" ]]; then
        printf "${GREEN}âœ“ CurlPing OK, Returned status 200${NC}\n"
      else
        printf "${RED}âœ– NOT FOUND${NC}\n"
      fi
    else
      printf "${GRAY}Pinging ${@} ...${NC}\n"
      if [[ $(ping -c 1 "$@" 2>&1) == *"0% packet loss"* ]]; then
        printf "${GREEN}âœ“ Ping OK${NC}\n"
      else
        printf "${RED}âœ– NO CONN${NC}\n"
      fi
    fi
  else
    printf "${GRAY}Pinging ${target} ...${NC}\n"
    if [[ $(ping -c 1 "$target" 2>&1) == *"0% packet loss"* ]]; then
      printf "${GREEN}âœ“ Ping OK${NC}\n"
    else
      printf "${RED}âœ– NO CONN${NC}\n"
    fi
  fi
}

function ux {
  matching_file=''
  get_matching_file matching_file "$1"
  matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

  if [ -f "$matching_file" ]; then
    printf "chmod u+x ${YELLOW}$matching_file${NC}\n"
    chmod u+x "$matching_file"
  else
    printf "${RED}File not found${NC}\n"
  fi
}

function archive {
  if [ -n "$1" ]; then
    mv $1 ~/Misc/Archive/
  else
    cd ~/Misc/Archive/
  fi
}

function archive_short {
  if [ -n "$1" ]; then
    mv $1 ~/Misc/Archive/Short\ Term/
  else
    cd ~/Misc/Archive/Short\ Term/
  fi
}

function getlog {
  remote -h "$1" "cat /var/log/syslog | grep shairpo > /tmp/log.txt"
  scp "${1}:/tmp/log.txt" .
}

function remove_ds_store {
  find . -name ".DS_Store" -depth -exec rm {} \;
}

function remove_ds_global {
  sudo find / -name ".DS_Store" -depth -exec rm {} \;
}

# *** nginx on server ***

alias ci="curl -I"

function nginx_executable() {
  local executable2
  if [ -f "/usr/sbin/nginx" ]; then
    executable2="/usr/sbin/nginx"
  elif [ -f "/opt/nginx/sbin/nginx" ]; then
    executable2="/opt/nginx/sbin/nginx"
  elif [ -f "/usr/local/bin/nginx" ]; then
    executable2="/usr/local/bin/nginx"
  else
    executable2=""
  fi
  eval "$1=${executable2}"
}

function nr {
  # lighttpd
  if [ -f /etc/lighttpd/lighttpd.conf ]; then
    printf "${YELLOW}Found lighttpd, reloading configuration...${NC}\n"

    if macos; then

      # if pid file is found,
      # - there is no process with this pid, try to start lighttpd
      # - if there is a process with this pid, send it a kill signal (reloads the configuration)
      if [ -f /var/run/lighttpd.pid ]; then
        local pid=$(cat /var/run/lighttpd.pid)

        local procs=$(ps -p $pid -o comm=) # find process executable by process id

        if [ "$procs" == "" ]; then # lighttpd is not there
          printf "${RED}lighttpd is not running (stale .pid file, possible configuration error!!)...${NC}\n"
          printf "${YELLOW}trying to start it...${NC}\n"
          sudo /usr/local/bin/lighttpd -f/etc/lighttpd/lighttpd.conf -D
        else
          sudo kill -9 $pid
        fi
      else
        printf "${YELLOW}lighttpd is not running...${NC}\n"
        printf "${YELLOW}trying to start it...${NC}\n"
        sudo /usr/local/bin/lighttpd -f/etc/lighttpd/lighttpd.conf -D
        return
      fi
    else
      sudo service lighttpd force-reload
    fi
    #printf "${GREEN}ok.${NC}\n"
    return
  fi

  # nginx
  if hash service 2>/dev/null; then
    service nginx reload
  else
    local executable=''
    nginx_executable executable

    if [ -n "$executable" ]; then
      local output
      if macos; then
        output=$($executable -s reload 2>&1)
      else
        output=$(sudo $executable -s reload 2>&1)
      fi
      if [ -z "$output" ]; then
        printf "${GREEN}OK${NC}\n"
      else
        printf "${RED}${output}${NC}\n"
      fi
    else
      if [ -f "/etc/init.d/nginx" ]; then
        sudo /etc/init.d/nginx restart
      else
        printf "${RED}Can't find nginx${NC}\n"
      fi
    fi
  fi
}

alias nr2="sudo service nginx restart"

function nt {
  # lighttpd
  if [ -f /etc/lighttpd/lighttpd.conf ]; then
    #printf "${YELLOW}Found lighttpd, reloading configuration...${NC}\n"
    local cmd="lighttpd"
    if [ -f /usr/sbin/lighttpd ]; then # on debian it wasn't in path after install
      cmd="/usr/sbin/lighttpd"
    fi
    $cmd -t -f /etc/lighttpd/lighttpd.conf
    printf "${YELLOW}Warning: even if syntax is ok, lighttpd might fail to run for semantic reasons${NC}\n"
    printf "${YELLOW}when using nr for restating, run twice to be sure!${NC}\n"
    return
  fi

  # nginx
  if [ -d /opt/nginx ]; then
    printf "Folder: ${YELLOW}/opt/nginx${NC}\n"
  elif [ -d /etc/nginx ]; then
    printf "Folder: ${YELLOW}/etc/nginx${NC}\n"
  fi

  local executable=''
  nginx_executable executable

  if [ -z "$executable" ]; then
    printf "${RED}Can't find nginx executable${NC}\n"
  fi

  if [ -n "$executable" ]; then
    printf "Executable: ${YELLOW}${executable}${NC}\n"
    local output
    if macos; then
      output=$($executable -t 2>&1)
    else
      output=$(sudo $executable -t 2>&1)
    fi
    if [[ $output == *"test is successful"* ]]; then
      printf "${GREEN}${output}${NC}\n"
    else
      printf "${RED}${output}${NC}\n"
    fi
  fi
}

function ne {
  if macos; then
    tail -f /var/log/nginx/error.log
  else
    sudo tail -f /var/log/nginx/error.log
    #printf "${RED}Not on the server${NC}\n"
  fi
}

function sites {
  if macos; then
    awesome_cd ~/.dmt/user/sites "$1"
  else
    if [ -d /opt/nginx/conf/sites/ ]; then
      cd /opt/nginx/conf/sites/
    elif [ -d /etc/nginx/sites ]; then
      cd /etc/nginx/sites
    elif [ -d /etc/nginx/sites-available ]; then
      cd /etc/nginx/sites-available
    elif [ -d /etc/apache2/sites-available ]; then
      cd /etc/apache2/sites-available
    else
      printf "${RED}Can't find nginx sites folder${NC}\n"
    fi
  fi

  if [ -n "$1" ]; then
    if [ "$1" == "ports" ]; then
      grep -r "localhost" .
    else
      grep -r "localhost" . | grep "$1"
    fi
  fi
}

function hosts {
  if [ -f /private/etc/hosts ]; then
    sudo nano /private/etc/hosts
  elif [ -f /etc/hosts ]; then
    sudo nano /etc/hosts
  else
    printf "${RED}Cannot find hosts file${NC}\n"
  fi
}

# ******

alias list="ls -la | grep"

function ta {
  tail -n 25 "$@"
}

function ta50 {
  tail -n 50 "$@"
}

function ta100 {
  tail -n 100 "$@"
}

# function v() {
#   if [[ "$1" == *".js" ]]; then
#     echo '"use strict"' > $1
#   else
#     touch "$1"
#   fi
# }

# function copp {
#   pwd | sed 's/\/Users\/david/~/' | tr -d '\n' | pbcopy
# }

# MacOS niceties

function lock {
  if [ -n "$1" ]; then
    local seconds=0
    local val=0
    local desc=""
    local denom=""

    convert_to_seconds seconds val desc denom "$1"
    sleep $seconds
  fi

  /System/Library/CoreServices/ScreenSaverEngine.app/Contents/MacOS/ScreenSaverEngine
}

function lock2 {
  if [ -n "$1" ]; then
    local seconds=0
    local val=0
    local desc=""
    local denom=""

    convert_to_seconds seconds val desc denom "$1"
    sleep $seconds
  fi

  /System/Library/CoreServices/"Menu Extras"/User.menu/Contents/Resources/CGSession -suspend
}

function off {
  #trap 'return' INT

  if [ -n "$1" ]; then
    local seconds=0
    local val=0
    local desc=""
    local denom=""

    convert_to_seconds seconds val desc denom "$1"
    sleep $seconds
  fi

  #alarm light off # crap dependecy!!! what if network or target device is unreachable, it could hang here

  pmset sleepnow
}

function suck {
     #--recursive \
     #--html-extension \
     #--no-parent
     #--wait=9 \
     # -U mozilla \
     #--exclude-domains quantserve.com
     #--domains filepi.com
     #--limit-rate=20K \

  # mirror ? -m

  domain=`ruby -ruri -e "puts URI.parse('$1').host"`

  mkdir -p "$domain"
  cd "$domain"

  wget \
     --page-requisites \
     --convert-links \
     --adjust-extension \
     --html-extension \
     --random-wait \
     --domains $domain \
     --no-check-certificate \
     --span-hosts \
     -e robots=off \
     -U "Mozilla/5.0 (X11; U; Linux; en-US; rv:1.9.1.16) Gecko/20110929 Firefox/3.5.16" \
       $1

  printf "\n${YELLOW}Got all resources from $domain. To get all of them, remove --domains flag and run again${NC}\n"
}

alias suckjs="phantomjs ~/Projects/scripts/save_page.js"

# miha's solution: https://gist.github.com/mrfoto/c6072e4fede3a6fe0f6b
function ssh {
  if [ -f /usr/local/bin/sshrc ]; then
    printf "\033]6;1;bg;red;brightness;162\a\033]6;1;bg;green;brightness;209\a\033]6;1;bg;blue;brightness;147\a"
    #https://www.iterm2.com/documentation-escape-codes.html
    #echo -e "\033]6;1;bg;green;brightness;0\a"
    command sshrc "$@"
    # caused problems ....
    # now we still have a problem when trying to log into OpenWRT (dropbear) powered ssh for example...)
    # if [ ! $? -eq 0 ]; then
    #   printf "${MAGENTA}Failed ssh via sshrc, trying /usr/bin/ssh${NC}\n"
    #   /usr/bin/ssh "$@"
    # fi
    echo -e "\033]6;1;bg;*;default\a"
  else
    command ssh "$@"
  fi
}

function ssh2 {
  command ssh "$@"
}

# iperf2
function speed {
  local host=''
  if [ -n "$1" ]; then
    host="$1"
  else
    local network_id=''
    network_def_reader host network_id "iperf"
  fi

  if [ -z "$host" ]; then
    printf "${RED}Host not specified either as a first argument or in networks.def (iperf: [ip]])${NC}\n"
    return
  fi

  which iperf > /dev/null 2>&1

  if [ $? -eq 0 ]; then
    printf "${GREEN}Measuring...${NC}\n"
  else
    printf "${MAGENTA}iperf is missing, installing...${NC}\n"
    sudo apt-get -y install iperf
    printf "\n${GREEN}Testing...${NC}\n"
  fi

  iperf -c "$host"
}

function speed3 {
  local host=''
  if [ -n "$1" ]; then
    host="$1"
  else
    local network_id=''
    network_def_reader host network_id "iperf"
  fi

  if [ -z "$host" ]; then
    printf "${RED}Host not specified either as a first argument or in networks.def (iperf: [ip]])${NC}\n"
    return
  fi

  if [ "$1" == "-h" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}speed${NC} ${GRAY}measures sending to default host${NC}\n"
    printf "${GREEN}speed [host]${NC} ${GRAY}specify another host${NC}\n"
    printf "${GREEN}speed [host] -R${NC} ${GRAY}reverse mode - server is sending${NC}\n"
    printf "${GREEN}speed [host] -u${NC} ${GRAY}udp test${NC}\n"
    return
  fi

  if [ -n "$1" ] && [[ "$1" != "-"* ]]; then
    host="$1"
    shift
  fi

  which iperf3 > /dev/null 2>&1

  if [ $? -eq 0 ]; then
    printf "${GREEN}Measuring...${NC}\n"
  else
    printf "${MAGENTA}iperf3 is missing, installing...${NC}\n"
    sudo apt-get -y install iperf3
    printf "\n${GREEN}Testing...${NC}\n"
  fi

  iperf3 $@ -c $host
}

function reset_npm {
  rm -rf node_modules
  npm cache clean
  npm install
}

alias np="npm publish"

function json {
  curl -s "$1" | jq .
}

# post_json data.json localhost:3000/api/readings
function post_json {
  curl -H "Content-Type: application/json" -d @"$1" "$2"
}

function ee {
  if macos; then
    awesome_cd ~/Misc/Electronics "$1"
  fi
}

function flash_usage {
  local sectors="$1"
  printf "${YELLOW}Usage:${NC}\n"
  printf "${GREEN}flash image.img 2${NC} ${GRAY}flash image.img to /dev/rdisk2${NC}\n"
  printf "${GREEN}flash read 2${NC} ${GRAY}read full image from /dev/rdisk2 to ./image.img${NC}\n"
  printf "${GREEN}flash read 2 16gb${NC} ${GRAY}read sectors 0..${sectors} from /dev/rdisk2 to ./image.img${NC}\n"
  #printf "${GREEN}flash read 2 default${NC} ${GRAY}read sectors 0..${sectors} from /dev/rdisk2 to ./image.img${NC}\n"
  printf "${GREEN}flash read 2 [nSectors]${NC} ${GRAY}read sectors 0..nSectors from /dev/rdisk2 to ./image.img${NC}\n"
}

function flash {
  local file_pattern="$1"
  local disk_n="$2"

  #local defaultSectors="20000768" # 9.5GB, divisible by 4096 for optimal sector alignment
  local sectors16gb="31116288" # 16GB


  if [ "$1" == "-h" ] || [ -z "$1" ]; then
    printf "${YELLOW}diskutil list:${NC}\n\n"
    diskutil list
    flash_usage "$sectors16gb"
    return
  fi

  if [ -z "$file_pattern" ]; then
    printf "${YELLOW}diskutil list:${NC}\n\n"
    diskutil list
    printf "${YELLOW}Usage:${NC}\n"
    echo "flash file.img diskN"
    return
  fi

  if [ "$1" == "read" ]; then
    if [ -z "$disk_n" ]; then
      printf "${YELLOW}diskutil list:${NC}\n\n"
      diskutil list

      printf "${MAGENTA}You have to specify the disk number from where to create the image${NC}\n"
      echo

      flash_usage "$sectors16gb"
    else
      local image="image.img"

      if [ -f "$image" ]; then
        printf "${RED}image.img already exists${NC}\n"
        return
      fi

      if [ -z "$3" ]; then
        printf "${GREEN}Copying full image to ${YELLOW}${image}${NC}\n"
        time sudo dd if="/dev/rdisk${disk_n}" of="${image}" bs=64k
      else
        local sectors

        if [ "$3" == "16gb" ] || [ "$3" == "16GB" ]; then
          printf "${GREEN}Reading first 16gb from sd card ... ${NC}\n"
          sectors="$sectors16gb"
        else
          sectors="$3"
        fi

        printf "${GREEN}Copying sectors${NC} 0..${sectors} to ${YELLOW}${image}${NC}\n"

        # Usually the number of sectors will be a multiple of some power of 2, and you can increase the copying speed
        # by increasing the block size and decreasing the count, keeping the product constant.
        if ! (( $sectors % 64 )) ; then
          printf "${MAGENTA}Optimal speed: number of sectors divisible by 64 - reading 128 sectors (64K) at a time${NC}\n"
          # for default 20000000 sectors it takes around 150s to copy data from sd card
          # 1 sector = 512b
          # 64K seems to be quite optimal, no difference with 1M, but faster than 32K or less
          time sudo dd if="/dev/rdisk${disk_n}" of="${image}" bs=64k count="$((sectors/128))"
        elif ! (( $sectors % 32 )) ; then
          printf "${MAGENTA}Almost optimal speed: number of sectors divisible by 32 - reading 64 sectors (32K) at a time${NC}\n"
          time sudo dd if="/dev/rdisk${disk_n}" of="${image}" bs=32k count="$((sectors/64))"
        else
          time sudo dd if="/dev/rdisk${disk_n}" of="${image}" bs=512 count="${sectors}"
        fi
      fi

      if [ -f "image.img" ]; then
        sudo chown $(whoami) image.img
        if macos; then
          sudo chgrp staff image.img
        fi
      fi
    fi

    return
  fi

  matching_file=''
  get_matching_file matching_file "$file_pattern"
  matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

  if [ ! -f "$matching_file" ]; then
    printf "${RED}No such file: ${file_pattern}${NC}\n"
  else
    if [ -z "$disk_n" ]; then
      printf "${YELLOW}diskutil list:${NC}\n\n"
      diskutil list

      printf "${MAGENTA}You have to specify the disk number where to flash ${GREEN}${matching_file}${NC}\n"
      echo

      flash_usage "$sectors"
    else
      printf "Flashing ${YELLOW}${matching_file}${NC} to ${RED}rdisk${disk_n}${NC}...\n"
      read -r -p "Sure????? (you will be asked for sudo password) [Y/n] " response
      if [[ ! $response =~ ^([nN])$ ]]
      then
        printf "${YELLOW}Flashing after password...${NC} Press Ctrl+T to see progress\n"
        diskutil unmountDisk "/dev/disk${disk_n}"
        time sudo dd if="$matching_file" of="/dev/rdisk${disk_n}" bs=64m # changed from: 1m
        diskutil eject "/dev/disk${disk_n}"
        printf "${GREEN}done.${NC} ${YELLOW}You can take the SD card out now.${NC}\n"
      fi
    fi
  fi
}

function vol2 {
  local origin="`pwd`"
  local IFS=$'\n' # default is " " and then array is not correctly constructed when there is spaces in filenames
  cd `find /Volumes -maxdepth 1 -type d ! -path . | grep -v "/Volumes$" | grep -v "Macintosh HD" | grep -v "WINDOWS" | grep -v "volume2"`
  if [ -n "$1" ]; then
    awesome_cd . "$1"
    if [ $? -eq 1 ]; then
      cd "$origin"
    fi
  fi
}

function cpd {
  cp $1 ~/Desktop/
}

function md {
  if [ -f "$1" ] || [ -d "$1" ]; then
    mv "$1" ~/Desktop
    if [ $? -eq 0 ]; then
      printf "${YELLOW}Moved ${1} to ~/Desktop\n"
    fi
  else
    printf "${RED}No such file or directory${NC}\n"
  fi
}

function yd {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}yd [id]${NC} - ${GRAY}download a video${NC}\n"
    printf "${GREEN}yd [id1] [id2] [id3]${NC} - ${GRAY}download multiple videos${NC}\n"
    printf "${GREEN}yd [playlistId]${NC} - ${GRAY}download a playlist${NC}\n"
    printf "${GREEN}yd --autonumber [playlistId]${NC} - ${GRAY}download a playlist, autonumbered${NC}\n"
    return
  fi

  if [ "$1" == "--autonumber" ]; then
    shift
    ydpl "$@"
    return
  fi

  if [ -z "$2" ]; then
    youtube-dl -- "$1"
  else
    for var in "$@"
    do
      yd "$var"
    done
  fi
}

function ydpl {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}ydpl [playlistId]${NC} ${GRAY}downloads autonumbered playlist${NC}\n"
    return
  else
    youtube-dl -i -o "%(playlist_index)s %(title)s - %(id)s.%(ext)s" -- "$1"
    #youtube-dl -o "%(playlist_index)s-%(title)s - %(id)s.%(ext)s" -- "$1"
  fi
}

function mp3_helper {
  # duplicate
  ffmpeg -i "$1" -acodec libmp3lame -aq 2 "$1".mp3
}

function mp3 {

  if [ "$1" == "." ]; then
    find *.m4a -type f | xargs -I@ bash -c "$(declare -f mp3_helper) ; mp3_helper \"@\" "
    return
  fi

  if [ -z "$2" ]; then
    if [ -f "$1" ]; then
      ffmpeg -i "$1" -acodec libmp3lame -aq 2 "$1".mp3
      # batch --
      # for foo in *.m4a; do ffmpeg -i "$foo" -acodec libmp3lame -aq 2 "${foo%.m4a}.mp3"; done
    else
      youtube-dl -x --audio-format mp3 -- "$1"
    fi
  else
    for var in "$@"
    do
      mp3 "$var"
    done
  fi
}


function mp4 {
  if [ -n "$1" ]; then
    for file in "$@"
    do
      if [ -f "$file" ]; then
        # http://www.bugcodemaster.com/article/convert-videos-mp4-format-using-ffmpeg
        ffmpeg -i "$file" "$file".mp4 -preset veryfast
      else
        echo "File $file doesn't exist"
      fi
    done
  else
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}mp4 file1 file2 file3 ...${NC} ${GRAY}convert different video formats to mp4${NC}\n"
  fi
}


alias vlc="open -n /Applications/VLC.app"

# Requirement for static server: npm install -g http-server
# Other: elixir, mina, jekyll, node, npm
function serve {
  if [ -f ./server ]; then
    printf "${YELLOW}./server $1${NC}\n"
    ./server $1
  elif [ -f ./mix.exs ]; then
    printf "${YELLOW}mix phoenix.server${NC}\n"
    mix phoenix.server
    # or: iex -S mix phoenix.server
  elif [ -f ./server.js ]; then
    printf "${YELLOW}node server.js${NC}\n"
    node server.js
  elif [ -f ./package.json ] && [ $(ls-scripts | grep 'serve' | wc -l) -gt 0 ]; then
    npm run serve
  # npm install -g npm-ls-scripts
  elif [ -f ./package.json ] && [ $(ls-scripts | grep '^start' | wc -l) = 1 ]; then
    printf "${YELLOW}npm run start${NC}\n"
    npm run start
  elif [ -f ./truffle.js ]; then
    printf "${YELLOW}testrpc --port 8700${NC}\n"
    testrpc --port 8700
  elif [ -f ./index.js ]; then
    local args=$@
    printf "${YELLOW}nodemon index.js ${args}${NC}\n"
    nodemon index.js $args
  elif [ -f ./elm-package.json ]; then
    printf "${YELLOW}elm reactor${NC}\n"
    elm reactor
    #elm-reactor
  elif [ -d _site ]; then
    printf "${YELLOW}jekyll serve${NC}\n"
    jekyll serve
  else
    printf "${YELLOW}http-server -p 3000${NC}\n"
    http-server -p 3000
  fi
}

alias ra="touch index.js"

function tests {

  # test single file
  if [ -n "$1" ] && [ -d "tests" ]; then

    local pattern="$1"
    shift

    local matching_file=''
    get_matching_file matching_file "tests/$pattern" "*.js"
    matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

    if [ ! -f "$matching_file" ]; then
      return
    fi

    printf "${YELLOW}tape ${matching_file} | tap-spec${NC}\n"

    tape "$matching_file" | tap-spec
  else

    if [ -f ./test ]; then
      printf "${YELLOW}./test ${1}${NC}\n"
      ./test "$1"
    fi

    #if grep -Fq '"test":' package.json
    if [ -f 'package.json' ] && [ -d "tests" ]; then

      which tape > /dev/null 2>&1

      if [ $? -ne 0 ]; then
          printf "${RED}missing 'tape' command${NC}\n"
          printf "${YELLOW}npm install -g tape${NC}\n"
          return
      fi

      which tap-spec > /dev/null 2>&1

      if [ $? -ne 0 ]; then
          printf "${RED}missing 'tap-spec' command${NC}\n"
          printf "${YELLOW}npm install -g tap-spec${NC}\n"
          return
      fi

      if grep -Fq '"tape"' package.json
      then

        printf "${YELLOW}tape 'tests/**/*.js'${NC}\n"
        tape 'tests/**/*.js' | tap-spec

        # printf "${YELLOW}npm run test${NC}\n"
        # npm run test

        # if grep -Fxq "import test from 'ava'" test.js
        # then
        #   ava
        # else
        #   printf "${YELLOW}NODE_ENV=test node test.js${NC}\n"
        #   NODE_ENV=test node test.js
        # fi
      # elif [ -d "tests" ]; then
      #   printf "${YELLOW}tape 'tests/**/*.js' | tap-spec${NC}\n"
      #   tape 'tests/**/*.js' | tap-spec
      else
        if [ -f "package.json" ]; then
          if grep -Fq '"test":' package.json
          then
            printf "${YELLOW}npm run test${NC}\n"
            npm run test
            #printf "${RED}Tests not defined${NC}\n"
          fi
        fi
      fi
    fi
  fi
}

function makedocs {
  documentation build "$@" -f html -o docs --shallow
}

function doc {
  node ~/Projects/node/docs/doc.js "$@"
}

# https://gist.github.com/davidhq/9883d43146d1fb2c2c00

# function source_code {
#   local matching_files=$(find . -name "*.${2}" -not -path "*/.git/*" -not -path "*/node_modules/*" -not -path "*/Godeps/*" -not -path "*/elm-stuff/*" -not -path "*/deps/*" -not -path "*/_build/*" -not -path "*/target/*" -not -path "*/dist/*" -not -path "*/bower_components/*" -not -path "*/tmp/*")
#   eval "$1='${matching_files}'"
# }

# npm install -g cloc
function cloc {
  command cloc . --exclude-dir=.git,log,node_modules,Godeps,elm-stuff,deps,_build,target,dist,vendor,bower_components,tmp,deploy,distroot,Deps --exclude-lang=XML
}

function loc {
  if [ -z "$1" ] || [ "$1" == "all" ]; then
    loc js "$2"
    loc ls "$2"
    loc coffee "$2"
    loc c "$2"
    loc cpp "$2"
    loc cs "$2"
    loc cc "$2"
    loc java "$2"
    loc scala "$2"
    loc jsx "$2"
    loc sh "$2"
    loc sol "$2"
    loc ex "$2"
    loc exs "$2"
    loc erl "$2"
    loc go "$2"
    loc rs "$2"
    loc hs "$2"
    loc elm "$2"
    loc rb "$2"
    loc py "$2"
    loc html "$2"
    loc md "$2"
    loc css "$2"
    #loc xml "$2"
    loc json "$2"
  else
    IFS=$'\n'

    local files=$(find . -name "*.${1}" -not -path "*/.git/*" -not -path "*/log/*" -not -path "*/node_modules/*" -not -path "*/assets/*" -not -path "*/Godeps/*" -not -path "*/elm-stuff/*" -not -path "*/deps/*" -not -path "*/_build/*" -not -path "*/target/*" -not -path "*/dist/*" -not -path "*/vendor/*" -not -path "*/bower_components/*" -not -path "*/tmp/*" -not -path "*/deploy/*" -not -path "*/distroot/*" -not -path "*/Deps/*")
    # local files=''
    # source_code files "$1"

    if [ -n "$files" ]; then
      printf "${GREEN}${1}${NC}\n"
      if [ "$2" == "total" ]; then
        local total=$(wc -l $files | grep "total")
        if [ -n "$total" ]; then
          echo $total
        else
          wc -l $files
        fi
      else
        wc -l $files
      fi
      echo
    fi

    unset IFS
  fi
}

function stats {
  local tempdir=$(mktemp -d)
  if [ -d ".git" ]; then
    gitstats . "$tempdir"
    open "$tempdir/authors.html"
  else
    printf "${RED}Not a git repo...${NC}\n"
  fi
}

function loct {
  loc "all" "total"
}

# alias deb="DEBUG=true"

# function diag {
#   echo "DIAGNOSTICS for the project: to implement"
# }

function replace {
  if [[ -z "$1" || -z "$2" || -z "$3" ]]; then
    printf "${YELLOW}Usage:${NC} replace file.txt original replacement\n"
  elif [ ! -f "$1" ]; then
    printf "${YELLOW}No such file${NC}\n"
  elif [ ! -w "$1" ]; then
    if macos; then
      printf "${YELLOW}Copy this:${NC} sudo sed -i '' \"s/${2}/${3}/g\" \"$1\"\n"
    else
      printf "${YELLOW}Copy this:${NC} sudo sed -i \"s/${2}/${3}/g\" \"$1\"\n"
    fi
  else
    if macos; then
      sed -i '' "s/${2}/${3}/g" "$1"
    else
      sed -i "s/${2}/${3}/g" "$1"
    fi
  fi
}

alias di="find . -type d"

function php {
  if [ -z "$1" ]; then
    # Interactive shell
    command php -a
  elif [ -f "$1" ]; then
    # Execute file
    command php "$1"
    echo
  elif [ -n "$1" ]; then
    # params
    command php $@
  #else
  #  echo "No such file: $1"
  fi
}

function a {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    echo "a [term] [context_lines]"
    echo "a --[lang] [term] [context_lines]"
  else
    clear && printf '\e[3J' # completely clear the terminal

    if [ -n "$2" ] && [[ $1 == *--* ]]; then
      if [ -n "$3" ]; then
        command ack "$1" -i -Q -C "$3" -- "$2"
      else
        command ack "$1" -i -Q -- "$2"
      fi
    # if [[ $@ == *--* ]]; then
    #   # ack --ruby something
    #   command ack -i -Q "$@"
    else
      # -k flag to say "Only search the files that ack recognizes the types for"
      if [ -n "$2" ]; then
        command ack -i -k -Q -C "$2" -- "$1"
      else
        command ack -i -k -Q -- "$@"
      fi
      #command ack -i -k -Q -- $@
      # there were problems with -- $Q with: ack "Refresh to" -C 3
      # look below
    fi
  fi
}

function j {
  if [ -z "$@" ]; then
    calc
  else
    awk "BEGIN{print $*}"
  fi
}

function = {
  echo "$@" | bc -l
}

# also: calc (brew install calc)

alias kk='nano ~/k.txt'

function tun {
  local config=~/.ngrok-config.yml
  if [ -z "$1" ]; then
    printf "${YELLOW}cat ${config}${NC}\n\n"
    cat "$config"
  else
    ~/Install/ngrok/bin/ngrok -config="$config" start "$1"
  fi
}

function readable {
  if [ -z "$1" ]; then
    echo "usage: readable [server]"
    echo "usage: readable ."
  elif [ "$1" == "." ]; then
    chmod -R ugo+r .
  else
    ssh "$1" "chmod -R ugo+r /var/www"
    echo "ssh"
  fi
}

function compare {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}compare dir1 dir2${NC}\n"
    printf "${GREEN}compare --size-only dir1 dir2${NC}\n"
  else
    local sizeonly=""
    if [ "$1" == "--size-only" ]; then
      sizeonly="--size-only"
      printf "${YELLOW}Sizeonly...${NC}\n"
      shift
    fi

    local params="-n -rli --delete $sizeonly"
    # -n = dry run
    #-rlptgoD
    rsync $params --exclude="._*" "$1"/ "$2"/
  fi
}

# stable project - using a git worktree feature:
# https://git-scm.com/docs/git-worktree
# so projects under ~/Projects/stable are actually a stable checkouts of projects elsewhere
function stable {
  if [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "stable . ${GRAY}checkout stable version of the project in ~/Projects/stable${NC}\n"
    printf "stable [project] ${GRAY}move to stable project${NC}\n"
  elif [ "$1" == "." ]; then
    local project="${PWD##*/}"
    local target="$HOME/Projects/stable/$project"

    if [ -d "$target" ]; then

      if [ -f ~/Projects/backups/nuke.rb ]; then
        printf "${YELLOW}${target} already exists...${NC}\n"
        #~/Projects/backups/nuke.rb "$target"
        rm -rf "$target"
      else
        printf "${RED}${target} already exists...${NC}\n"
        printf "Please execute: ${RED}rm -rf ${target}${NC} manually\n"
        return
      fi
    fi

    git worktree prune

    if git rev-parse --quiet --verify stable > /dev/null; then
      git branch -d stable
    fi

    git worktree add -b stable "$target" master

    printf "${GREEN}\nNow copying some things over (copy more manually if needed):${NC}\n"

    if [ -d data ]; then
      printf "${YELLOW}data...${NC}\n"
      cp -r data "$target/"
      printf "${GREEN}ok${NC}\n"
    fi

    if [ -d node_modules ]; then
      printf "${YELLOW}node_modules...${NC}\n"
      cp -r node_modules "$target/"
      printf "${GREEN}ok${NC}\n"
    fi

    echo
    printf "${MAGENTA}Project stabilified in ${target}${NC}\n"

  else
    awesome_cd ~/Projects/stable "$1"
  fi
}

# function ss {
#   local dir="`pwd`"
#   p "$1"
#   if [ ! "$dir" == "`pwd`" ]; then
#     subl -n .
#   fi
# }

function sn {
  local dir="`pwd`"
  n "$1"
  if [ ! "$dir" == "`pwd`" ]; then
    subl -n .
  fi
}

function pog {
  p "$1"
  og
}
#!/bin/bash

function lint {
  ~/Misc/CodeLintEslint/node_modules/eslint/bin/eslint.js "$@" -c ~/Misc/CodeLintEslint/.eslintrc.json --resolve-plugins-relative-to ~/Misc/CodeLintEslint

  # maybe implement looking for local linter first ... (probably not needed)
  # if [ ! -f ./node_modules/.bin/eslint ] || [ ! -f ./.eslintrc.json ]; then
  # ...
  # fi
}

function pretty {
  local opts=" "

  if [ "$1" == "c" ]; then
    shift
    opts="-c"
  fi

  if [ "$1" == "l" ]; then
    shift
    opts="-l"
  fi

  if [ "$1" == "write" ] || [ "$1" == "w" ]; then
    shift
    opts="--write"
  fi

  ~/Misc/CodeLintEslint/node_modules/prettier/bin-prettier.js --config ~/Misc/CodeLintEslint/prettier.config.js --plugin-search-dir ~/Misc/CodeLintEslint "$opts" "$@"
}
#!/bin/bash

function conf {

  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    echo

    printf "${GREEN}pi:${NC} sudo raspi-config\n"
    printf "${GREEN}wifi:${NC} /etc/wpa_supplicant/wpa_supplicant.conf\n"
    printf "${GREEN}dietpi:${NC} /DietPi/dietpi.txt\n"
    printf "${GREEN}net:${NC} /etc/network/interfaces\n"
    printf "${GREEN}sshd:${NC} /etc/ssh/sshd_config\n"
    printf "${GREEN}lighttpd:${NC} /etc/lighttpd/lighttpd.conf\n"
    printf "${GREEN}haproxy:${NC} /etc/haproxy/haproxy.cfg\n"
    printf "${GREEN}dnsmasq:${NC} /etc/dnsmasq.conf\n"
    printf "${GREEN}hostapd:${NC} /etc/hostapd/hostapd.conf\n"
    printf "${GREEN}alsa:${NC} /usr/share/alsa/alsa.conf\n"
    printf "${GREEN}fstab:${NC} /etc/fstab\n"
    printf "${GREEN}mpd:${NC} /etc/mpd.conf || ~/.mpdconf\n"
    printf "${GREEN}samba:${NC} /etc/samba/smb.conf\n"
    printf "${GREEN}syncthing:${NC} ~/.config/syncthing/config.xml\n"
    printf "${GREEN}munin:${NC} /etc/munin/munin.conf\n"
    printf "${GREEN}munin-node:${NC} /etc/munin/munin-node.conf\n"
    printf "${GREEN}mosquitto:${NC} /etc/mosquitto/mosquitto.conf ${GRAY}${NC}\n"

    return
  fi

  declare -a opts=(
    "pi"
    "wifi"
    "dietpi"
    "net"
    "sshd"
    "lighttpd"
    "haproxy"
    "dnsmasq"
    "hostapd"
    "ap"
    "alsa"
    "fstab"
    "mpd"
    "samba"
    "syncthing"
    "munin"
    "munin-node"
    "mosquitto"
  )

  local matching_opt=''
  opts_matcher matching_opt "$1" "${opts[@]}"
  if [ $? -ne 0 ]; then # error
    printf "${RED}Unknown package${NC}\n"
    return
  fi

  shift

  case "$matching_opt" in

    pi)
      sudo raspi-config
      ;;

    wifi)
      wifi_setup "from_conf" "$@"
      ;;

    dietpi)
      sudo nano /DietPi/dietpi.txt
      ;;

    net)
      local conf="/etc/network/interfaces"

      if [ -f "${conf}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf}${NC}\n"
        sudo nano "${conf}"
      else
        printf "${RED}no networking config file found${NC}\n"
        return
      fi
      ;;

    sshd)
      local conf="/etc/ssh/sshd_config"

      if [ -f "${conf}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf}${NC}\n"
        sudo nano "${conf}"
      else
        printf "${RED}no sshd config file found${NC}\n"
        return
      fi
      ;;

    lighttpd)
      local conf="/etc/lighttpd/lighttpd.conf"

      if [ -f "${conf}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf}${NC}\n"
        sudo nano "${conf}"
      else
        printf "${RED}no lighttpd config file found${NC}\n"
        return
      fi
      ;;

    haproxy)
      local conf="/etc/haproxy/haproxy.cfg"

      if [ -f "${conf}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf}${NC}\n"
        sudo nano "${conf}"
      else
        printf "${RED}no haproxy config file found${NC}\n"
        return
      fi
      ;;

    dnsmasq)
      local conf="/etc/dnsmasq.conf"

      if [ -f "${conf}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf}${NC}\n"
        sudo nano "${conf}"
      else
        printf "${RED}no dnsmasq config file found${NC}\n"
        return
      fi
      ;;

    hostapd)
      printf "${YELLOW}Please use ${GREEN}conf ap${NC}\n"
      ;;

    ap)
      local conf="/etc/hostapd/hostapd.conf"

      if [ -f "${conf}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf}${NC}\n"
        sudo nano "${conf}"
      else
        printf "${RED}no hostapd config file found${NC}\n"
        return
      fi
      ;;

    alsa)
      local conf="/usr/share/alsa/alsa.conf"

      if [ -f "${conf}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf}${NC}\n"
        sudo nano "${conf}"
      else
        printf "${RED}no alsa config file found${NC}\n"
        return
      fi
      ;;

    fstab)
      local conf="/etc/fstab"

      if [ -f "${conf}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf}${NC}\n"
        sudo nano "${conf}"
      else
        printf "${RED}no fstab config file found${NC}\n"
        return
      fi
      ;;

    mpd)
      local conf="/etc/mpd.conf"
      local conf2="$HOME/.mpdconf"

      if [ -f "${conf}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf}${NC}\n"
        sudo nano "${conf}"
      elif [ -f "${conf2}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf2}${NC}\n"
        nano "${conf2}"
      else
        printf "${RED}no mpd config file found${NC}\n"
        return
      fi
      ;;

    samba)
      local conf="/etc/samba/smb.conf"

      if [ -f "${conf}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf}${NC}\n"
        sudo nano "${conf}"
      else
        printf "${RED}no samba config file found${NC}\n"
      fi
      ;;

    syncthing)
      local conf="$HOME/.config/syncthing/config.xml"
      local conf2="$HOME/Library/Application Support/Syncthing/config.xml"

      if [ -f "${conf}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf}${NC}\n"
        nano "${conf}"
      elif [ -f "${conf2}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf2}${NC}\n"
        nano "${conf2}"
      else
        printf "${RED}no syncthing config file found${NC}\n"
      fi
      ;;

    munin)
      local conf="/etc/munin/munin.conf"

      if [ -f "${conf}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf}${NC}\n"
        sudo nano "${conf}"
      else
        printf "${RED}no munin config file found${NC}\n"
      fi
      ;;

    munin-node)
      local conf="/etc/munin/munin-node.conf"

      if [ -f "${conf}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf}${NC}\n"
        sudo nano "${conf}"
      else
        printf "${RED}no munin-node config file found${NC}\n"
      fi
      ;;

    mosquitto)
      local conf="/etc/mosquitto/mosquitto.conf"

      if [ -f "${conf}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf}${NC}\n"
        sudo nano "${conf}"
      else
        printf "${RED}no mosquitto config file found${NC}\n"
      fi
      ;;

  esac
}

function wifi_setup {
  local conf="/etc/wpa_supplicant/wpa_supplicant.conf"

  local instr="wifi_setup"
  if [ "$1" == "from_conf" ]; then
    instr="conf wifi"
    shift
  fi

  if [ -f "${conf}" ]; then
    if [ -n "$1" ]; then
      wpa_passphrase "$@"
      return
    fi

    sudo nano "${conf}"
    printf "${MAGENTA}Never provide password in cleartext.\n${YELLOW}Use ${GREEN}${instr} [SSID]${NC} to generate encrypted password\n"
  else
    printf "${conf} ${RED}not found${NC}\n"
    return
  fi
}


function slog {

  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    echo

    printf "${GREEN}lighttpd|light: ${GRAY}/var/log/lighttpd/error.log${NC} \n"
    printf "${GREEN}haproxy: ${GRAY}root; tail -f /var/log/haproxy.log${NC}\n"
    # printf "${GREEN}sshd:${NC} /etc/ssh/sshd_config\n"
    # printf "${GREEN}alsa:${NC} /usr/share/alsa/alsa.conf\n"
    printf "${GREEN}mpd:${NC} /var/log/mpd/mpd.log\n"
    # printf "${GREEN}samba:${NC} /etc/samba/smb.conf\n"
    printf "${GREEN}mosquitto:${NC} /var/log/mosquitto/mosquitto.log ${GRAY}${NC}\n"

    return
  fi

  declare -a opts=(
    "dmt"
    "mpd"
    "lighttpd"
    "haproxy"
    "munin"
    "munin-node"
    "mosquitto"
  )

  local matching_opt=''
  opts_matcher matching_opt "$1" "${opts[@]}"
  if [ $? -ne 0 ]; then # error
    return
  fi

  shift

  case "$matching_opt" in
    dmt)
      dmt_log "$@"
      ;;

    mpd)
      tail -f /var/log/mpd/mpd.log
      ;;

    lighttpd)

      local conf="/etc/lighttpd/lighttpd.conf"

      if [ -f "${conf}" ]; then
        tail -f /var/log/lighttpd/error.log
      else
        printf "${RED}no lighttpd found${NC}\n"
        return
      fi

      ;;

    haproxy)

      local conf="/etc/haproxy/haproxy.cfg"

      if [ -f "${conf}" ]; then
        printf "Execute: ${MAGENTA}root; tail -f /var/log/haproxy.log${NC}\n"
      else
        printf "${RED}no haproxy found${NC}\n"
        return
      fi

      ;;

    mosquitto)

      local log="/var/log/mosquitto/mosquitto.log"

      if [ -f "${log}" ]; then
        printf "tail -f ${YELLOW}${log}${NC}\n"
        tail -f "$log"
      else
        printf "${RED}log not found${NC}\n"
      fi

      ;;

    munin)

      local log="/var/log/munin/munin-update.log"

      if [ -f "${log}" ]; then
        printf "tail -f ${YELLOW}${log}${NC}\n"
        tail -f "$log"
      else
        printf "${RED}log not found${NC}\n"
      fi

      ;;

    munin-node)

      local log="/var/log/munin/munin-node.log"

      if [ -f "${log}" ]; then
        printf "tail -f ${YELLOW}${log}${NC}\n"
        tail -f "$log"
      else
        printf "${RED}log not found${NC}\n"
      fi

      ;;

  esac
}
#!/bin/bash

############### Ports and Processes

# what is listening on port
function port {

  if [ "$1" == "-h" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}port${NC} ${GRAY}list all open ports${NC}\n"
    printf "${GREEN}port [num]${NC} ${GRAY}show the process that uses port [num]${NC}\n"
    printf "${GREEN}port [proc]${NC} ${GRAY}list all open ports held by specified process grep string${NC}\n"
    return
  fi

  if [[ "$1" =~ ^[0-9]+$ ]]; then
    lsof -i :$1
  elif [ -n "$1" ]; then
    if macos; then
      sudo lsof -i | grep "$1"
    else
      netstat -l -p | grep "$1"
    fi
  else
    if macos; then
      sudo lsof -i
    else
      netstat -l -p
    fi
  fi
}

function killport {
  port $1 | awk '{print $2}' | xargs kill -9
}

function proc {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}proc [process]${NC} ${GRAY}search all processes that match the term${NC}\n"
    return
  fi

  ps aux | grep -v "command -v openssl >/dev/null" | grep -v " grep " | grep -i --color=auto "$@"
  # grep -v "command -v openssl >/dev/null" ==> get rid of really big output when using over ssh, this process output includes big public key which often matches our grepping stuff
}

function killall {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}killall [term]${NC} ${GRAY}kills *all processes* matching the search term${NC}\n"
    return
  fi

  local proc=$(ps -ef | grep "${1}" | grep -v "command -v openssl >/dev/null" | grep -v grep | awk '{print $2}')

  if [ -n "$proc" ]; then
    echo "$proc" | xargs kill -9
    printf "${CYAN}Killed process ${proc}${NC}\n"
  else
    printf "${GRAY}No such process: ${1}${NC}\n"
  fi
  # grep -v "command -v openssl >/dev/null" ==> get rid of really big output when using over ssh, this process output includes big public key which often matches our grepping stuff
}

function port2 {
  lsof -n -i4UDP:$1
}

# list all the executable files in folder
function exe {
  if macos; then
    find . -type f -perm +111 -print
  else
    find . -type f -executable -print
  fi
}

function sr {
  if [ -z "$1" ]; then
    screen -r
  else
    screen -D "$1" > /dev/null 2>&1
    screen -r "$1"
  fi
}

function ss {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}ss [screen]${NC}\n"
  else
    screen -S "$1"
  fi
}

# se - "Screen execute"
# executes commands (separated by comma) in background screen
function se {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
      printf "${GREEN}se [cmd]${NC} ${GRAY}executes command in background screen which exits when command finishes${NC}\n"
      printf "${GREEN}se [cmd1], [cmd2], [cmd3]${NC} ${GRAY}executes multiple commands in background screen - must use comma and not semicolon!${NC}\n"
      printf "${GREEN}se -n [screen_name] [cmd]${NC} ${GRAY}executes command in a named screen which *doesn't* exit when command finishes${NC}\n"
      printf "${GREEN}se [cmd], p${NC} ${GRAY}sends push notification to mobile phone when command finishes${NC}\n"
      printf "${GREEN}se -n [screen_name] [cmd], p${NC} ${GRAY}same as above only in named screen which remains when command(s) finish${NC}\n"
  else
    if [ "$1" == '-n' ]; then
      local name="$2"
      local msg="$(hostname): <$name> finished."
      shift
      shift
    fi

    if [[ "$1" =~ ^[0-9]+ ]] ; then
      local delay="$1"
      shift
    fi

    local cmd=$(echo "$@" | sed 's/,/;/g')

    if [ -n "$delay" ]; then
      cmd="timer $delay; $cmd"
    fi

    cmd=$(echo "$cmd" | sed 's/; p$/;p/')

    if [[ "$cmd" =~ ";p"$ ]]; then
      cmd=$(echo "$cmd" | sed 's/;p$//')
      if [ -z "$msg" ]; then
        local msg="$(hostname): <${cmd}> finished."
      fi
      cmd="${cmd}; push_notify \"${msg}\""
    fi

    if [ -n "$name" ]; then
      cmd="${cmd}; exec bash"
    fi

    printf "${GREEN}Executing in background screen:\n${YELLOW}${cmd}${NC}\n"

    cmd="if [ -f ~/.bash_aliases ]; then . ~/.bash_aliases; fi; ${cmd}"

    if [ -z "$name" ]; then
      local name="dmt_task"
    fi

    screen -S "$name" -dm bash -c "$cmd"
  fi
}

function killport {
  port $1 | awk '{ print $2 }' | xargs kill -9
}


alias dup="docker-compose up -d"

function dc {
  docker container $@
}

#
#!/bin/bash

#######
# git #
#######
#alias gx="gitx"
alias _good="git bisect good"
alias _bad="git bisect bad"

function good {
  if [[ $@ == *--* ]]; then
    command good "$@";
  else
    echo "Last week stats:"
    echo
    command good --email=david.krmpotic@gmail.com --days=7;
  fi
}


alias gsu="git submodule update --init"
alias gst="git stash"
alias gsa="git stash apply"
alias gl='git pull'
#alias gp='git push'
#alias gpm='git push origin master'
#alias fpm='git push origin +master'
alias ga='git add'
alias gba='git branch -v -a'
alias glf="git fetch && git reset --hard origin/master"
alias glast="git show HEAD"

function latest_tag {
  local latest_tag=$(git describe --tags `git rev-list --tags --max-count=1`)
  git checkout $latest_tag
}

function gp {
  local branch=$(git rev-parse --abbrev-ref HEAD)
  git push origin $branch
}

function fp {
  local branch=$(git rev-parse --abbrev-ref HEAD)
  git push origin +$branch
  # if [ "$branch" == "master" ]; then
  # else
  #   printf "${RED}Not on master${NC}\n"
  # fi
}

function af {
  aa
  fp
  # local branch=$(git rev-parse --abbrev-ref HEAD)
  # if [ "$branch" == "master" ]; then
  #   aa
  #   git push origin +master
  # else
  #   printf "${RED}Not on master${NC}\n"
  # fi
}

alias afd="aa && fp && dep"

function gb {
  if [ -z "$1" ]; then
    git branch -v
  else
    git diff master "origin/${1}" --name-status
  fi
}

function gd {
  if [ -n "$1" ]; then
    run_on_file "$1" "git diff" '*'
  else
    git diff
  fi
}

alias clean='echo -n "Really clean this directory?";
  read yorn;
  if test "$yorn" = "y"; then
     rm -f \#* *~ .*~ *.bak .*.bak  *.tmp .*.tmp core a.out;
     echo "Cleaned.";
  else
     echo "Not cleaned.";
  fi'


alias clone="git clone"

function cclone {
  local tmp
  if macos; then
    tmp=$(mktemp -t git)
  else
    tmp=$(mktemp)
  fi

  local repo_name

  git clone "$@" --progress 2>&1 | tee $tmp
  repo_name=$(awk -F\' '/Cloning into/ {print $2}' $tmp)
  rm $tmp
  cd "$repo_name"
}

function amend {
  if [ -n "$1" ]; then
    git add "$1"
  fi
  git commit --amend --no-edit
}

alias am=amend

function depa {
  read -r -p "Amend all and deploy. Sure? [Y/n] " response
  if [[ ! $response =~ ^([nN])$ ]]
  then
    git add .
    git commit --amend --no-edit
    echo
    dep
  fi
}

alias share_git='git update-server-info & ruby -run -e httpd -- -p 5000 .git'

function pick {
  if [ -n "$1" ]; then
    git cherry-pick "$1"
  else
    git cherry-pick @{-1}
  fi
}

function changed {
  if ! $(git rev-parse --is-inside-work-tree > /dev/null 2>&1); then
    >&2 printf "${RED}Not a git repository${NC}\n"
    return 1
  fi

  local branch=$(git rev-parse --abbrev-ref HEAD)

  if [ "$1" == "help" ]; then
    echo "Usage:"
    printf "${YELLOW}changed${NC} - changes summary since the last pull\n"
    printf "${YELLOW}changed .${NC} - changes since the last pull\n"
    printf "${YELLOW}changed path/file${NC} - same as above, just for file\n"
    printf "${YELLOW}changed HEAD~10..HEAD${NC} - changes between two commits\n"
    printf "${YELLOW}changed [sha (previous!)]..HEAD${NC} - similar\n"
  elif [ -z "$1" ]; then
    git diff --stat $branch@{1} $branch
  elif [ "$1" == '.' ]; then
    git diff $branch@{1} $branch # all changes
  elif [ "$1" == 'local' ]; then
    git log @{push}.. # stuff that would get pushed with "git push"
  else
    grep -qv "\.\." <<< $1
    if [ ! $? -eq 0 ]; then
      git diff --pretty="format:" --name-only "$1" #| sort | uniq | awk "{print $url $0}"
    else
      local matching_file=''
      get_matching_file matching_file "$1"
      matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

      if [ ! -f "$matching_file" ]; then
        return
      fi

      printf "${YELLOW}git diff ${branch}@{1} ${branch} ${matching_file}${NC}\n"

      git diff $branch@{1} $branch "$matching_file"
    fi
  fi
}

# http://pastebin.com/k8WryYxM
# ----------------------------

function git_repo {
  local root=$(git rev-parse --show-toplevel || echo ".")
  local cwd="`pwd`"
  cd $root
  local origin=$(git remote -v | grep origin | grep push | sed 's/origin//g' | sed 's/git@github.com://g' | sed 's/https:\/\/github.com\///g' | sed 's/.git (push)//g' | sed 's/ (push)//g' | xargs)
  cd $cwd
  eval "$1=$origin"
}

# Opens Github project in browser from command line
# og - opens current branch
# og [branch] - opens selected branch
# og copy - copies to clipboard
# og commits - opens commits tab
# by davidhq
function og {
  if ! $(git rev-parse --is-inside-work-tree > /dev/null 2>&1); then
    >&2 printf "${RED}Not a git repository${NC}\n"
    return 1
  fi

  local repo=''
  git_repo repo

  local origin="https://github.com/${repo}"
  local branch=$(git rev-parse --abbrev-ref HEAD)

  if [ "$1" == 'copy' ]; then
    # copy to clipboard
    printf "${YELLOW}Copied: ${NC}${origin}\n"
    echo $origin | tr -d '\n' | pbcopy # chomp before copy
  elif [ "$1" == 'commits' ]; then
    # open commits tab
    open "${origin}/commits/${branch}"
  elif [ "$1" == 'npm' ]; then
    # open commits tab
    open "https://www.npmjs.com/package/$(name)"
  elif [ -n "$1" ]; then
    open "${origin}/tree/${1}"
  elif [ "$branch" != "master" ]; then
    open "${origin}/tree/${branch}"
  else
    open $origin
  fi
}

alias ogc="og copy"

# Usage inside a git repository:
# gc utils/file.js
# to get:
# https://github.com/[user]/[repo]/blob/[branch]/utils/file.js
# copied to clipboard and printed on the command line (you can use newest iTerm2 to being able to click on urls from terminal with CMD+click)
function gc {
  if ! $(git rev-parse --is-inside-work-tree > /dev/null 2>&1); then
    >&2 printf "${RED}Not a git repository${NC}\n"
    return 1
  fi

  local repo=''
  git_repo repo

  if [ -z "$1" ]; then
    echo "Usage: gc folder/file.txt"
    echo "copied github url to clipboard"
    local repo=''
    git_repo repo
    local origin="https://github.com/${repo}"
    echo $origin | tr -d '\n' | pbcopy # chomp before copy
  else
    local matching_file=''
    get_matching_file matching_file "$1"
    matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

    if [ ! -f "$matching_file" ]; then
      return
    fi

    local repo_root=$(git rev-parse --show-toplevel || echo ".")
    local file_path=$(readlink -f "$matching_file" | tr -d '\n')

    local branch=$(git rev-parse --abbrev-ref HEAD)
    local url_cluttered="https://github.com/${repo}/blob/${branch}/${file_path}"
    local url=$(echo $url_cluttered  | sed "s#${repo_root}/##")

    echo $url | tr -d '\n' | pbcopy
    printf "Clipboard: ${YELLOW}$url${NC}\n"
  fi
}

# ----------------------------

function log {
  if [ -n "$1" ]; then
    slog "$1"
    return
  fi

  if [ -d ".git" ]; then
    clear
    git log -5
    # if [ -z "$1" ]; then
    #   git log -3
    # else
    #   git log -"$1"
    # fi
  else
    printf "${RED}Not a git repository${NC}\n"
  fi
}

# open app log
function lg {
  if [ -f ".log" ]; then
    `cat .log`
  else
    if [ -z "$1" ]; then
      if macos; then
        if [ -f 'log/development.log' ]; then
          tail -n 20 -f log/development.log
        elif [ -f 'log/error.log' ]; then
          tail -n 20 -f log/error.log
        else
          puts "No log files"
        fi
      else
        if [ -f 'log/production.log' ]; then
          tail -n 20 -f log/production.log
        elif [ -f 'log/nginx.access.log' ]; then
          tail -n 20 -f log/nginx.access.log
        else
          puts "No log files"
        fi
      fi
    else
      if [ "$1" == "apache" ]; then
        tail -n 20 -f /var/log/apache2/error_log
      elif [ "$1" == "nginx" ]; then
        tail -n 20 -f /var/log/nginx/error.log
      # else # lg th mak
      #   local parserScript=~/Projects/scripts/ssh_parse_host
      #   if [ ! -f "$parserScript" ] && [ -f /var/projects/scripts/ssh_parse_host ]; then
      #     parserScript="/var/projects/scripts/ssh_parse_host"
      #   fi
      #   local server=$("$parserScript" "$1")
      #   ssh "$server" "if [ -d /var/www/${2}/current/log ]; then tail -n 20 -f /var/www/${2}/current/log/production.log; elif [ -f /var/www/${2}/log/nginx.access.log ]; then tail -n 20 -f /var/www/${2}/log/nginx.access.log; else tail -n 20 -f /var/www/${2}/log/production.log; fi"
      fi
    fi
  fi
}

function com {
  if [ "$1" == "-m" ]; then
    shift
  fi
  git commit -m "$@"
}

function coma {
  if [ "$1" == "-m" ]; then
    shift
  fi
  git add .
  git add . -u
  git commit -m "$@"
}

function comv {
  git add .
  git commit -v
}

function add {
  if [ -n "$1" ]; then
    run_on_file "$1" "git add" '*'
  else
    git add -p
  fi
}

function addp {
  if [ -n "$1" ]; then
    run_on_file "$1" "git add -p" '*'
  else
    git add -p
  fi
}

alias rh='git reset HEAD'
alias open_last_commit="git reset --soft HEAD^1"
alias last_commit=open_last_commit

#alias gp_amend="git add . && git commit --amend && fp"
alias cdr='cd $(git rev-parse --show-toplevel || echo ".")'

function gco {
  if [ -z "$1" ]; then
    git checkout master
  else
    git checkout $1
  fi
}

function st {
  if [ -d ".svn" ]; then
    svn status
  else
    git status
  fi
}

# function reb {
#    git rebase -i HEAD~"$1"
# }

alias i5='git commit -m "moo" && git stash && git rebase -i HEAD~5 && git stash apply'
alias i10='git commit -m "moo" && git stash && git rebase -i HEAD~10 && git stash apply'

# http://openmonkey.com/articles/2009/07/fast-github-clone-bash-function
function ghclone {
  gh_url=${1:-`pbpaste`}
  co_dir=${HOME}/Projects/source/$(echo $gh_url | sed -e 's/^git:\/\/github.com\///; s/\//-/; s/\.git$//')

  if [ -d $co_dir ]; then
    cd $co_dir && git pull origin master
  else
    git clone "${gh_url}" "${co_dir}" && cd "${co_dir}"
  fi
}

function aa {
  #read -r -p "Amend ALL to last commit? [Y/n] " response
  #if [[ ! $response =~ ^([nN])$ ]]
  #then
    git add .
    git commit --amend --no-edit
  #fi
}
