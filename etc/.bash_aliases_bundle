#!/bin/bash

#                 _
#             .__(.)< (💡DMT ALIASES v1.0.86 ■ 2019-08-24)
#              \___)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~ WARNING: CHANGES TO THIS FILE WILL BE LOST (FILE IS COMPILED) ~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#!/bin/bash

# DEFINE COLORS
YELLOW='\033[0;33m'
GREEN='\033[0;32m'
RED='\033[0;31m'
BLUE='\033[0;94m'
CYAN='\e[0;36m'
MAGENTA='\033[0;35m'
GRAY='\e[1;30m'
WHITE='\e[33;97m'
NC='\033[0m' # No Color

# http://stackoverflow.com/a/17805088/458177
# Ultimate bash debugging
# just "set -x" and you will get all this additional info printed:
export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'

function macos {
  if [[ $OSTYPE == darwin* ]]; then
    return 0 # true
  fi

  return 1 # false
}

function is_rpi {
  if [ -f /etc/issue ] && [[ $(cat /etc/issue) =~ Raspbian ]]; then
    return 0 # true
  fi

  return 1 # false
}

function dev_machine {
  if [ -f "$DMT_THIS_DEVICE/.dev-machine" ]; then
    return 0 # true
  fi

  return 1 # false
}

# info: https://mharrison.org/post/bashfunctionoverride/
save_function() {
  local ORIG_FUNC=$(declare -f $1)
  local NEWNAME_FUNC="$2${ORIG_FUNC#$1}"
  eval "$NEWNAME_FUNC"
}

function array_contains_element {
  local e match="$1"
  shift
  for e; do [[ "$e" == "$match" ]] && return 0; done
  return 1
}

function opts_matcher_helper {
  local pattern="$2"
  local ARGS=("$@")
  local opts=("${ARGS[@]:2}")

  local min_size=1000
  local match

  for entry in "${opts[@]}"
  do
    shopt -s nocasematch # case insensitive regex
    if [[ "$entry" == "$pattern"* ]] && [ -n "$pattern" ]; then
      local size=${#entry}
      if [[ $size -lt $min_size ]]; then
        match=$entry
        min_size=$size
      fi
    fi
    shopt -u nocasematch
  done

  if [ -n "$match" ]; then
    eval "$1='${match}'"
  else
    return 1
  fi
}

function opts_matcher {
  local __matching_opt=''

  local no_warning
  if [ "$2" == "no_warning" ]; then
    no_warning="true"

    local pattern="$3"
    local ARGS=("$@")
    local opts=("${ARGS[@]:3}")
  else
    local pattern="$2"
    local ARGS=("$@")
    local opts=("${ARGS[@]:2}")
  fi



  opts_matcher_helper __matching_opt "$pattern" "${opts[@]}"
  if [ $? -ne 0 ]; then # error
    if [ -n "$pattern" ] && [ -z "$no_warning" ]; then
      printf "${RED}Unknown option:${NC} ${pattern}\n\n"
    fi
    return 1
  elif [ "$pattern" != "$__matching_opt" ]; then
    printf "${MAGENTA}Matched: ${GREEN}${__matching_opt}${NC}\n\n"
  fi

  eval "$1='${__matching_opt}'"
}

# Priority for executable binary scripts:
#
# ~/.dmt/bin
# ~/.dmt/user/bin
# ~/.dmt/user/devices/this/bin
#
# TODO:
# DEV_BIN=true [command] [args]
# when true, it goes directly to core/rust/target/release example or bin... searches everything
function platform_bin_command {
  local __result=''

  shift

  local _device_script="${DMT_DEVICE_PLATFORM_BIN}/$@"
  local _user_script="${DMT_USER_PLATFORM_BIN}/$@"
  local _fw_script="${DMT_PLATFORM_BIN}/$@"

  if [ -f "$_fw_script" ]; then
    __result="$_fw_script"
  elif [ -f "$_user_script" ]; then
    __result="$_user_script"
  elif [ -f "$_device_script" ]; then
    __result="$_device_script"
  else
    printf "${GRAY}Script $@ not found among device, user or fw scripts.${NC}\n"
    return 1
  fi

  eval "$1='${__result}'"
}

# very simple parsing... scan all the lines until "parent_key" is found,
# then search for the first occurence of "key" and return its "value"
function def_reader {
  local file="$2"
  local parent_key="$3"
  local key="$4"

  local parent_key_matched=false

  IFS=$'\n' read -d '' -r -a lines < "$file"

  local _result=''

  IFS=$'\n'

  for line in ${lines[@]}; do
    unset IFS

    line=$(echo "${line}" | xargs) # trim whitespace

    # Handle comments

    if [[ $line =~ ^\s*"#" ]]; then # comment is a whole line, ignore
      continue
    fi

    # if not, ignore after # character

    local fillInToken="%@@%" # string that is unlikely to occur

    line=$(echo "$line" | sed "s/ /${fillInToken}/g")
    local arr=(${line/\#/ }) # split on \#
    line=$(echo ${arr[0]} | sed "s/${fillInToken}/ /g")

    # ---- end comment handing

    if [[ $line =~ ^${parent_key}\: ]]; then
      parent_key_matched=true

      if [ -z "$key" ]; then
        local arr=($(echo "$line" | tr ":" "\n"))
        _result=$(echo "${arr[@]:1}" | xargs) # trim whitespace
        break
      fi
    elif [[ $line =~ ^${key}\: ]] && $parent_key_matched; then
      local arr=($(echo "$line" | tr ":" "\n"))
      _result=$(echo "${arr[@]:1}" | xargs) # trim whitespace
      break
    fi
  done

  eval "$1='$_result'"
}

# calls nodejs parser and outputs nicely formatted json --
# good for testing the correctness .def files syntax
function parsedef {
  which node > /dev/null 2>&1

  if [ ! $? -eq 0 ]; then
    printf "${MAGENTA}nodejs not installed, please install it and try again${NC}\n"
    return
  fi

  local DEF_PARSER_PATH="$DMT_NODE_CORE/dmt-bridge/cli/parseDef.js"

  if [ ! -f "$DEF_PARSER_PATH" ]; then
    printf "${RED}Missing dmt-bridge nodejs package${NC}\n"
    return
  fi

  local pattern="$1"

  if [ -z "$pattern" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}parsedef [file.def]${NC} ${GRAY}converts .def file to json and shows the parsed results if successful${NC}\n"
    return
  fi

  local matching_file=''
  get_matching_file matching_file "$pattern" "*.def"
  matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

  if [ ! -f "$matching_file" ]; then
    printf "${RED}No matching file for pattern $1${NC}\n"
    return
  fi

  node "$DEF_PARSER_PATH" "$matching_file"
}

function def {
  parsedef "$@"
}
#!/bin/bash

LOGNAME_HOME="$HOME"

DMT_PATH="$LOGNAME_HOME/.dmt"

DMT_USER_PATH="$LOGNAME_HOME/.dmt/user"
DMT_THIS_DEVICE="$LOGNAME_HOME/.dmt/user/devices/this"

DMT_DEVICE_FILE="$DMT_THIS_DEVICE/def/device.def"

DMT_STATE="$DMT_PATH/state"

DMT_CORE="$LOGNAME_HOME/.dmt/core"
DMT_NODE_CORE="$DMT_CORE/node"
DMT_RUST_CORE="$DMT_CORE/rust"

LOCAL_DMT_SOURCE_MAC="62:38:e0:cc:f7:80"
LOCAL_DMT_SOURCE_ENDPOINT="192.168.0.10:1111"

DMT_RUNTIMES=(node rust)

# for runtime in "${DMT_RUNTIMES[@]}"
# do
#   if [ ! -f "$DMT_CORE/${runtime}" ]; then
#     mkdir -p "$DMT_CORE/${runtime}"
#   fi
# done

# if [ ! -f "$DMT_CORE/static" ]; then
#   mkdir -p "$DMT_CORE/static"
# fi

DMT_SCRIPTS="$DMT_PATH/etc/scripts"

DMT_PLATFORM=""
if macos; then
  DMT_PLATFORM="darwin"
elif [ "$OSTYPE" == "linux-gnu" ]; then
  DMT_PLATFORM="linux-x64"
elif [ "$OSTYPE" == "linux-gnueabihf" ]; then
  DMT_PLATFORM="linux-arm"
fi

DMT_PLATFORM_BIN="${DMT_PATH}/bin/${DMT_PLATFORM}"
DMT_USER_PLATFORM_BIN="${DMT_USER_PATH}/bin/${DMT_PLATFORM}"
DMT_DEVICE_PLATFORM_BIN="${DMT_THIS_DEVICE}/bin/${DMT_PLATFORM}"
DMT_AP_DEFAULT_HOST="root@192.168.1.1"
#!/bin/bash

function f {

  local walksearch=''
  platform_bin_command walksearch "walksearch"
  if [ -z "$walksearch" ]; then
    printf "${YELLOW}Using bash find instead ...${NC}\n"
    # not completelly sure why I used uniq filter here....
    local pattern=$(echo "$1" | sed 's/\[/\\[/g' | sed 's/\]/\\]/g') # grep really doesn't like unescaped [ or ]
    find . -name '.git' -prune -o -print -name 'node_modules' -prune -o -print -name 'Godeps' -prune -o -print -name 'elm-stuff' -prune -o -print -name 'bower_components' -prune -o -print | uniq | grep -i -- "$pattern"
    return
  fi

  "$walksearch" "$@" | grep -v ".git$" | grep -v ".git/" | grep -v ".node_modules$" | grep -v "node_modules/" | grep -v "Godeps$" | grep -v "Godeps/" | grep -v ".elm-stuff$" | grep -v ".elm-stuff/" | grep -v ".bower_components$" | grep -v ".bower_components/"

  # not completelly sure why I used uniq filter here....
  #local pattern=$(echo "$1" | sed 's/\[/\\[/g' | sed 's/\]/\\]/g') # grep really doesn't like unescaped [ or ]
  #find . -name '.git' -prune -o -print -name 'node_modules' -prune -o -print -name 'Godeps' -prune -o -print -name 'elm-stuff' -prune -o -print -name 'bower_components' -prune -o -print | uniq | grep -i -- "$pattern"
}

# finds just files in current directory
function ff {
  local pattern=$(echo "$1" | sed 's/\[/\\[/g' | sed 's/\]/\\]/g') # grep really doesn't like unescaped [ or ]
  find . -maxdepth 1 -type f | grep -i -- "$pattern"
  #find . -type f -maxdepth 1 | grep -i -- "$1"
}

# finds just directories in current directory
function ffd {
  local pattern=$(echo "$1" | sed 's/\[/\\[/g' | sed 's/\]/\\]/g') # grep really doesn't like unescaped [ or ]
  find . -maxdepth 1 -type d | grep -i -- "$pattern"
  #find . -type f -maxdepth 1 | grep -i -- "$1"
}

# deps: ggrep -> brew install grep (GNU grep, newer versions which support -z option, paring by null)
function ffm {
  if [ -z "$1" ]; then
    printf "${GREEN}Move files to destination directory${NC}\n"
    echo "Usage: ffm [filter] [dir]"
  else
    if [ -z "$2" ]; then
      printf "${MAGENTA}-- Dry run -- Files that would be moved:${NC}\n"
      ff "$1"
      printf "\n${YELLOW}Usage reminder: ffm [filter] [dir]${NC}\n"
    else
      if [ -d "$2" ]; then
        printf "${GREEN}Moved to${NC} ${YELLOW}$2${NC}:\n"
        ff "$1"
        local pattern=$(echo "$1" | sed 's/\[/\\[/g' | sed 's/\]/\\]/g') # grep really doesn't like unescaped [ or ]
        if macos; then
          find . -maxdepth 1 -type f -print0 | ggrep -z -i -- "$pattern" | xargs -0 -I{} mv '{}' "$2"
        else
          find . -maxdepth 1 -type f -print0 | grep -z -i -- "$pattern" | xargs -0 -I{} mv '{}' "$2"
        fi
      else
        printf "${RED}Target directory doesn't exist${NC}\n"
      fi
    fi
  fi
}

# deps: ggrep -> brew install grep (GNU grep, newer versions which support -z option, paring by null)
function ffc {
  if [ -z "$1" ]; then
    printf "${GREEN}Copy files to destination directory${NC}\n"
    echo "Usage: ffc [filter] [dir]"
  else
    if [ -z "$2" ]; then
      printf "${MAGENTA}-- Dry run -- Files that would be copied:${NC}\n"
      ff "$1"
      printf "\n${YELLOW}Usage reminder: ffc [filter] [dir]${NC}\n"
    else
      if [ -d "$2" ]; then
        printf "${GREEN}Copied to${NC} ${YELLOW}$2${NC}:\n"
        ff "$1"
        local pattern=$(echo "$1" | sed 's/\[/\\[/g' | sed 's/\]/\\]/g') # grep really doesn't like unescaped [ or ]

        if macos; then
          find . -maxdepth 1 -type f -print0 | ggrep -z -i -- "$pattern" | xargs -0 -I{} cp '{}' "$2"
        else
          find . -maxdepth 1 -type f -print0 | grep -z -i -- "$pattern" | xargs -0 -I{} cp '{}' "$2"
        fi
      else
        printf "${RED}Target directory doesn't exist${NC}\n"
      fi
    fi
  fi
}

function fa {
  find . -name '.git' -prune -o -print | uniq | grep -i -- "$1"
}

# ~~~~~~~~~~~~
# Jump around!
# p proj -> cd ~/Projects/project
# works best (fastest) if your projects are lower-case and you refer to them as such
# if not, then for best performance (no lag) you have to call "p Proj" (if ~/Projects/Project exists)
function awesome_cd {
  local base=$1
  local pattern=$2
  local arg=$3
  local origin
  if [ "$4" != 'subdir' ]; then
    local origin="`pwd`"
  fi

  if [ ! -d "$base" ]; then
    return 1
  fi

  cd "$base"

  if [ -z "$pattern" ]; then
    return
  fi

  # optimization, todo!
  # if [ -d "$pattern" ]; then
  #   cd "$pattern"
  #   return
  # fi
  # ==> above is not good enough because:
  # suppose there is a directory called AAA, you type "c aaa", then just "cd aaa" will cause command line to show $/aaa instead of real name- $/AAA
  #cd $(find . -maxdepth 1 -type d -iname "$1" | head -1) # this works correctly but has other problems -- find reports some unrelated error if for example some directory is not valied anymore (unmounted etc).. also "c dir/" (with slash) caused problems

  local subdir

  if [[ "$pattern" =~ \/ ]] ; then
    arr=(${pattern//\// })
    pattern=${arr[0]}
    subdir=${arr[1]}
  else
    unset subdir
  fi

  local IFS=$'\n' # default is " " and then array is not correctly constructed when there is spaces in filenames
  local dirlist=($(find . -maxdepth 1 -type d ! -path . -or -type l | sed "s/^\.\///" | grep -i ${pattern}))
  # will return symlinks that are files (not dirs) as well, that's why we have additional check [ -d "$d" ] below

  local match
  if [ -n "$pattern" ]; then
    local min_size=1000
    if [ "$arg" == "fuzzy" ]; then
      shopt -s nocasematch # case insensitive regex
      for d in ${dirlist[@]} ; do
        if [[ "$d" =~ $pattern ]] && [ -d "$d" ]; then
          local size=${#d}
          if [[ $size -lt $min_size ]]; then
            match="$d"
            min_size=$size
          fi
        fi
      done
      shopt -u nocasematch
    else
      # first try only directories that start exactly with our input
      for d in ${dirlist[@]} ; do
        if [[ "$d" == $pattern* ]] && [ -d "$d" ]; then
          local size=${#d}
          if [[ $size -lt $min_size ]]; then
            match="$d"
            min_size=$size
          fi
        fi
      done
    fi
    if [ -z "$match" ]; then
      #local proj=`echo $pattern | tr '[:upper:]' '[:lower:]'`
      local min_size=1000
      # search case-insensitive now
      shopt -s nocasematch # case insensitive regex
      for d in ${dirlist[@]} ; do
        if [[ "$d" == $pattern* ]] && [ -d "$d" ]; then
          local size=${#d}
          if [[ $size -lt $min_size ]]; then
            match="$d"
            min_size=$size
          fi
        fi
      done
      shopt -u nocasematch
    fi
  fi

  if [ -n "$match" ]; then
    cd "$match"
    if [ -n "$subdir" ]; then
      awesome_cd . "$subdir" "$arg" 'subdir'
      if [ $? -gt 0 ]; then
        cd "$origin"
        return 1
      fi
    fi
  elif [ "$arg" != "fuzzy" ]; then
    awesome_cd . "$pattern" 'fuzzy'
    if [ $? -gt 0 ]; then
      cd "$origin"
      return 1
    elif [ -n "$subdir" ]; then
      awesome_cd . "$subdir"
      if [ $? -gt 0 ]; then
        cd "$origin"
        return 1
      fi
    fi
  else
    if [ -z "$AWESOME_SILENCE" ]; then
      printf "${RED}Directory not found${NC}\n"
    fi
    cd "$origin"
    return 1
  fi
}

function p {
  if macos; then

    AWESOME_SILENCE=true awesome_cd ~/.dmt/core/node/dmt-controller "$1"

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/Projects/node "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/Projects/rust "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/Projects "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd /var/projects "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/Projects/node/dcrypt "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/.dmt/core/node "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/.dmt/core/rust "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/Projects/ethereum "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/Projects/music "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd $GOPATH/src "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/Documents/Arduino "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/Documents/Arduino/libraries "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/Install "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/Projects/playground "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/Projects/node/archive "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/Library/Application\ Support/Sublime\ Text\ 3/Packages "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/Projects/archive "$1"
    fi

    if [ $? -gt 0 ]; then
      awesome_cd ~/Misc "$1"
    fi

  else
    # nice side effect:
    # p -> /var/projects
    # p (second time) -> /var/www
    AWESOME_SILENCE=true awesome_cd ~/.dmt/core/node/dmt-controller "$1"

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd /var/projects "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/.dmt/core/node "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd ~/.dmt/core/rust "$1"
    fi

    if [ $? -gt 0 ]; then
      AWESOME_SILENCE=true awesome_cd /var/www "$1"

      if [ $? -gt 0 ]; then
        awesome_cd ~/Install "$1"
      elif [ -d "current" ]; then
        cd current
      fi
    fi
  fi
}

function app {
  awesome_cd /Applications "$1"
  if [ $? -eq 0 ] && [ -d "Contents" ]; then
    cd Contents
  fi
}

# TREE:
# red
#   blue
# green
#
# c r → cd red
# c re/bl → cd red/blue
# c → cd to first directory
function c {
  # c → cd to first directory
  if [ -z "$1" ]; then
    cd "`find . -maxdepth 1 -type d ! -path '*/\.*' ! -path . | sed "s/^\.\///" | sort | sed "1q;d"`"
  else
    # absolute paths
    if [[ "$1" =~ ^\/ ]]; then
      cd "$1"
      return
    fi
    awesome_cd . "$1"
  fi
}

function h {
  str="$1"
  str="$(tr '[:lower:]' '[:upper:]' <<< ${str:0:1})${str:1}" # upcase first letter for performance, most subdirs of interest here have first letter upcased and comparison will be faster

  local cwd=`pwd`

  AWESOME_SILENCE=true awesome_cd ~/ "$str"

  if [ $? -gt 0 ]; then
    if macos; then
      if [ -d ~/Misc ]; then
        AWESOME_SILENCE=true awesome_cd ~/Misc "$str"
        if [ $? -gt 0 ]; then
          if [ "$cwd" == "`pwd`" ]; then
            printf "${RED}Directory not found${NC}\n"
          fi
        fi
      fi
    else

      AWESOME_SILENCE=true awesome_cd ~/Storage "$1"

      if [ $? -gt 0 ]; then
        AWESOME_SILENCE=true awesome_cd ~/System "$1"
      fi

      if [ $? -gt 0 ]; then
        AWESOME_SILENCE=true awesome_cd ~/Media "$1"
      fi

      if [ $? -gt 0 ]; then
        AWESOME_SILENCE=true awesome_cd ~/Helper "$1"
      fi

      if [ $? -gt 0 ]; then
        printf "${RED}Directory not found${NC}\n"
      fi
    fi
  fi
}

function l {
  local pattern=$1

  if [ -f "$pattern" ]; then
    printf "File ${YELLOW}${pattern}:${NC}\n"
    ls -lah "$pattern"
    return
  fi

  # search for extensions
  # l .sol
  if [[ "$1" =~ ^\. ]]; then
    printf "Files with ${YELLOW}${pattern}${NC} extension:\n"
    echo
    ls -la *"$1"
    # ls -1
    return
  fi

  # absolute paths
  if [[ "$1" =~ ^\/ ]]; then
    ls -la "$1"
    return
  fi

  if [ -z "$pattern" ]; then
    ls -lah
    return
  fi

  # split on slash
  if [[ "$pattern" =~ \/ ]]; then
    arr=($(echo $pattern | tr "/" "\n"))
    pattern=${arr[0]}
    local subdir=${arr[1]}
  fi

  return_match=''
  dir_match return_match "$pattern"
  local match=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$return_match")

  if [ -n "$match" ] && [ -n "$subdir" ]; then
    local dir="`pwd`"
    cd "$match"
    local subdir
    return_match=''
    dir_match return_match "$subdir"
    subdir=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$return_match")

    cd "$dir"
    if [ -z "$subdir" ]; then
      printf "${RED}${match}${arr[1]} not found${NC}\n"
      return
    fi
  fi

  if [ -n "$match" ]; then
    if [ -z "$subdir" ]; then
      printf "Subdirectory ${YELLOW}${match}:${NC}\n"
      echo
      ls -lah "$match/" # end slash is for symlinks... without it, it doesn't show contents
    else
      printf "Subdirectory ${YELLOW}${match}/${subdir}:${NC}\n"
      echo
      ls -lah "$match/$subdir/"
    fi
  else
    printf "${YELLOW}No subdirectory matches the pattern and there is no file with that exact name${NC}\n"
  fi
}

# there is also simpler get_matching_folder

#WARNING: replace single quotes back after calling this function:
# return_match=''
# dir_match return_match "$pattern"
# THIS LINE IS IMPORTANT --->  local match=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$return_match")
function dir_match {
  local pattern=$2
  local match

  if [ -n "$pattern" ]; then
    local IFS=$'\n' # default is " " and then array is not correctly constructed when there is spaces in filenames
    local dirlist=($(find . -maxdepth 1 -type d ! -path . -or -type l | sed "s/^\.\///" | grep -i ${pattern}))
    # will return symlinks that are files (not dirs) as well, that's why we have additional check [ -d "$d" ] below
    local min_size=1000
    # first try only directories that start exactly with our input
    for d in ${dirlist[@]} ; do
      if [[ $d == $pattern* ]] && [ -d "$d" ]; then
        local size=${#d}
        if [[ $size -lt $min_size ]]; then
          match=$d
          min_size=$size
        fi
      fi
    done
    if [ -z "$match" ]; then
      local proj=`echo $pattern | tr '[:upper:]' '[:lower:]'`
      local min_size=1000
      # search all directories case-insensitive now
      for d in ${dirlist[@]} ; do
        local dir=`echo "$d" | tr '[:upper:]' '[:lower:]'`
        if [[ $dir == $proj* ]] && [ -d "$d" ]; then
          local size=${#d}
          if [[ $size -lt $min_size ]]; then
            match=$d
            min_size=$size
          fi
        fi
        # if exact match stop the loop to gain some performance
        if [[ $dir == $proj/ ]]; then
          match=$dir
          break
        fi
      done
    fi
    if [ -z "$match" ]; then
      for d in ${dirlist[@]} ; do
        shopt -s nocasematch # case insensitive
        if [[ $d =~ $pattern ]] && [ -d "$d" ]; then
          local size=${#d}
          if [[ $size -lt $min_size ]]; then
            match=$d
            min_size=$size
          fi
        fi
        shopt -u nocasematch # revert
      done
    fi
  fi

  match=$(sed "s/'/111SINGLE___QUOTE111/g" <<< "$match")
  eval "$1='$match'"
}

# expand hidden filenames for run_on_file (globally, actually)
shopt -s dotglob

# run_on_file prog elixir '*.ex' 'dummy' "$@"
# doesn't work with hidden files currently, they are not passed in bash
# TO TEST SEE ABOVE
function run_on_file {

  if [ -z "$1" ]; then # safety
    return
  fi

  local pattern="$1"
  shift
  local executable="$1"
  shift
  local files="$1"
  shift
  local flag="$1"
  shift
  local args="$@"

  local matching_file=''
  get_matching_file matching_file "$pattern" "$files"
  matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")
  if [ ! -f "$matching_file" ]; then
    return
  fi

  local match="$matching_file" # we were careful not to send $match to the function, because the same name is used locally there

  if [ -n "$match" ]; then

    if [ "$flag" == "local" ]; then

      if [ "$flag" != "silent" ] && [ "$matching_file" != "$pattern" ]; then
        printf "${YELLOW}$executable ./$match $args${NC}\n"
      fi

      if [ -z "$args" ]; then
        command $executable "./$match"
      else
        command $executable "./$match" "$args"
      fi

    else

      if [ "$flag" != "silent" ] && [ "$matching_file" != "$pattern" ]; then
        printf "${YELLOW}$executable $match $args${NC}\n"
      fi

      if [ -z "$args" ]; then
        command $executable "${match}"
      else
        command $executable "$match" "$args"
      fi
    fi

  else

    if [ "$flag" == "force" ]; then # run the executable on pattern even if actual file was not found by pattern
      if [ -z "$args" ]; then
        command $executable "$pattern"
      else
        command $executable "$pattern" "$args"
      fi
    else
      printf "${RED}File not recognized${NC}\n"
    fi

  fi
}

#WARNING: replace single quotes back after calling this function:
# local matching_folder=''
# get_matching_folder matching_folder ~/Install/npm "$1"
# THIS LINE IS IMPORTANT --->  matching_folder=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_folder")
function get_matching_folder() {
  local dir="$2"
  local pattern="$3"

  if [ ! -d "$dir" ]; then
    printf "${RED}$dir is not a directory${NC}\n"
    return
  fi

  # exact match
  for d in `ls -1 "$dir"` ; do
    if [[ $d == "$pattern" ]]; then
      d=$(sed "s/'/111SINGLE___QUOTE111/g" <<< "$d")
      eval "$1='${d}'"
      return
    fi
  done

  # begins with
  for d in `ls -1 "$dir"` ; do
    if [[ $d == "$pattern"* ]]; then
      d=$(sed "s/'/111SINGLE___QUOTE111/g" <<< "$d")
      eval "$1='${d}'"
      return
    fi
  done
}

#WARNING: replace single quotes back after calling this function:
# local matching_file=''
# get_matching_file matching_file "$pattern" "$files"
# THIS LINE IS IMPORTANT --->  matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")
function get_matching_file {

  local pattern="$2"
  local files="$3"

  if [ -z "$files" ]; then
    #command $executable
    files="*"
  fi

  # r compare.go
  # this called "get_matching_file matching_file "$pattern" "*.js"" (see function r)
  # and then it matched in following lines although it shoudln't because "*.js" was not taken into account
  #
  # OPTIONS:
  # - leave is at is (is it fast enough?)
  # - improve by checking if file with exact $pattern exists but also check for extenstion
  #
  if [ -f "$pattern" ] && [ "$files" == "*" ]; then
    pattern=$(sed "s/'/111SINGLE___QUOTE111/g" <<< "$pattern")
    eval "$1='${pattern}'"
    return
  fi

  local cwd="`pwd`"

  local subdir=''

  if [[ "$pattern" =~ \/ ]] ; then
    local arr=($(echo $pattern | tr "/" "\n"))
    subdir=${arr[0]}
    pattern=${arr[1]}
    AWESOME_SILENCE=true awesome_cd . "$subdir"
    if [ "$cwd" == "`pwd`" ]; then
      printf "${RED}There is no matches for ${subdir} folder pattern${NC}\n"
      return 1
    elif [ -z "$pattern" ]; then
      printf "${RED}You have to specify the file pattern${NC}\n"
      cd "$cwd"
      return 1
    fi
    subdir=${PWD##*/} # where we actually landed
  fi

  local min_size=1000
  local match
  local file
  # local extensions_arr=(${extensions/;/ })

  # local IFS=$'\n' # default is " " and then array is not correctly constructed when there is spaces in filenames

  # start with case sensitive
  #for extension in "${extensions_arr[@]}"
  for file in $files
  do
    #local files=($(find * -maxdepth 0 -type f))
    if [ -f "$file" ] && [[ $file == "$pattern"* ]]; then
      local size=${#file}
      if [[ $size -lt $min_size ]]; then
        match=$file
        min_size=$size
      fi
    fi
  done

  # case insensitive
  if [ -z "$match" ]; then
    shopt -s nocasematch # case insensitive regex

    for file in $files
    do
      if [ -f "$file" ] && [[ $file == "$pattern"* ]]; then
        local size=${#file}
        if [[ $size -lt $min_size ]]; then
          match=$file
          min_size=$size
        fi
      fi
    done

    shopt -u nocasematch
  fi

  # anywhere case sensitive
  if [ -z "$match" ]; then
    for file in $files
    do
      if [ -f "$file" ] && [[ $file == *"$pattern"* ]]; then
        local size=${#file}
        if [[ $size -lt $min_size ]]; then
          match=$file
          min_size=$size
        fi
      fi
    done
  fi

  # anywhere case insensitive
  if [ -z "$match" ]; then
    shopt -s nocasematch # case insensitive regex

    for file in $files
    do
      if [ -f "$file" ] && [[ $file == *"$pattern"* ]]; then
        local size=${#file}
        if [[ $size -lt $min_size ]]; then
          match=$file
          min_size=$size
        fi
      fi
    done

    shopt -u nocasematch
  fi

  if [ "$cwd" != "`pwd`" ]; then
    cd "$cwd"
  fi

  if [ -n "$match" ]; then
    if [ "$flag" == "mux" ]; then
      match=${match:2:${#match}-6}
    fi

    if [ -n "$subdir" ]; then
      match="$subdir/$match"
    fi

    if  [ "$match" == "$subdir/" ]; then
      printf "${RED}Folder $subdir has no matching file${NC}\n"
      return 1
    fi

    # single quotes don't make it through the return from the function
    match=$(sed "s/'/111SINGLE___QUOTE111/g" <<< "$match")
    eval "$1='${match}'"
  else
    return 1
  fi
}

function r {
  if [ -z "$1" ]; then
    if [ -f "index.js" ]; then
      r index.js
    elif [ -f "Cargo.toml" ]; then
      cargo run
    else
      printf "${RED}No index.js to run: need file pattern${NC}\n"
    fi
  else
    local executable=''

    local pattern=$1
    shift

    # javascript
    local matching_file=''
    get_matching_file matching_file "$pattern" "*.js"
    matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

    if [ -n "$matching_file" ]; then
      if [ -f "./truffle.js" ]; then
        executable="truffle exec"
      else
        executable=node
      fi
    fi

    # elixir
    if [ -z "$matching_file" ]; then
      matching_file=''
      get_matching_file matching_file "$pattern" "*.ex"
      matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

      if [ -n "$matching_file" ]; then
        executable=elixir
      fi
    fi

    # ruby
    if [ -z "$matching_file" ]; then
      matching_file=''
      get_matching_file matching_file "$pattern" "*.rb"
      matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

      if [ -n "$matching_file" ]; then
        executable=ruby
      fi
    fi

    # go
    if [ -z "$matching_file" ]; then
      matching_file=''
      get_matching_file matching_file "$pattern" "*.go"
      matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

      if [ -n "$matching_file" ]; then
        executable="go run"
      fi
    fi

    # python
    if [ -z "$matching_file" ]; then
      matching_file=''
      get_matching_file matching_file "$pattern" "*.py"
      matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

      if [ -n "$matching_file" ]; then
        executable=python3
      fi
    fi

    if [ -n "$executable" ]; then
      local args="$@"
      printf "${YELLOW}$executable $matching_file ${args}${NC}\n" # if using $@ directly here, only the first argument is printed :/
      command $executable "$matching_file" "$@"
    elif [ -d "cli" ]; then
      cli "$pattern" "$@"
    else
      printf "${RED}No match${NC}\n"
    fi
  fi
}

# runs scripts from util, utils or utilities
# u sc => node utils/scan.js
function ru {

  if [ -z "$1" ]; then
    return
  fi

  local pattern="$1"
  shift

  local matching_file=''
  get_matching_file matching_file "util/$pattern" "*.js"
  matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

  if [ ! -f "$matching_file" ]; then
    return
  fi

  printf "${YELLOW}node ${matching_file}${NC}\n"

  node "$matching_file" "$@"
}

function bn {
  run_on_file "$1" babel-node '*.js' force
}

function edit {
  # if [ -z "$1" ] && [ -f ".gitignore" ]; then
  #   nano .gitignore
  if [ -z "$1" ]; then
    exit
  elif [ -n "$1" ]; then
    run_on_file "$1" nano '*' force
  fi
}

function moc {
  run_on_file "tests/$1" mocha '*.js'
}

function ct {
  run_on_file "$1" cat '*'
}

function tt {
  tree -Ia 'test|node_modules|.git|Godeps|elm-stuff|deps|log|_build|vendor|bower_components|tmp|deploy|distroot|Deps'
}

# t -> tree
# t fil -> t file.txt
# t sc -> t script.js => with sytax highlighting
# t fil lala -> t file.txt | grep lala -i
function t {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}t [file] ${GRAY}shows file with syntax highlighting${NC}\n"
    printf "${GREEN}t [file] [term] ${GRAY}searches for lines with [term]${NC}\n"
  else

    local matching_file=''
    get_matching_file matching_file "$1"
    matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

    if [ ! -f "$matching_file" ]; then
      printf "${RED}File not found${NC}\n"
      return
    fi

    if [ "$matching_file" != "$1" ]; then
      printf "${YELLOW}${matching_file}${NC}\n"
    fi

    if [[ "$matching_file" == *".def" ]]; then
      parsedef "$matching_file"
    elif [[ "$matching_file" == *".json" ]]; then
      if [ "$2" == "hidden" ]; then
        cat "$matching_file"
      else
        if [ -n "$2" ]; then
          printf "${BLUE}${2}:${NC}\n"
        fi
        cat "$matching_file" | grep -v "^\s*//" | jq ".$2" # $2 can be empty.. if it's not, then it graps the specific key, more info: https://stedolan.github.io/jq/tutorial/
        # Python JSON validator
        # cat file.json | python -m json.tool
        if [ $? -ne 0 ]; then # parse error..
          cat "$matching_file"
          printf "${RED}"
          cat "$matching_file" | grep -v "^\s*//" | jq ".$2"
          printf "${NC}"
        fi
      fi
    elif [ -n "$2" ]; then
      run_on_file "$matching_file" cat '*' force | grep "$2" --color -in
    elif [[ "$(head -1 "$matching_file")" =~ \#\!\/bin\/(bash|sh) ]]; then
      run_on_file "$matching_file" "highlight -O xterm256 -s darkbone --syntax bash" '*' 'silent'
    else
      if [[ "$matching_file" == "Makefile" ]] || [[ "$matching_file" == *".js" ]] || [[ "$matching_file" == *".rb" ]] || [[ "$matching_file" == *".py" ]] ||
         [[ "$matching_file" == *".go" ]] || [[ "$matching_file" == *".html" ]] || [[ "$matching_file" == *".css" ]]; then  # this will not be true on incomplete file names
        run_on_file "$matching_file" "highlight -O xterm256 -s darkbone" '*' 'silent'
      else
        run_on_file "$matching_file" cat '*'
      fi
    fi
  fi
}

function uz {
  run_on_file "$1" unzip '*.zip'
}

function ir {
  if [ -z "$1" ]; then
    irb
  else
    #command irb -r "./$1"
    run_on_file "$1" "irb -r" '*.rb' 'local'
  fi
}

function oi {
  if [ -f "index.html" ]; then
    open "index.html"
  else
    printf "${RED}No index.html${NC}\n"
  fi
}

# open
function op {
  if [ -z "$1" ] || [ "$1" == "." ]; then
    open .
  elif [ "$1" == "xcode" ] && [ -d "ios" ]; then
    find ios -type d -depth 1 | grep xcodeproj | xargs open
  elif [[ "$1" =~ ^[0-9]+$ ]]; then
    open "http://localhost:${1}"
  else
    run_on_file "$1" "open" '*'
  fi
}

alias ox="o xcode"

function e {
  en "$@"
}

function es {
  local sublime_path="/usr/local/bin/subl" # warning: this symlink is not automatic after sublime install, user has to add it, pointing to: /Applications/Sublime Text.app/Contents/SharedSupport/bin/subl
  local sublime_path2="$HOME/bin/subl"

  if [ -f "${sublime_path}" ]; then
    local editor="${sublime_path}"
  elif [ -f "${sublime_path2}" ]; then
    local editor="${sublime_path2}"
  else
    printf "${RED}No SublimeText editor installed${NC}\n"
    return
  fi

  if [ -z "$1" ]; then
    command "${editor}" .
  else
    run_on_file "$1" "${editor}" '*' force
  fi
}

function ea {
  local atom_path="/Applications/Atom.app/Contents/Resources/app/atom.sh"
  if [ -f "${atom_path}" ]; then
    local editor="${atom_path}"

    if [ -z "$1" ]; then
      command "${editor}" .
    else
      run_on_file "$1" "${editor}" '*' force
    fi
  else
    printf "${RED}No atom editor installed${NC}\n"
    return
  fi
}

function en {
  if [ -z "$1" ]; then
    printf "${RED}Must specify file to edit with nano${NC}\n"
  else
    EDITOR=nano run_on_file "$1" "nano" '*' force
  fi
}

function ec {
  local cmd="/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code"
  local args="$@"
  if [ -z "$1" ]; then
    args="."
  fi
  command "$cmd" "$args"
}

function g {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    echo "z [file]"
  else
    run_on_file "$1" nano '*' force
  fi
}

function i {
  if [ "$1" == '-h' ] || [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}i [package] [package] ... ${GRAY}install packages${NC}\n"
    printf "${GREEN}i --check [package] ${GRAY}check if installed${NC}\n"
    printf "${GREEN}i --search [package] ${GRAY}check for available versions of similarly named packages${NC}\n"
    printf "${GREEN}i --info [package] ${GRAY}detailed info of exact match (faster)${NC}\n"
    printf "${GREEN}i --cmd [package] ${GRAY}which package does the command belong to${NC}\n"
  else
    if [[ "$1" == *--* ]]; then

      if [ -z "$2" ]; then
        printf "${RED}missing the rest of the command${NC}\n"
        return
      fi

      case "$1" in
        --check)
          shift
          ii "$@"
          ;;

        --search)
          shift

          printf "\n${YELLOW}Available packages:${NC}\n"
          aptitude search "$1" -F "%c %p %d %V"

          # apt-cache search *search term*
          ;;

        --info)
          shift

          printf "\n${YELLOW}Exact match info:${NC}\n"
          apt-cache show "$1"

          ;;

        --cmd)
          shift

          local cmd="$@"

          which "$cmd" > /dev/null 2>&1

          if [ $? -eq 0 ]; then
            dpkg -S `which ${cmd}`
          else
            printf "${RED}command${NC} ${YELLOW}${cmd}${NC} ${RED}not found${NC}\n"
          fi
          ;;

        *)
          printf "${RED}unknown flag ${1}${NC}\n"
          ;;

      esac

    else
      sudo apt-get install -y "$@"
    fi
  fi
}

function ii {
  printf "${MAGENTA}Installed versions:${NC}\n"
  #dpkg-query -s "$@" | grep "Version"
  dpkg-query -l "$@" | grep "ii"
}

alias ll='ls -l'
alias la='ls -A'
alias pu='pushd'
alias po='popd'

alias to='touch'
alias wg='wget'

#alias .='l' bad idea
alias ..='cd ..'
alias ...='cd ../..'
alias ..3="cd ../../.."
alias ..4="cd ../../../.."
alias ..5="cd ../../../../.."
alias cd..='cd ..'

function cop {
  if ! macos; then
    printf "${MAGENTA}Warning: not copied to clipboard because in remote shell${NC}\n"
  fi

  local path

  if [ -z "$1" ]; then
    path=$(pwd)
  else
    if [ -f "$1" ]; then
      if macos; then
        path=$(greadlink -f "$1")
      else
        path=$(readlink -f "$1")
      fi
    else
      local matching_file=''
      get_matching_file matching_file "$1"
      matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

      if [ ! -f "$matching_file" ]; then
        return
      fi

      if macos; then
        local path=$(greadlink -f "$matching_file")
      else
        path=$(readlink -f "$matching_file")
      fi
    fi
  fi

  if [ -e "${path}" ]; then
    path=$(sed "s/ /\\\ /g" <<< "$path")
    path=$(sed "s/\!/\\\\!/g" <<< "$path")
    path=$(sed "s/(/\\\(/g" <<< "$path")
    path=$(sed "s/)/\\\)/g" <<< "$path")
    path=$(sed "s/'/\\\'/g" <<< "$path")
    path=$(sed "s/\"/\\\\\"/g" <<< "$path")
    path=$(echo $path | tr -d '\n')

    if macos; then
      printf "Clipboard: ${YELLOW}${path}${NC}\n"
      echo "$path" | tr -d '\n' | pbcopy
    else
      echo "$path"
    fi
  else
    printf "${RED}No such file${NC}\n"
  fi
}

function cli_helper() {
  local MAGENTA='\033[0;35m'
  local NC='\033[0m' # No Color
  local text=$(echo "$1" | sed "s/cli\///g" | sed "s/.js//g")
  printf "${MAGENTA}${text}${NC} >>> "
  node "$1" -h
  echo
}

function cli {
  if [ -z "$1" ] || [ "$1" == "-h" ]; then
    if [ -d "cli" ]; then
      if [ -z "$1" ]; then
        find cli -type f | sort | sed "s/cli\///g" | sed 's/.js//g'
        echo
        printf "${YELLOW}Tip:${NC} use ${CYAN}cli -h${NC} for more info\n"
        return
      elif [ -d "cli" ] && [ -n "$1" ]; then
        #hardcore ;P --
        find cli/*.js -type f | sort | xargs -I@ bash -c "$(declare -f cli_helper) ; cli_helper @ "
        return
      fi
    elif [ -d "lib" ]; then
      printf "${YELLOW}lib:${NC}\n"
      find lib -type f | sort | sed "s/lib\///g" | sed 's/.js//g'
      return
    fi
  fi

  local dirname=$(pwd | xargs basename)

  # first option for "cli" to be active: existence of ./cli directory
  if [ -d "cli" ]; then
    local cmd="$1"
    cd cli
    local matching_file=''
    get_matching_file matching_file "$cmd" "*.js"
    matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")
    cd ..

    if [ -n "$matching_file" ]; then
      shift
      local fileName=$(echo $matching_file | sed 's/.js//g')
      >&2 printf "cli/${MAGENTA}${fileName}${NC} \n" # output to stderr so that piping the output to file doesn't contain this header
      node "cli/$matching_file" "$@"
      found=true
    else
      printf "${RED}Unknown cli command${NC}\n"
    fi
  elif [ -d "lib" ]; then # second option: existence of .lib directory (very similar to above)
    local cmd="$1"
    cd lib
    local matching_file=''
    get_matching_file matching_file "$cmd" "*.js"
    matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")
    cd ..

    if [ -n "$matching_file" ]; then
      shift
      >&2 node "lib/$matching_file" "$@"
      found=true
    else
      printf "${RED}Unknown cli command${NC}\n"
    fi
  elif [ "$dirname" == "packages" ]; then
    printf "${GREEN}We are inside packages.${MAGENTA} TODO - should report something about each package (subdirectory) ... at least report basic description of a package.. should probably not be in bash, but delegate this to superlib (which has to get extended functionality)${NC}\n"
  else
    printf "${RED}Not in the right kind of directory for ${MAGENTA}cli${RED} to work ${NC}\n"
  fi
}

function tape {
  declare -a opts=(
    "status"
    "rewind"
    "look"
    "eject"
    "eom"
    "goto"
    "fwd"
    "prev"
    "backup"
    "copy"
    "copy_rewind"
    "restore"
  )

  if [ -z "$1" ] || [ "$1" == "-h" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    echo "${opts[@]}"
    return
  fi

  local matching_opt=''
  opts_matcher matching_opt "$1" "${opts[@]}"
  if [ $? -ne 0 ]; then # error
    printf "${YELLOW}Use ${GREEN}-h ${YELLOW}to see valid options${NC}\n\n"
    return
  fi

  shift

  case "$matching_opt" in
    status)
      sudo mt -f /dev/nst0 status
      ;;

    rewind)
      time sudo mt -f /dev/st0 rewind
      ;;

    eject)
      time sudo mt -f /dev/st0 offline
      ;;

    look)
      sudo tar -b 2048 -tf /dev/nst0
      ;;

    eom)
      time sudo mt -f /dev/nst0 eom
      ;;

    goto)
      if [ -z "$1" ]; then
        printf "${RED}Must specify which archive number to seek to${NC}\n"
      else
        time sudo mt -f /dev/nst0 asf "$1"
        sudo mt -f /dev/nst0 status
      fi
      ;;

    fwd)
      local steps="1"
      if [ -n "$1" ]; then
        steps="$1"
      fi

      time sudo mt -f /dev/nst0 fsf "$steps"
      sudo mt -f /dev/nst0 status
      ;;

    prev)
      local steps="1"
      if [ -n "$1" ]; then
        steps="$1"
      fi

      time sudo mt -f /dev/nst0 bsfm "$steps"
      sudo mt -f /dev/nst0 status
      ;;

    backup)
      local script="$DMT_SCRIPTS/tape_backup"
      if [ -f "$script" ]; then
        sudo "$script" "$@"
      else
        printf "${RED}missing ${script}${NC}\n"
      fi
      ;;

    copy)
      local dir="$1"
      time sudo tar -b 2048 -cf /dev/nst0 "$dir" --verbose --verbose
      ;;

    copy_rewind)
      local dir="$1"
      time sudo tar -b 2048 -cf /dev/st0 "$dir" --verbose --verbose
      ;;

    restore)
      local dir="$1" # optional! if we call tar -xf without the directory which we want to extract, we will extract the entire archive
      time sudo tar -b 2048 -xf /dev/nst0 "$dir" #--verbose --verbose
      #tar -b 2048 -xf /dev/nst0 "$dir"
      ;;
  esac
}
#!/bin/bash

# -- DMT ALIASES --
# SAVES YOU TIME AND MONEY. FREE SOFTWARE.

# INSTALL INSTRUCTIONS FOR Linux / macOS
# (Windows not supported, it has different philosophy)

# TODO: UPDATE!!!!!!!!

# 1.
# put this file into ~/.bash_aliases
# curl -o ~/.bash_aliases https://elm-research.com/projects/bash_aliases.txt
#
# Make the shell load it:
# type:
# sudo nano /etc/profile
#
# add this to the end:
#
# # Alias definitions.
# if [ -f /Users/[your name]/.bash_aliases ]; then
#   . /Users/[your name]/.bash_aliases
# fi
#
# You could also add this to ~/.bash_profile but it's better in /etc/profile because then you will have access to things defined here even when you are root
#
# To update in the future:
# update
#
# You can also check the changelog before each update:
# update_diff

# 2.
# place to put non-shareable stuff: /etc/.bash_aliases_custom

# YOU CAN add your custom aliases or changes here please...
# don't add them in this file for now, rather ask me (the author - davidhq) to update it, this is the only way to keep this file in sync for easy updates

# 3.
# ------------ TEST YOUR SETUP: ---------------
# Open a new terminal tab and type:
# l [enter]
# or
# count [enter]

# You can always terminate commands that are running too long (shouldn't happen often and almost always by your own fault - for example running count on a big folder!)
# with: CTRL+C

# If you make some changes to ~/.bash_aliases_custom, you can type: rel [enter] to reload the environment without closing the tab and opening a new one

# Learn about two useful metacommands for start: "rel" and "al"

# -------------------------------------------------------

# OPTIONAL:
#
# 4. DEPENDENCIES

# Install some other dependencies that some functions use:
# - Install "homebrew" awesome package manager for macOS based on the archaic Ruby language
#
# --- SSHRC
# brew install sshrc
#
# This turbocharges this file even more because now you'll take it with you to whatever linux server you ssh into!
# This file speeds up your command line in both, MacOS and Linux in the same exact way: it smoothes out the differences, vas majority of commands work the same on both
# types of systems.
#
# Step 2 - create symlink to this file:
# cd [this moves to home directory]
# ln -s

# -- coreutils (macOS)
# brew install coreutils
# provides gsort (used in "usage" for example) and other commands
# also provides "gshuf"
#
# --- GNU GREP
# brew install grep (gnu grep: install the command "ggrep")
#
# --- CLOC
# npm install -g cloc (code analysis in addition to "loc" which .dmt provides)
#
# --- ACK
# brew install ack
#
# Create ~/.ackrc with this contents:
#
# --type-add
# ruby=.builder,.feature
# --type-set
# rackup=.ru
# --type-set
# elm=.elm
# --type-set
# livescript=.ls
# --type-set
# haml=.haml
# --type-add
# php=.phtml
# --type-set
# jsx=.jsx
# --type-set
# vue=.vue
# --type-set
# markdown=.markdown,.md,.mdown
# --type-set=cache=.cache
# --ignore-dir=.idea
# --ignore-dir=tmp
# --ignore-dir=photos
# --ignore-dir=node_modules
# --ignore-dir=bower_components
# --ignore-dir=dist
# --ignore-dir=.git
# --ignore-dir=log
# --ignore-dir=Godeps
# --ignore-dir=elm-stuff
# --ignore-dir=deps
# --ignore-dir=build
# --ignore-dir=_build
# --ignore-dir=dist
# --ignore-dir=Deps
# --ignore-dir=vendor
# --nocache
#
# --- HIGHLIGHT: highlight code in terminal (when using "t" command instead of "cat")
# brew install highlight
#
# --- jq: parse .json in terminal
# brew install jq
#
# --- latest version of RSYNC (only needed for macOS Sierra+, linux already has the latest version)
# brew install rsync
# needed because of --protect-args (https://unix.stackexchange.com/a/137285/135062) - used in dirsync function
# if you want to rsync *to* macOS (rsync server is used), make sure to add /usr/local/bin to $PATH in ~/.bashrc so that it's loaded on ssh / rsync
#
# --- TREE: show directory and file structure
# brew install tree
#
# --- COLORDIFF: colors in diffs (example: update_diff command that shows what would be updated with "update")
# brew install colordiff
#
# --- GITSTATS
# Todo: automatic install - detect os, ask for confirmation and install!!!
# command: stats

# 5. SYNCBOX
#
# mkdir ~/Syncbox
# echo "pi@lab.local" > ~/.syncbox
#
# Commands:
# push
# pull

# ----------------======---------------

# + LOAD DMT DEPS

# LOGNAME=$(logname 2>/dev/null)

# # Returns error in two known occasions:
# # 1) after "dmt update [device]" which calls "./install" *via ssh -e*
# # 2) on linux machines when executing "se" (command in background screen)
# if [ $? -ne 0 ]; then # error
#   LOGNAME_HOME="$HOME"
# else
#   if macos; then
#     #LOGNAME_HOME="/Users/$(whoami)"
#     LOGNAME_HOME="$HOME"
#   else
#     LOGNAME_HOME="/home/$(logname)" # MAYBE IMPROVE??
#   fi
# fi

# LOGNAME_HOME="$HOME"
# DMT_PATH="$LOGNAME_HOME/.dmt"

# syncbox="pi@dmt.local"

# if [ -f ~/.syncbox ]; then
#   syncbox=`cat ~/.syncbox`
# fi

# cp with progress and speed of the transfer
alias cpp="rsync -ah --progress"

function compile {
  local cwd="`pwd`"
  cd "$DMT_PATH/shell"
  ./compile
  cd "$cwd"
}

# copies custom user javascript files which are loaded inside dmt-proc !
# each gets an instance of a "program"
## UPDATE: this (along with .scripts/copy_user_bootscripts was moved into node.js code -- inside dmt-user)
# function copy_core_bootscripts {
#   local script="$DMT_NODE_CORE/.scripts/copy_user_bootscripts"

#   if [ -f "$script" ]; then
#     local cwd="`pwd`"
#     cd "$DMT_NODE_CORE/.scripts"
#     ./copy_user_bootscripts
#     cd "$cwd"
#   fi
# }

function symlink_if_unlinked {
  local script="$DMT_NODE_CORE/.scripts/symlink_dmt_deps"

  if [ -f "$script" ]; then

    if [ ! -L "$DMT_NODE_CORE/dmt-bridge/node_modules" ]; then
      local cwd="`pwd`"
      cd "$DMT_NODE_CORE/.scripts"
      ./symlink_dmt_deps
      cd "$cwd"
    fi
  fi
}

function compile_gui_if_missing {
  if [ ! -f "$DMT_NODE_CORE/dmt-gui/gui-frontend-core/app/public/bundle.js" ]; then
    gui build
  fi
}

# Reload the environment
function rel {

  if [ -f "$DMT_PATH/shell/compile" ]; then
    compile
  fi

  if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
  fi
  if [ -f ~/.bashrc ]; then
    . ~/.bashrc
  fi
  if [ -f ~/.bash_profile ]; then
    . ~/.bash_profile
  fi
}

# Usage:
# "al [enter]" - opens Sublime editor on the ~/.dmt
# or "al [any function name]" to see the source for the function directly in terminal without having to open source files
function al {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}al [function]${NC} ${GRAY}show bash function source${NC}\n"
    return
  fi

  which highlight > /dev/null 2>&1

  if [ $? -eq 0 ]; then
    type "$1" | highlight -O xterm256 -s darkbone --syntax bash
  else
    type "$1"
  fi
}

function loop {
  while true; do "$@"; sleep 2; done
}

function latest {
  local num=5
  if [ -n "$1" ]; then
    num="$1"
  fi

  ls -tp | grep -v /$ | head -"$num"
}

function newscript {
  if [ -n "$1" ]; then
    if [ -f "$1" ]; then
      printf "${RED}File already exists${NC}\n"
    else
      echo "#!/usr/bin/env node" > "$1"
      echo '"use strict"' >> "$1"
      ux "$1"
    fi
  else
    echo "Usage: newscript [file]"
  fi
}

function os {
  cat /etc/os-release
}

# ---------------------------

# function gr {
#   if [ -z "$1" ]; then
#     printf "${YELLOW}Usage:${NC}\n"
#     echo "gr search_term [where]"
#     return
#   fi

#   local pattern="$1"
#   local where="."

#   if [ -n "$2" ]; then
#     where="$2"
#   fi
#   # http://www.computerhope.com/unix/ugrep.htm

#   grep -rI --exclude-dir="\.svn" --exclude-dir="\.git" "$pattern" "$where" --color -n
# }

function mac {
  system_profiler SPNetworkDataType | grep Wi-Fi -A10
  ifconfig en0
}

# dep for reload:
# sudo apt-get install -y xdotool
function kiosk {
  if macos; then
    printf "${RED}Cannot run on macOS${NC}\n"
    return
  fi

  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    echo

    printf "${GREEN}edit: ${GRAY}edit kiosk configuration file${NC}\n"
    printf "${GREEN}reload: ${GRAY}reload currently set url in kiosk browser${NC}\n"
    printf "${GREEN}restart: ${GRAY}restart kiosk browser (for example on configuration change)${NC}\n"

    if [ -f ~/.config/lxsession/LXDE-pi/autostart ]; then
      printf "\n${MAGENTA}Current kiosk setup:${NC}\n"
      cat ~/.config/lxsession/LXDE-pi/autostart | grep ^@/usr/bin/chromium-browser
    fi

    return
  fi

  case "$1" in

    edit)

      local loc1="/var/lib/dietpi/dietpi-software/installed/chromium-autostart.sh"
      local loc2=~/.config/lxsession/LXDE-pi/autostart
      local loc3=/home/pi/.config/lxsession/LXDE-pi/autostart

      if [ -f "$loc1" ]; then
        sudo nano "$loc1"
      elif [ -f "$loc2" ]; then
        nano "$loc2"
      elif [ -f "$loc3" ]; then
        nano "$loc3"
      fi

      ;;

    reload)

      # if [ ! -f ~/.config/lxsession/LXDE-pi/autostart ]; then
      #   printf "${YELLOW}Kiosk configuration missing...${NC}\n"
      #   return
      # fi

      #printf "${MAGENTA}Note: this only reloads the currently open url, if you changed it, you have to call [kiosk restart]${NC}\n"

      which xdotool > /dev/null 2>&1

      if [ $? -eq 0 ]; then
        export DISPLAY=":0"
        WID=$(xdotool search --onlyvisible --class chromium|head -1)
        xdotool windowactivate ${WID}
        xdotool key ctrl+F5
      else
        printf "${RED}xdotool missing, please install with: ${GRAY}sudo apt-get -y install xdotool${NC}\n"
      fi

      printf "${GREEN}Reloaded...${NC}\n"

      ;;

    restart)

      if [ ! -f ~/.config/lxsession/LXDE-pi/autostart ]; then
        printf "${YELLOW}Kiosk configuration missing...${NC}\n"
        return
      fi

      sudo killall chromium-browser
      printf "${MAGENTA}Please copy and execute this command:${NC}\n"
      echo "export DISPLAY=\":0\"; $(cat ~/.config/lxsession/LXDE-pi/autostart | grep ^@/usr/bin/chromium-browser | sed 's/^@//') &"

      ;;

    *)
      printf "${RED}Unknown request${NC}\n"
      ;;

  esac
}


#### systemd

function shut {

  if ! macos && [ -f "/etc/fstab" ] ; then
    which lsblk > /dev/null 2>&1

    # lsblk exists
    if [ $? -eq 0 ]; then
      local labels=()

      # read all present labels via lsblk
      while read label do
      do
        if [ -n "$label" ] && [ "$label" != "LABEL" ]; then
          labels+=("$label")
        fi
      done < <(lsblk -o LABEL)

      # read /etc/fstab
      while read line
      do
        local label=$(echo "$line" | awk '{print $1}' | sed 's/LABEL=//')
        local path=$(echo "$line" | awk '{print $2}')

        array_contains_element "$label" "${labels[@]}"

        if [ $? -eq 0 ]; then
          if [ ! -d "$path" ]; then
            printf "${YELLOW}/etc/fstab:${NC} ${CYAN}Directory ${path} ${RED}not found, system wouldn't boot, aborting ...${NC}\n"
            return
          fi
        else
          printf "${YELLOW}/etc/fstab:${NC} ${CYAN}Label ${label} ${RED}not found on the system with lsblk, system wouldn't boot, aborting ...${NC}\n"
          return
        fi
      done < <(cat /etc/fstab | grep '^LABEL')
    else
      printf "${YELLOW}lsblk missing${NC}, no additional safety checks performed on /etc/fstab ...\n"
      printf "${MAGENTA}Install lsblk${NC}\n"
    fi
  fi

  if [ "$1" == 'reboot' ] || [ "$1" == 'r' ]; then
    if is_rpi; then
      # fix: "This profile appears to be in use by another Chromium process (543)...""
      if [ -d /home/pi/.config/chromium ]; then
        rm /home/pi/.config/chromium/Singleton*
      fi
    fi

    save_dmt_state

    printf "${MAGENTA}Rebooting...${NC}\n"
    sudo reboot
  elif [ "$1" == 'rr' ]; then
    # https://unix.stackexchange.com/questions/183095/last-resort-linux-terminal-command-to-reboot-over-ssh-in-case-of-a-kernel-bu
    echo s > /proc/sysrq-trigger
    echo u > /proc/sysrq-trigger
    echo s > /proc/sysrq-trigger
    echo b > /proc/sysrq-trigger
  else
    if [ -n "$1" ]; then
      local seconds=0
      local val=0
      local desc=""
      local denom=""

      convert_to_seconds seconds val desc denom "$1"

      if [ "$denom" == "s" ]; then
        printf "${RED}Please specify shutdown delay in minutes or hours${NC}\n"
        return
      else
        echo
        printf "${CYAN}Shutting down in ${MAGENTA}${desc}${NC} ${CYAN}...${NC}\n"
        echo
        # sleep $seconds

        se -n shutdown_task "$1" execute_shutdown
      fi
    else
      read -r -p "Are you sure you want to shut the device down (instead of rebooting)? [Y/n] " response
      if [[ ! $response =~ ^([nN])$ ]]
      then
        execute_shutdown
      fi
    fi
  fi
}

function execute_shutdown {
  printf "${RED}Shutting down...${NC}\n"
  if macos; then
    off
  else
    save_dmt_state

    sudo shutdown -h now
  fi
}

function res {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}res [service] ${GRAY}= sudo systemctl restart [service]${NC}\n"
  else
    sudo systemctl restart "$@"
    printf "${GREEN}Done.${NC}\n"
  fi
}

function reb {
  printf "${MAGENTA}Rebooting...${NC}\n"
  shut reboot
}

function srv {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"

    printf "${GREEN}srv [service]${NC} ${GRAY}show status${NC}\n"
    printf "${GREEN}srv [service] [command]${NC} ${GRAY}run command, ex.: start|stop|reload|restart|enable|disable${NC}\n"
    printf "${GREEN}srv [service] cat${NC} ${GRAY}show service specification${NC}\n"
    printf "${GREEN}srv [service] edit${NC} ${GRAY}edit service specification${NC}\n"
    printf "${GREEN}srv [service] log${NC} ${GRAY}see service log${NC}\n"
    echo
    printf "${GREEN}srv ls${NC} ${GRAY}show services in /etc/systemd/system${NC}\n"
    printf "${GREEN}srv cd${NC} ${GRAY}move to /etc/systemd/system${NC}\n"
    printf "${GREEN}srv cd2${NC} ${GRAY}move to /lib/systemd/system${NC}\n"

    #printf "${GREEN}${NC} ${GRAY}${NC}\n"

    echo

    printf "Dir: ${MAGENTA}/etc/systemd/system${NC}\n"
    printf "Dir (system): ${MAGENTA}/lib/systemd/system${NC}\n"

    return
  fi

  if [ -z "$2" ]; then
    if [ "$1" == "ls" ]; then
      ls -la /etc/systemd/system/*.service
    elif [ "$1" == "cd" ]; then
      cd /etc/systemd/system
    elif [ "$1" == "cd2" ]; then
      cd /lib/systemd/system
    else
      sudo systemctl status "$1"
    fi
  elif [ "$2" == "cat" ]; then
    local loc1="/etc/systemd/system/${1}.service"
    local loc2="/lib/systemd/system/${1}.service"

    if [ -f "$loc1" ]; then
      printf "${YELLOW}Found${NC} ${GREEN}$loc1${NC}\n\n"
      cat "$loc1"
    elif [ -f "$loc2" ]; then
      printf "${YELLOW}Found${NC} ${GREEN}$loc2${NC}\n\n"
      cat "$loc2"
    else
      printf "${RED}unknown service $1${NC}\n"
    fi
  elif [ "$2" == "edit" ]; then
    local loc1="/etc/systemd/system/${1}.service"
    local loc2="/lib/systemd/system/${1}.service"

    if [ -f "$loc1" ]; then
      printf "${YELLOW}Found${NC} ${GREEN}$loc1${NC}\n\n"
      sudo nano "$loc1"
      sudo systemctl daemon-reload
    elif [ -f "$loc2" ]; then
      printf "${YELLOW}Found${NC} ${GREEN}$loc2${NC}\n\n"
      sudo nano "$loc2"
      sudo systemctl daemon-reload
    else
      printf "${RED}unknown service $1${NC}\n"
    fi
  elif [ "$2" == "log" ]; then
    journalctl -u "${1}.service"
  else
    sudo systemctl "$2" "$1"
  fi
}

function d {
  dmt "$@"
}

function de {
  local desk="$HOME/Desktop"
  # if [ ! -d $desk ]; then
  #   #printf "~/Desktop not found, using ${YELLOW}/tmp${NC}\n"
  #   #desk="/tmp"
  #   docker_cmd "$@"
  #   return
  # fi
  # if [ -z "$1" ]; then
  if [ -d "$desk" ]; then
    cd "$desk"
    local dir="`pwd`"
    AWESOME_SILENCE=true awesome_cd . "$1"
    if [ "`pwd`" == "$dir" ] && [ -n "$1" ]; then
      printf "Created ${YELLOW}~/Desktop/$1${NC}\n"
      mkdir "$1"
      cd "$1"
    fi
  else
    printf "${RED}${desk} not found${NC}\n"
  fi

  # "$1" is not present at this point, but we keep this code for possible change in the future
  # else
  #   dmt "$@"
  # fi
}

# moves file to desktop
function dm {
  local desk="$HOME/Desktop"

  local matching_file=''
  get_matching_file matching_file "$1"
  matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

  if [ ! -f "$matching_file" ]; then
    printf "${RED}No file matches the pattern ${YELLOW}$1${NC}\n"
  else # found file
    local target="$desk/$matching_file"
    if [ -f "$target" ]; then
      printf "Trying to move ${YELLOW}$matching_file${NC} to ${CYAN}~/Desktop${NC} ...\n"
      printf "${RED}Problem: ${YELLOW}~/Desktop/$matching_file ${NC}already exists - not overwriting${NC}\n"
      return
    else
      mv "$matching_file" "$target"
      printf "${GREEN}Moved ${YELLOW}$matching_file ${GREEN}to ${CYAN}~/Desktop${NC}\n"
    fi
  fi
}

###### Arduino

alias esp8266="cd ~/Library/Arduino15/packages/esp8266/hardware/esp8266"

function arduino {
  awesome_cd ~/Documents/Arduino/libraries "$1"
}

###### Deps management

function query {
  if [ -z "$1" ]; then
    for d in `ls -1 ~/Install/npm/` ; do
      do_query "$d"
    done
    # this is faster (done in parallel), but:
    # - we would need to move query out to ~/bin/query because xargs cannot work with functions
    # - results would be in random order
    #ls -1 ~/Install/npm | xargs -n 1 -P 10 query
  else
    local matching_folder=''
    get_matching_folder matching_folder ~/Install/npm "$1"
    matching_folder=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_folder")

    if [ -n "$matching_folder" ]; then
      do_query "$matching_folder"
    else
      printf "${RED}$1 doesn't match any package in ~/Install/npm${NC}\n"
    fi
  fi
}

function do_query {
  local matches=$(ls -l /usr/local/lib/node_modules | grep "$1" | wc -l)
  if [ ! $matches -eq 0 ]; then
    version=$(version "/usr/local/lib/node_modules/${1}")
    matches=$(ls -l /usr/local/lib/node_modules | grep "Install/npm" | grep "$1" | wc -l)

    if [ $matches == 0 ]; then
      printf "${YELLOW}${1} ${version} (unstable)${NC}\n"
    else
      printf "${GREEN}${1} ${version} (stable)${NC}\n"
    fi
  else
    printf "${RED}${1} (not linked)${NC}\n"
  fi
}



######

function message {
  if [ -z "$1" ]; then
    echo "Usage: message msg [title]"
  else
    local title=""
    if [ -n "$2" ]; then
      title="$2"
    fi
    osascript -e "display notification \"$1\" with title \"$title\""
  fi
}

function ctrl_c_trap() {
  CTRL_C=true # crap, still doesn't get called in time!!!
  echo "** Trapped CTRL-C in ~/.bash_aliases"
}

# warning: STAYS FOREVER INSIDE TERMINAL CONSOLE after first set
function set_ctrl_c_trap {
  CTRL_C=false
  trap ctrl_c_trap INT
}

function convert_to_seconds {
  local time_input="$5"
  local _seconds=0
  local _val=0
  local _desc=""
  local _denom=""

  # default is minutes!
  if [[ "$time_input" =~ [0-9]+$ ]] ; then
    #_seconds=$time_input
    _seconds=$time_input
    _val=$time_input
    _desc="${_seconds}s"
    _denom="s"
  else
    local number=${time_input:0:${#time_input}-1}
    if [[ "$time_input" =~ s$ ]] ; then
      _seconds=$number
      _val=$number
      _desc="${_seconds}s"
      _denom="s"
    elif [[ "$time_input" =~ m$ ]] ; then
      _seconds=$(( $number*60 ))
      _val=$number
      _desc="${number}m"
      _denom="m"
    elif [[ "$time_input" =~ h$ ]] ; then
      _seconds=$(( $number*3600 ))
      _val=$number
      _desc="${number}h"
      _denom="h"
    elif [[ "$time_input" =~ d$ ]] ; then
      _seconds=$(( $number*3600*24 ))
      _val=$number
      _desc="${number}d"
      _denom="d"
    fi
  fi

  eval "$1='$_seconds'"
  eval "$2='$_val'"
  eval "$3='$_desc'"
  eval "$4='$_denom'"
}

function timer {
  if [ -z "$1" ]; then
    echo "Usage: timer [1|1s|5min|2h|3d] [message]"
  else

    local seconds=0
    local val=0
    local desc=""
    local denom=""

    convert_to_seconds seconds val desc denom "$1"

    if [ -n "$desc" ]; then
      printf "${YELLOW}Waiting for ${desc} ...${NC}\n"

      case $denom in
        "s" )
          sleep $seconds
          # for (( i=$val; i>0; i-- ))
          # do
          #   printf "${GRAY}$(date +"%H:%M") ${MAGENTA}$i ${denom} to go ...${NC}\n"
          #   sleep 1
          # done
          printf "${GREEN}Time's up!${NC}\n"
          ;;
        "m" )
          for (( i=$val; i>0; i-- ))
          do
            printf "${GRAY}$(date +"%H:%M") ${MAGENTA}$i ${denom} to go ...${NC}\n"
            sleep 60
          done
          printf "${GREEN}Time's up!${NC}\n"
          ;;
        "h" )
          for (( i=$val; i>0; i-- ))
          do
            printf "${GRAY}$(date +"%H:%M") ${MAGENTA}$i ${denom} to go ...${NC}\n"
            sleep 3600
          done
          printf "${GREEN}Time's up!${NC}\n"
          ;;
        "d" )
          for (( i=$val; i>0; i-- ))
          do
            printf "${GRAY}$(date +"%H:%M") ${MAGENTA}$i ${denom} to go ...${NC}\n"
            sleep 86400
          done
          printf "${GREEN}Time's up!${NC}\n"
          ;;
      esac

      # following check won't matter because CTRL_C is not actually set to TRUE yet even if trap function ctrl_c_trap was supposedly called first (?)
      #if [ -z ${CTRL_C+x} ] || [ $CTRL_C] ; then
      #  echo $CTRL_C
      if macos; then
        shift
        local msg="$@"
        if [ -n "$msg" ]; then
          message "$msg" "${desc} is up"
        else
          message "${desc} is up" "Time's up"
        fi
      fi
    else
      printf "${RED}Error in argument${NC}\n"
    fi
  fi
}

function sleepmin {
  if [ -z "$1" ]; then
    echo "Usage:"
    echo "sleepmin [min]"
  else
    sleep $(( $1*60 ))
  fi
}

########

function repl {
  if [ -f "repl.js" ]; then
    printf "${YELLOW}Using local ./repl.js${NC}\n"
    node --use_strict ./repl.js
  else
    node --use_strict ~/Projects/scripts/repl.js
  fi
}

function get_npm_version() {
  npm --no-git-tag-version version patch
}

function npm_patch {
  local ver=$(get_npm_version)
  printf "Updated package.json to ${YELLOW}${ver}${NC}\n"
}

function publish_npm {
  local version=$(get_npm_version)
  printf "Updated package.json to ${YELLOW}${version}${NC}\n"

  git add package.json
  git commit --amend
  printf "\n${RED}Ammended to:${NC}\n"
  git log -n 1

  git tag $version
  printf "\n${BLUE}Tagged git repo with ${version}${NC}\n\n"

  npm publish
  printf "\n${MAGENTA}Published ${version}${NC}\n"
}

function tag {
  #get highest tag number
  VERSION=`git describe --abbrev=0 --tags`

  #replace . with space so can split into an array
  VERSION_BITS=(${VERSION//./ })

  #get number parts and increase last one by 1
  VNUM1=${VERSION_BITS[0]}
  VNUM2=${VERSION_BITS[1]}
  VNUM3=${VERSION_BITS[2]}
  VNUM3=$((VNUM3+1))

  #create new tag
  NEW_TAG="$VNUM1.$VNUM2.$VNUM3"

  echo "Updating $VERSION to $NEW_TAG"

  #get current hash and see if it already has a tag
  GIT_COMMIT=`git rev-parse HEAD`
  NEEDS_TAG=`git describe --contains $GIT_COMMIT`

  #only tag if no tag already (would be better if the git describe command above could have a silent option)
  if [ -z "$NEEDS_TAG" ]; then
      echo "Tagged with $NEW_TAG (Ignoring fatal:cannot describe - this means commit is untagged) "
      git tag $NEW_TAG
      git push --tags
  else
      echo "Already a tag on this commit"
  fi
}

# repl
# function re {
#   if [ -f ./mix.exs ]; then
#     printf "${YELLOW}mix console?${NC}\n"
#   elif [ -f ./package.json ]; then
#     printf "${YELLOW}node${NC}\n"
#     node
#   else
#     node
#   fi
# }

alias preety="prettier --write --print-width 160 --single-quote *.js"

function nd {
  run_on_file "$1" "node debug" '*.js'
}

# tip: install from github: npm install --save user/repo
function ni {
  if [ "`pwd`" == "/Users/${USER}/Projects/node" ]; then
    printf "${RED}Ups, get out of this directory${NC}\n"
    return
  fi

  if [ -z "$1" ]; then
    #echo "Usage: ni [npm_module]"
    if [ -f "package.json" ]; then
      npm install
    else
      node_init
    fi
  else
    if [ ! -f "package.json" ]; then
      node_init
    fi
    npm install "$@" --save
  fi
}

function node_init {
  if [ -f "package.json" ]; then
    printf "${RED}package.json already exists${NC}\n"
  else
    local name="$1"
    if [ -z "$name" ]; then
      name=$(basename "`pwd`")
    fi
    sed -e "s/<name>/${name}/g" "$DMT_PATH/etc/templates/node/package.json" > package.json
    if [ ! -f ".gitignore" ]; then
      #echo "node_modules" > .gitignore
      ignore_node
    fi
    printf "${YELLOW}package.json${NC} created with name ${CYAN}${name}${NC}\n"
  fi
}

function ignore_node {
  cp "$DMT_PATH/etc/templates/node/gitignore" .gitignore
}

function setup_linter {
  if [ ! -f "package.json" ]; then
    printf "${RED}Not in a npm project${NC}\n"
  else
    echo "Installing deps..."

    (
      export PKG=eslint-config-airbnb;
      npm info "$PKG@latest" peerDependencies --json | command sed 's/[\{\},]//g ; s/: /@/g' | xargs npm install --save-dev "$PKG@latest"
    )
    # source: https://www.npmjs.com/package/eslint-config-airbnb

    # had issues with eslint-plugin-jsx-a11y errors
    # npm install eslint-plugin-jsx-a11y --save-dev
    # npm install eslint --save-dev
    # npm install eslint-plugin-import --save-dev
    # npm install eslint-plugin-react --save-dev
    # npm install eslint-config-airbnb --save-dev

    echo
    update_linter
  fi
}

# function update_linter {
#   local conf="$DMT_PATH/etc/templates/node/.eslintrc.json"
#   if [ -f "$conf" ]; then
#     printf "${YELLOW}Copying ${conf} ...${NC}\n"
#     cp "$conf" .
#     printf "${GREEN}done${NC}\n"
#   else
#     printf "${RED}Cannot complete (or update) linter because file ${conf} is missing...${NC}\n"
#   fi
# }

function restart_airplay {
  sudo systemctl restart shairport-sync
}
alias airplay_restart="restart_airplay"

function nid {
  if [ -z "$1" ]; then
    echo "Usage: nid [npm_module]"
  else
    npm install "$1" --save-dev
  fi
}

function dn {
  doc npm "$@"
}

function linked {
  #ls -l $HOME/n/lib/node_modules | grep ^l
  find /usr/local/lib/node_modules -type l -d 1 -exec ls -lah {} \;
  #RECURSIVE and SLOWER: find $HOME/n/lib/node_modules -type l -exec ls -lah {} \;

  #find ~/Dropbox -type l -exec ls -lah {} \;

  #Recursive: ls -lR $HOME/n/lib/node_modules | grep ^l
  #find "$HOME/n/lib/node_modules" -type l -name '.git' -prune -o -print | uniq | grep "$1" -i
}

function global {
  #printf "${YELLOW}/usr/local/bin/n${NC}\n"
  #echo
  local n_direct_install=~/n/lib/node_modules
  local n_homebrew_install=/usr/local/lib/node_modules

  local global_node_modules

  if [ -d $n_direct_install ]; then # installed n directly
    global_node_modules=$n_direct_install
  elif [ -d $n_homebrew_install ]; then # installed via homebrew
    global_node_modules=$n_homebrew_install
  else
    printf "${RED}n installation not found...${NC}\n"
    return
  fi


  if [ -z "$1" ]; then
    ls -la $global_node_modules
    printf "${YELLOW}${global_node_modules}${NC}\n"
    if [ -d ~/n/lib/node_modules ]; then # installed n directly
      printf "${YELLOW}n installed directly...${NC}\n"
      global_node_modules=~/n/lib/node_modules
    elif [ -d /usr/local/lib/node_modules ]; then # installed via homebrew
      printf "${YELLOW}n installed via homebrew...${NC}\n"
      global_node_modules=/usr/local/lib/node_modules
    fi
  else
    awesome_cd $global_node_modules "$1"
  fi
}

############### NODE.JS -- END

alias psq="sudo -u postgres psql"

# fix permissions
function fixperm() {
  local dir="$1"
  if [ -z "$dir" ]; then
    dir="."
  fi
  chmod -R uog+r "$dir"
}

# fix permissions
function fixperm2() {
  local dir="$1"
  if [ -z "$dir" ]; then
    dir="."
  fi
  sudo chown -R 1000:1000 "$dir"
  chmod -R 644 "$dir"
}

function find_recent() {
  find . -type f -mmin -$1 -not -name .DS_Store -exec ls -lh {} \; | sed 's/\.\///' | awk '{print $5, substr($0,index($0,$9))}'
  #| cut -d' ' -f6-
}

alias min="find_recent 2"
alias hour="find_recent 60"
alias day="find_recent 1440"

alias mk="mkdir"
alias mkp="mkdir -p"
k () { mkdir -p "$@" && cd "$_"; }

# sum column of numbers...
# 1 lala
# 234 aaavdfv
# 54 sdfdsf
function total {
  cat $1 | awk '{s+=$1} END {printf "Sum: %.0f\n", s}'
}

alias aria="aria2c" # http://aria2.sourceforge.net/ - The next generation download utility.

function wh {

  if [[ "$1" =~ \.com$ ]]; then
    local match=$(whois "$1" | grep "No match for domain" | wc -l)
    if [ ! $match -eq 0 ]; then
      printf "${GREEN}${1} is available${NC}\n"
    else
      printf "${RED}${1} not available${NC}\n"
    fi
  elif [[ "$1" =~ \.io$ ]]; then
    local match=$(whois "$1" | grep "NOT FOUND" | wc -l)
    if [ ! $match -eq 0 ]; then
      printf "${GREEN}${1} is available${NC}\n"
    else
      printf "${RED}${1} not available${NC}\n"
    fi
  elif [[ "$1" =~ \.eu$ ]]; then
    local match=$(whois "$1" | grep "Status: AVAILABLE" | wc -l)
    if [ ! $match -eq 0 ]; then
      printf "${GREEN}${1} is available${NC}\n"
    else
      printf "${RED}${1} not available${NC}\n"
    fi
  else
    whois "$1"
  fi
}

function root {
  if macos; then
    sudo bash -l # makes process substitution (<) work: https://unix.stackexchange.com/questions/42973/bash-process-substitution-does-not-work-as-root-on-os-x
  else
    sudo -i
  fi
}

alias pb=pbcopy

alias fd="sudo fdisk -l"

# iterm2
alias normal='echo -e "\033]50;SetProfile=Default\a"'
alias large='echo -e "\033]50;SetProfile=LargeFont\a"'

#brew install highlight
#alias pcat="pygmentize -f terminal256 -O style=monokai -g"
function hcat {
  highlight -O xterm256 -s darkbone "$@"
}

# Save temporary command in ~/Desktop
#
function temp_cmd {
  local cmd=~/Desktop/temp_cmd

  if [ "$1" == "remove" ] && [ -f "$cmd" ]; then
    rm $cmd
    printf "${YELLOW}~/temp_cmd deleted${NC}\n"
    return
  fi

  if [ -f "$cmd" ]; then
    chmod u+x $cmd
    local contents=`cat $cmd`
    printf "${YELLOW}${contents}${NC}\n"
    $cmd
  else
    nano "$cmd"
    if [ -f "$cmd" ]; then
      chmod u+x $cmd
      local contents=`cat $cmd`
      printf "Command saved: ${YELLOW}${contents}${NC}\n\n"
      printf "You can run it with: ${MAGENTA}temp_cmd${NC}\n"
    fi
  fi
}

# themes: highlight -w
# in sublime there is SublimeHighlight plugin (use for Elixir since there is no Elixir syntax in highlight)
function code {
  if [ -z "$1" ]; then
    echo "Copies code in rtf format for slides"
    echo
    echo "code example.js"
    echo "code themes"
    echo "code example.js dark"
    echo "code example.js [theme]"
  else
    local theme="bright"
    if [ -n "$2" ]; then
      if [ "$2" == 'dark' ]; then
        theme="darkbone"
      else
        theme="$2"
      fi
    fi

    if [ "$1" == 'themes' ]; then
      highlight -w
    else
      highlight -O rtf -s $theme $1 | pb
    fi
    # moe, acid
  fi
}

function snip {
  snippet "$@"
}

function snippet {

  local sublime_snippets_folder="/Users/${USER}/Library/Application Support/Sublime Text 3/Packages/User/"

  if [ -z "$1" ] || [ "$1" == "-h" ]; then
    #printf "${YELLOW}Usage:${NC}\n"
    #echo "${opts[@]}"
    ls "$sublime_snippets_folder" | grep "snippet$"
    echo
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}snippet edit [keyword]${NC} ${GRAY}edit${NC}\n"
    printf "${GREEN}snippet create [keyword]${NC} ${GRAY}create and edit (ext is added automatically)${NC}\n"
    printf "${GREEN}snippet cd${NC} ${GRAY}move to directory with snippets${NC}\n"
    return
  fi

  declare -a opts=(
    "edit"
    "create"
    "cd"
  )

  local matching_opt=''
  opts_matcher matching_opt "$1" "${opts[@]}"
  if [ $? -ne 0 ]; then # error
    matching_opt="[DEFAULT]" # default ... will trigger *) case below
  fi

  shift

  case "$matching_opt" in
    edit)
       local dir="`pwd`"
       cd "$sublime_snippets_folder"
       run_on_file "$1" "subl" '*.sublime-snippet'
       cd "$dir"
      ;;

    create)
        local dir="`pwd`"
        cd "$sublime_snippets_folder"
        local snippet_file="${1}.sublime-snippet"
        cat > "${snippet_file}" <<EOF
<snippet>
  <content><![CDATA[
const \${1} = require('\${1}');
]]></content>
  <!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
  <tabTrigger>require</tabTrigger>
  <!-- Optional: Set a scope to limit where the snippet will trigger -->
  <scope>source.js</scope>
</snippet>
EOF
        subl "${snippet_file}"
        cd "$dir"
      ;;

    cd)
      cd "$sublime_snippets_folder"
      ;;

    *)
      ls -1 "$sublime_snippets_folder" | grep "snippet$" | grep "$@"
      ;;
  esac
}

# utility function
function current_usage {
  local output=$(du -sh | awk '{ print $1 }')
  printf "${YELLOW}${output}${NC}\n"
}

function freespace {
  printf "Free:\t ${GREEN}`df -h . | tail -1 | awk '{ print $4 }'`${NC}\n"
}

function space {
  local dir="`pwd`"
  if [ -n "$1" ]; then
    if [ -d "$1" ]; then
      dir="$1"
    else
      printf "${RED}No such directory${NC}\n"
      return
    fi
  fi

  if [ ! "$dir" == $HOME ] && [ ! "$dir" == '/' ]; then
    if [ "$dir" == "`pwd`" ]; then
      printf "Current: "
      current_usage
    else
      printf "${dir}: "
      local cwd="`pwd`"
      cd "$dir"
      current_usage
      cd "$cwd"
    fi
  fi
  freespace
}

# utility function
function usage_for {
  printf "${1} "
  if [ -d "${1}" ]; then
    cd "$1"
    current_usage
  else
    printf "${RED}No such directory${NC}\n"
  fi
}

function usage {
  if macos; then
    #ls -1d -- */ | xargs -I{} du -sh -- {} | gsort -hr # probably need: "brew install coreutils" for gsort
    find . -maxdepth 1 -type d -print0 | xargs -0 -I{} du -sh {} | gsort -hr # probably need: "brew install coreutils" for gsort
  else
    find . -maxdepth 1 -type d -print0 | xargs -0 -I{} du -sh {} | sort -hr
    #ls -1d */ | xargs -I{} du -sh {} | sort -hr
  fi
  #ls -1d */ | xargs -I{} du -sh {} && du -sh | sort -r
}

function count {

  local dir=""
  if [ -z "$1" ]; then
    dir="."
  else
    if [ -d "$1" ]; then
      dir="$1"
      printf "${YELLOW}${dir}:${NC}\n"
    else
      printf "${RED}No such directory${NC}\n"
      return
    fi
  fi

  printf "${CYAN}Directories: "
  find "$dir" -maxdepth 1 ! -path . ! -path "*/.git" -type d | wc -l | xargs
  printf "${GREEN}Files:       "
  find "$dir" -maxdepth 1 ! -path "*/.DS_Store" ! -path "*/.git" -type f | wc -l | xargs
  printf "${NC}"

  # echo
  # printf "${CYAN}Directories (Recursive): "
  # find "$dir/" ! -path . ! -path "*/.git/*" -type d | wc -l | xargs # "/" is needed if we use "count ~/path/to/symlinked_directory", it's changed to: "count ~/path/to/symlinked_directory/"
  # printf "${GREEN}Files: (Recursive):      "
  # find "$dir/" ! -path "*/.DS_Store" ! -path "*/.git/*" -type f | wc -l | xargs
  # printf "${NC}"
}

function countr {

  count "$@"

  local dir=""
  if [ -z "$1" ]; then
    dir="."
  else
    if [ -d "$1" ]; then
      dir="$1"
      printf "${YELLOW}${dir}:${NC}\n"
    else
      printf "${RED}No such directory${NC}\n"
      return
    fi
  fi

  echo
  printf "${CYAN}Directories (Recursive): "
  find "$dir/" ! -path . ! -path "*/.git/*" -type d | wc -l | xargs # "/" is needed if we use "count ~/path/to/symlinked_directory", it's changed to: "count ~/path/to/symlinked_directory/"
  printf "${GREEN}Files: (Recursive):      "
  # If you have issues here: for example mismatch in number of files in two directories where one is a copy of another,
  # it's almost certainly symlinks issue, find out like this:
  # Directory A) find . -type f > ~/Desktop/a.txt
  # Directory B) find . -type f > ~/Desktop/b.txt
  # Compare: diff ~/Desktop/a.txt ~/Desktop/b.txt
  find "$dir/" ! -path "*/.DS_Store" ! -path "*/.git/*" -type f | wc -l | xargs
  printf "${NC}"
}

function lines {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}lines [file.txt] ${GRAY}counts the number of lines in the file${NC}\n"
  else
    cat "$1" | wc -l
  fi
}

function space2rem {
  if [ "$EUID" -ne 0 ]; then
    echo "please run under root - execute: root"
    return
  fi
  find /var/folders -name "*.iscachebmp" -type f -exec rm -v "{}" \;
  find /private/var/folders -name "*.iscachebmp" -type f -exec rm -v "{}" \;
}

# swap files or directories
function swap {
  if [ -n "$1" ] && [ -n "$2" ]; then
    swap_once "$1" "$2"
  elif [ -f "config.json.sample" ] && [ -f "config.json" ]; then
    swap_once "config.json.sample" "config.json"
  elif [ -f "david_wallet" ] && [ -f "default_wallet" ]; then
    swap_once "david_wallet" "default_wallet"
  fi
}

function swap_once {
  mv "$1" /tmp/switch_temp
  mv "$2" "$1"
  mv /tmp/switch_temp "$2"
}

# rename file or directory by adding _ at the end
# or if _ is present, remove it
function ren {
  local subject
  if [[ "$1" == */ ]]; then
    subject=$(echo "$1" | sed 's/.$//')
  else
    subject="$1"
  fi

  local new
  if [[ "$subject" == *_ ]]; then
    new=$(echo "$subject" | sed 's/.$//')
  else
    new="${subject}_"
  fi

  mv "$subject" "$new"
}

# Example:
#
# $ find . | grep core_ext
# ./config/initializers/core_ext.rb
# ./spec/lib/core_ext_spec.rb
#
# $ grab 2
# ./spec/lib/core_ext_spec.rb ===> (also copied on clipboard)
#
# Without arguments the default is to grab the first line
grab() {
  local num=1
  if [ -n "$1" ]; then
    num=$1
  fi
  local line=`$(history | tail -2 | head -1 | cut -d" " -f4-) | sed "${num}q;d" | sed 's/commit //'`
  echo $line | tr -d "\n" | pbcopy
  echo $line
}

function chrome {
  "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome" --disable-new-avatar-menu &
}

function sleepin {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC} sleepin 10 (min)\n"
  else
    local delay=$(($1*60))
    sleep $delay && pmset sleepnow # with && - if you cancel with ctrl+c it works correctly (semicolon doesn't!)
  fi
}

alias pumar="kill -SIGUSR2 `ps aux | grep tcp://0.0.0.0:$port | grep puma | awk '{ print $2 }'`"
alias updatedb="sudo /usr/libexec/locate.updatedb"

alias blackie="cd /Volumes/BLACKIE/Backups.backupdb/eclipse/Latest/Macintosh\ HD$HOME"
alias sublime="cd '$HOME/Library/Application Support/Sublime Text 3/Packages/User'"

# ping server (ex. server.com) or "resource" (http://server.com/file)
function pi {
  local target="1.0.0.1"
  if [ -n "$1" ]; then
    if [[ "$1" =~ \/ ]]; then
      if [[ $(curl -I --write-out %{http_code} --silent --output /dev/null "$@") == "200" ]]; then
        printf "${GREEN}✓ CurlPing OK, Returned status 200${NC}\n"
      else
        printf "${RED}✖ NOT FOUND${NC}\n"
      fi
    else
      printf "${GRAY}Pinging ${@} ...${NC}\n"
      if [[ $(ping -c 1 "$@" 2>&1) == *"0% packet loss"* ]]; then
        printf "${GREEN}✓ Ping OK${NC}\n"
      else
        printf "${RED}✖ NO CONN${NC}\n"
      fi
    fi
  else
    printf "${GRAY}Pinging ${target} ...${NC}\n"
    if [[ $(ping -c 1 "$target" 2>&1) == *"0% packet loss"* ]]; then
      printf "${GREEN}✓ Ping OK${NC}\n"
    else
      printf "${RED}✖ NO CONN${NC}\n"
    fi
  fi
}

function ux {
  matching_file=''
  get_matching_file matching_file "$1"
  matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

  if [ -f "$matching_file" ]; then
    printf "chmod u+x ${YELLOW}$matching_file${NC}\n"
    chmod u+x "$matching_file"
  else
    printf "${RED}File not found${NC}\n"
  fi
}

function archive {
  if [ -n "$1" ]; then
    mv $1 ~/Misc/Archive/
  else
    cd ~/Misc/Archive/
  fi
}

function archive_short {
  if [ -n "$1" ]; then
    mv $1 ~/Misc/Archive/Short\ Term/
  else
    cd ~/Misc/Archive/Short\ Term/
  fi
}

function getlog {
  remote -h "$1" "cat /var/log/syslog | grep shairpo > /tmp/log.txt"
  scp "${1}:/tmp/log.txt" .
}

function remove_ds_store {
  find . -name ".DS_Store" -depth -exec rm {} \;
}

function remove_ds_global {
  sudo find / -name ".DS_Store" -depth -exec rm {} \;
}

# *** nginx on server ***

alias ci="curl -I"

function nginx_executable() {
  local executable2
  if [ -f "/usr/sbin/nginx" ]; then
    executable2="/usr/sbin/nginx"
  elif [ -f "/opt/nginx/sbin/nginx" ]; then
    executable2="/opt/nginx/sbin/nginx"
  elif [ -f "/usr/local/bin/nginx" ]; then
    executable2="/usr/local/bin/nginx"
  else
    executable2=""
  fi
  eval "$1=${executable2}"
}

function nr {
  # lighttpd
  if [ -f /etc/lighttpd/lighttpd.conf ]; then
    printf "${YELLOW}Found lighttpd, reloading configuration...${NC}\n"

    if macos; then

      # if pid file is found,
      # - there is no process with this pid, try to start lighttpd
      # - if there is a process with this pid, send it a kill signal (reloads the configuration)
      if [ -f /var/run/lighttpd.pid ]; then
        local pid=$(cat /var/run/lighttpd.pid)

        local procs=$(ps -p $pid -o comm=) # find process executable by process id

        if [ "$procs" == "" ]; then # lighttpd is not there
          printf "${RED}lighttpd is not running (stale .pid file, possible configuration error!!)...${NC}\n"
          printf "${YELLOW}trying to start it...${NC}\n"
          sudo /usr/local/bin/lighttpd -f/etc/lighttpd/lighttpd.conf -D
        else
          sudo kill -9 $pid
        fi
      else
        printf "${YELLOW}lighttpd is not running...${NC}\n"
        printf "${YELLOW}trying to start it...${NC}\n"
        sudo /usr/local/bin/lighttpd -f/etc/lighttpd/lighttpd.conf -D
        return
      fi
    else
      sudo service lighttpd force-reload
    fi
    #printf "${GREEN}ok.${NC}\n"
    return
  fi

  # nginx
  if hash service 2>/dev/null; then
    service nginx reload
  else
    local executable=''
    nginx_executable executable

    if [ -n "$executable" ]; then
      local output
      if macos; then
        output=$($executable -s reload 2>&1)
      else
        output=$(sudo $executable -s reload 2>&1)
      fi
      if [ -z "$output" ]; then
        printf "${GREEN}OK${NC}\n"
      else
        printf "${RED}${output}${NC}\n"
      fi
    else
      if [ -f "/etc/init.d/nginx" ]; then
        sudo /etc/init.d/nginx restart
      else
        printf "${RED}Can't find nginx${NC}\n"
      fi
    fi
  fi
}

alias nr2="sudo service nginx restart"

function nt {
  # lighttpd
  if [ -f /etc/lighttpd/lighttpd.conf ]; then
    #printf "${YELLOW}Found lighttpd, reloading configuration...${NC}\n"
    local cmd="lighttpd"
    if [ -f /usr/sbin/lighttpd ]; then # on debian it wasn't in path after install
      cmd="/usr/sbin/lighttpd"
    fi
    $cmd -t -f /etc/lighttpd/lighttpd.conf
    printf "${YELLOW}Warning: even if syntax is ok, lighttpd might fail to run for semantic reasons${NC}\n"
    printf "${YELLOW}when using nr for restating, run twice to be sure!${NC}\n"
    return
  fi

  # nginx
  if [ -d /opt/nginx ]; then
    printf "Folder: ${YELLOW}/opt/nginx${NC}\n"
  elif [ -d /etc/nginx ]; then
    printf "Folder: ${YELLOW}/etc/nginx${NC}\n"
  fi

  local executable=''
  nginx_executable executable

  if [ -z "$executable" ]; then
    printf "${RED}Can't find nginx executable${NC}\n"
  fi

  if [ -n "$executable" ]; then
    printf "Executable: ${YELLOW}${executable}${NC}\n"
    local output
    if macos; then
      output=$($executable -t 2>&1)
    else
      output=$(sudo $executable -t 2>&1)
    fi
    if [[ $output == *"test is successful"* ]]; then
      printf "${GREEN}${output}${NC}\n"
    else
      printf "${RED}${output}${NC}\n"
    fi
  fi
}

function ne {
  if macos; then
    tail -f /var/log/nginx/error.log
  else
    sudo tail -f /var/log/nginx/error.log
    #printf "${RED}Not on the server${NC}\n"
  fi
}

function sites {
  if macos; then
    awesome_cd ~/.dmt/user/sites "$1"
  else
    if [ -d /opt/nginx/conf/sites/ ]; then
      cd /opt/nginx/conf/sites/
    elif [ -d /etc/nginx/sites ]; then
      cd /etc/nginx/sites
    elif [ -d /etc/nginx/sites-available ]; then
      cd /etc/nginx/sites-available
    elif [ -d /etc/apache2/sites-available ]; then
      cd /etc/apache2/sites-available
    else
      printf "${RED}Can't find nginx sites folder${NC}\n"
    fi
  fi

  if [ -n "$1" ]; then
    if [ "$1" == "ports" ]; then
      grep -r "localhost" .
    else
      grep -r "localhost" . | grep "$1"
    fi
  fi
}

function hosts {
  if [ -f /private/etc/hosts ]; then
    sudo nano /private/etc/hosts
  elif [ -f /etc/hosts ]; then
    sudo nano /etc/hosts
  else
    printf "${RED}Cannot find hosts file${NC}\n"
  fi
}

# ******

alias list="ls -la | grep"

function ta {
  tail -n 25 "$@"
}

function ta50 {
  tail -n 50 "$@"
}

function ta100 {
  tail -n 100 "$@"
}

# function v() {
#   if [[ "$1" == *".js" ]]; then
#     echo '"use strict"' > $1
#   else
#     touch "$1"
#   fi
# }

# function copp {
#   pwd | sed 's/\/Users\/david/~/' | tr -d '\n' | pbcopy
# }

# MacOS niceties

function lock {
  if [ -n "$1" ]; then
    local seconds=0
    local val=0
    local desc=""
    local denom=""

    convert_to_seconds seconds val desc denom "$1"
    sleep $seconds
  fi

  /System/Library/CoreServices/ScreenSaverEngine.app/Contents/MacOS/ScreenSaverEngine
}

function lock2 {
  if [ -n "$1" ]; then
    local seconds=0
    local val=0
    local desc=""
    local denom=""

    convert_to_seconds seconds val desc denom "$1"
    sleep $seconds
  fi

  /System/Library/CoreServices/"Menu Extras"/User.menu/Contents/Resources/CGSession -suspend
}

function off {
  #trap 'return' INT

  if [ -n "$1" ]; then
    local seconds=0
    local val=0
    local desc=""
    local denom=""

    convert_to_seconds seconds val desc denom "$1"
    sleep $seconds
  fi

  #alarm light off # crap dependecy!!! what if network or target device is unreachable, it could hang here

  pmset sleepnow
}

function suck {
     #--recursive \
     #--html-extension \
     #--no-parent
     #--wait=9 \
     # -U mozilla \
     #--exclude-domains quantserve.com
     #--domains filepi.com
     #--limit-rate=20K \

  # mirror ? -m

  domain=`ruby -ruri -e "puts URI.parse('$1').host"`

  mkdir -p "$domain"
  cd "$domain"

  wget \
     --page-requisites \
     --convert-links \
     --adjust-extension \
     --html-extension \
     --random-wait \
     --domains $domain \
     --no-check-certificate \
     --span-hosts \
     -e robots=off \
     -U "Mozilla/5.0 (X11; U; Linux; en-US; rv:1.9.1.16) Gecko/20110929 Firefox/3.5.16" \
       $1

  printf "\n${YELLOW}Got all resources from $domain. To get all of them, remove --domains flag and run again${NC}\n"
}

alias suckjs="phantomjs ~/Projects/scripts/save_page.js"

# miha's solution: https://gist.github.com/mrfoto/c6072e4fede3a6fe0f6b
function ssh {
  if [ -f /usr/local/bin/sshrc ]; then
    printf "\033]6;1;bg;red;brightness;162\a\033]6;1;bg;green;brightness;209\a\033]6;1;bg;blue;brightness;147\a"
    #https://www.iterm2.com/documentation-escape-codes.html
    #echo -e "\033]6;1;bg;green;brightness;0\a"
    command sshrc "$@"
    # caused problems ....
    # now we still have a problem when trying to log into OpenWRT (dropbear) powered ssh for example...)
    # if [ ! $? -eq 0 ]; then
    #   printf "${MAGENTA}Failed ssh via sshrc, trying /usr/bin/ssh${NC}\n"
    #   /usr/bin/ssh "$@"
    # fi
    echo -e "\033]6;1;bg;*;default\a"
  else
    command ssh "$@"
  fi
}

function ssh2 {
  command ssh "$@"
}

# iperf2
function speed {
  local host=''
  if [ -n "$1" ]; then
    host="$1"
  else
    local network_id=''
    network_def_reader host network_id "iperf"
  fi

  if [ -z "$host" ]; then
    printf "${RED}Host not specified either as a first argument or in networks.def (iperf: [ip]])${NC}\n"
    return
  fi

  which iperf > /dev/null 2>&1

  if [ $? -eq 0 ]; then
    printf "${GREEN}Measuring...${NC}\n"
  else
    printf "${MAGENTA}iperf is missing, installing...${NC}\n"
    sudo apt-get -y install iperf
    printf "\n${GREEN}Testing...${NC}\n"
  fi

  iperf -c "$host"
}

function speed3 {
  local host=''
  if [ -n "$1" ]; then
    host="$1"
  else
    local network_id=''
    network_def_reader host network_id "iperf"
  fi

  if [ -z "$host" ]; then
    printf "${RED}Host not specified either as a first argument or in networks.def (iperf: [ip]])${NC}\n"
    return
  fi

  if [ "$1" == "-h" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}speed${NC} ${GRAY}measures sending to default host${NC}\n"
    printf "${GREEN}speed [host]${NC} ${GRAY}specify another host${NC}\n"
    printf "${GREEN}speed [host] -R${NC} ${GRAY}reverse mode - server is sending${NC}\n"
    printf "${GREEN}speed [host] -u${NC} ${GRAY}udp test${NC}\n"
    return
  fi

  if [ -n "$1" ] && [[ "$1" != "-"* ]]; then
    host="$1"
    shift
  fi

  which iperf3 > /dev/null 2>&1

  if [ $? -eq 0 ]; then
    printf "${GREEN}Measuring...${NC}\n"
  else
    printf "${MAGENTA}iperf3 is missing, installing...${NC}\n"
    sudo apt-get -y install iperf3
    printf "\n${GREEN}Testing...${NC}\n"
  fi

  iperf3 $@ -c $host
}

function reset_npm {
  rm -rf node_modules
  npm cache clean
  npm install
}

alias np="npm publish"

function json {
  curl -s "$1" | jq .
}

# post_json data.json localhost:3000/api/readings
function post_json {
  curl -H "Content-Type: application/json" -d @"$1" "$2"
}

function ee {
  if macos; then
    awesome_cd ~/Misc/Electronics "$1"
  fi
}

function flash_usage {
  local sectors="$1"
  printf "${YELLOW}Usage:${NC}\n"
  printf "${GREEN}flash image.img 2${NC} ${GRAY}flash image.img to /dev/rdisk2${NC}\n"
  printf "${GREEN}flash read 2${NC} ${GRAY}read full image from /dev/rdisk2 to ./image.img${NC}\n"
  printf "${GREEN}flash read 2 16gb${NC} ${GRAY}read sectors 0..${sectors} from /dev/rdisk2 to ./image.img${NC}\n"
  #printf "${GREEN}flash read 2 default${NC} ${GRAY}read sectors 0..${sectors} from /dev/rdisk2 to ./image.img${NC}\n"
  printf "${GREEN}flash read 2 [nSectors]${NC} ${GRAY}read sectors 0..nSectors from /dev/rdisk2 to ./image.img${NC}\n"
}

function flash {
  local file_pattern="$1"
  local disk_n="$2"

  #local defaultSectors="20000768" # 9.5GB, divisible by 4096 for optimal sector alignment
  local sectors16gb="31116288" # 16GB


  if [ "$1" == "-h" ] || [ -z "$1" ]; then
    printf "${YELLOW}diskutil list:${NC}\n\n"
    diskutil list
    flash_usage "$sectors16gb"
    return
  fi

  if [ -z "$file_pattern" ]; then
    printf "${YELLOW}diskutil list:${NC}\n\n"
    diskutil list
    printf "${YELLOW}Usage:${NC}\n"
    echo "flash file.img diskN"
    return
  fi

  if [ "$1" == "read" ]; then
    if [ -z "$disk_n" ]; then
      printf "${YELLOW}diskutil list:${NC}\n\n"
      diskutil list

      printf "${MAGENTA}You have to specify the disk number from where to create the image${NC}\n"
      echo

      flash_usage "$sectors16gb"
    else
      local image="image.img"

      if [ -f "$image" ]; then
        printf "${RED}image.img already exists${NC}\n"
        return
      fi

      if [ -z "$3" ]; then
        printf "${GREEN}Copying full image to ${YELLOW}${image}${NC}\n"
        time sudo dd if="/dev/rdisk${disk_n}" of="${image}" bs=64k
      else
        local sectors

        if [ "$3" == "16gb" ] || [ "$3" == "16GB" ]; then
          printf "${GREEN}Reading first 16gb from sd card ... ${NC}\n"
          sectors="$sectors16gb"
        else
          sectors="$3"
        fi

        printf "${GREEN}Copying sectors${NC} 0..${sectors} to ${YELLOW}${image}${NC}\n"

        # Usually the number of sectors will be a multiple of some power of 2, and you can increase the copying speed
        # by increasing the block size and decreasing the count, keeping the product constant.
        if ! (( $sectors % 64 )) ; then
          printf "${MAGENTA}Optimal speed: number of sectors divisible by 64 - reading 128 sectors (64K) at a time${NC}\n"
          # for default 20000000 sectors it takes around 150s to copy data from sd card
          # 1 sector = 512b
          # 64K seems to be quite optimal, no difference with 1M, but faster than 32K or less
          time sudo dd if="/dev/rdisk${disk_n}" of="${image}" bs=64k count="$((sectors/128))"
        elif ! (( $sectors % 32 )) ; then
          printf "${MAGENTA}Almost optimal speed: number of sectors divisible by 32 - reading 64 sectors (32K) at a time${NC}\n"
          time sudo dd if="/dev/rdisk${disk_n}" of="${image}" bs=32k count="$((sectors/64))"
        else
          time sudo dd if="/dev/rdisk${disk_n}" of="${image}" bs=512 count="${sectors}"
        fi
      fi

      if [ -f "image.img" ]; then
        sudo chown $(whoami) image.img
        if macos; then
          sudo chgrp staff image.img
        fi
      fi
    fi

    return
  fi

  matching_file=''
  get_matching_file matching_file "$file_pattern"
  matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

  if [ ! -f "$matching_file" ]; then
    printf "${RED}No such file: ${file_pattern}${NC}\n"
  else
    if [ -z "$disk_n" ]; then
      printf "${YELLOW}diskutil list:${NC}\n\n"
      diskutil list

      printf "${MAGENTA}You have to specify the disk number where to flash ${GREEN}${matching_file}${NC}\n"
      echo

      flash_usage "$sectors"
    else
      printf "Flashing ${YELLOW}${matching_file}${NC} to ${RED}rdisk${disk_n}${NC}...\n"
      read -r -p "Sure????? (you will be asked for sudo password) [Y/n] " response
      if [[ ! $response =~ ^([nN])$ ]]
      then
        printf "${YELLOW}Flashing after password...${NC} Press Ctrl+T to see progress\n"
        diskutil unmountDisk "/dev/disk${disk_n}"
        time sudo dd if="$matching_file" of="/dev/rdisk${disk_n}" bs=64m # changed from: 1m
        diskutil eject "/dev/disk${disk_n}"
        printf "${GREEN}done.${NC} ${YELLOW}You can take the SD card out now.${NC}\n"
      fi
    fi
  fi
}

function vol2 {
  local origin="`pwd`"
  local IFS=$'\n' # default is " " and then array is not correctly constructed when there is spaces in filenames
  cd `find /Volumes -maxdepth 1 -type d ! -path . | grep -v "/Volumes$" | grep -v "Macintosh HD" | grep -v "WINDOWS" | grep -v "volume2"`
  if [ -n "$1" ]; then
    awesome_cd . "$1"
    if [ $? -eq 1 ]; then
      cd "$origin"
    fi
  fi
}

function cpd {
  cp $1 ~/Desktop/
}

function md {
  if [ -f "$1" ] || [ -d "$1" ]; then
    mv "$1" ~/Desktop
    if [ $? -eq 0 ]; then
      printf "${YELLOW}Moved ${1} to ~/Desktop\n"
    fi
  else
    printf "${RED}No such file or directory${NC}\n"
  fi
}

function yd {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}yd [id]${NC} - ${GRAY}download a video${NC}\n"
    printf "${GREEN}yd [id1] [id2] [id3]${NC} - ${GRAY}download multiple videos${NC}\n"
    printf "${GREEN}yd [playlistId]${NC} - ${GRAY}download a playlist${NC}\n"
    printf "${GREEN}yd --autonumber [playlistId]${NC} - ${GRAY}download a playlist, autonumbered${NC}\n"
    return
  fi

  if [ "$1" == "--autonumber" ]; then
    shift
    ydpl "$@"
    return
  fi

  if [ -z "$2" ]; then
    youtube-dl -- "$1"
  else
    for var in "$@"
    do
      yd "$var"
    done
  fi
}

function ydpl {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}ydpl [playlistId]${NC} ${GRAY}downloads autonumbered playlist${NC}\n"
    return
  else
    youtube-dl -i -o "%(playlist_index)s %(title)s - %(id)s.%(ext)s" -- "$1"
    #youtube-dl -o "%(playlist_index)s-%(title)s - %(id)s.%(ext)s" -- "$1"
  fi
}

function mp3_helper {
  # duplicate
  ffmpeg -i "$1" -acodec libmp3lame -aq 2 "$1".mp3
}

function mp3 {

  if [ "$1" == "." ]; then
    find *.m4a -type f | xargs -I@ bash -c "$(declare -f mp3_helper) ; mp3_helper \"@\" "
    return
  fi

  if [ -z "$2" ]; then
    if [ -f "$1" ]; then
      ffmpeg -i "$1" -acodec libmp3lame -aq 2 "$1".mp3
      # batch --
      # for foo in *.m4a; do ffmpeg -i "$foo" -acodec libmp3lame -aq 2 "${foo%.m4a}.mp3"; done
    else
      youtube-dl -x --audio-format mp3 -- "$1"
    fi
  else
    for var in "$@"
    do
      mp3 "$var"
    done
  fi
}


function mp4 {
  if [ -n "$1" ]; then
    for file in "$@"
    do
      if [ -f "$file" ]; then
        # http://www.bugcodemaster.com/article/convert-videos-mp4-format-using-ffmpeg
        ffmpeg -i "$file" "$file".mp4 -preset veryfast
      else
        echo "File $file doesn't exist"
      fi
    done
  else
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}mp4 file1 file2 file3 ...${NC} ${GRAY}convert different video formats to mp4${NC}\n"
  fi
}


alias vlc="open -n /Applications/VLC.app"

# Requirement for static server: npm install -g http-server
# Other: elixir, mina, jekyll, node, npm
function serve {
  if [ -f ./server ]; then
    printf "${YELLOW}./server $1${NC}\n"
    ./server $1
  elif [ -f ./mix.exs ]; then
    printf "${YELLOW}mix phoenix.server${NC}\n"
    mix phoenix.server
    # or: iex -S mix phoenix.server
  elif [ -f ./server.js ]; then
    printf "${YELLOW}node server.js${NC}\n"
    node server.js
  elif [ -f ./package.json ] && [ $(ls-scripts | grep 'serve' | wc -l) -gt 0 ]; then
    npm run serve
  # npm install -g npm-ls-scripts
  elif [ -f ./package.json ] && [ $(ls-scripts | grep '^start' | wc -l) = 1 ]; then
    printf "${YELLOW}npm run start${NC}\n"
    npm run start
  elif [ -f ./truffle.js ]; then
    printf "${YELLOW}testrpc --port 8700${NC}\n"
    testrpc --port 8700
  elif [ -f ./index.js ]; then
    local args=$@
    printf "${YELLOW}nodemon index.js ${args}${NC}\n"
    nodemon index.js $args
  elif [ -f ./elm-package.json ]; then
    printf "${YELLOW}elm reactor${NC}\n"
    elm reactor
    #elm-reactor
  elif [ -d _site ]; then
    printf "${YELLOW}jekyll serve${NC}\n"
    jekyll serve
  else
    printf "${YELLOW}http-server -p 3000${NC}\n"
    http-server -p 3000
  fi
}

alias ra="touch index.js"

function tests {

  # test single file
  if [ -n "$1" ] && [ -d "tests" ]; then

    local pattern="$1"
    shift

    local matching_file=''
    get_matching_file matching_file "tests/$pattern" "*.js"
    matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

    if [ ! -f "$matching_file" ]; then
      return
    fi

    printf "${YELLOW}tape ${matching_file} | tap-spec${NC}\n"

    tape "$matching_file" | tap-spec
  else

    if [ -f ./test ]; then
      printf "${YELLOW}./test ${1}${NC}\n"
      ./test "$1"
    fi

    #if grep -Fq '"test":' package.json
    if [ -f 'package.json' ] && [ -d "tests" ]; then

      which tape > /dev/null 2>&1

      if [ $? -ne 0 ]; then
          printf "${RED}missing 'tape' command${NC}\n"
          printf "${YELLOW}npm install -g tape${NC}\n"
          return
      fi

      which tap-spec > /dev/null 2>&1

      if [ $? -ne 0 ]; then
          printf "${RED}missing 'tap-spec' command${NC}\n"
          printf "${YELLOW}npm install -g tap-spec${NC}\n"
          return
      fi

      if grep -Fq '"tape"' package.json
      then

        printf "${YELLOW}tape 'tests/**/*.js'${NC}\n"
        tape 'tests/**/*.js' | tap-spec

        # printf "${YELLOW}npm run test${NC}\n"
        # npm run test

        # if grep -Fxq "import test from 'ava'" test.js
        # then
        #   ava
        # else
        #   printf "${YELLOW}NODE_ENV=test node test.js${NC}\n"
        #   NODE_ENV=test node test.js
        # fi
      # elif [ -d "tests" ]; then
      #   printf "${YELLOW}tape 'tests/**/*.js' | tap-spec${NC}\n"
      #   tape 'tests/**/*.js' | tap-spec
      else
        if [ -f "package.json" ]; then
          if grep -Fq '"test":' package.json
          then
            printf "${YELLOW}npm run test${NC}\n"
            npm run test
            #printf "${RED}Tests not defined${NC}\n"
          fi
        fi
      fi
    fi
  fi
}

function makedocs {
  documentation build "$@" -f html -o docs --shallow
}

function doc {
  node ~/Projects/node/docs/doc.js "$@"
}

# https://gist.github.com/davidhq/9883d43146d1fb2c2c00

# function source_code {
#   local matching_files=$(find . -name "*.${2}" -not -path "*/.git/*" -not -path "*/node_modules/*" -not -path "*/Godeps/*" -not -path "*/elm-stuff/*" -not -path "*/deps/*" -not -path "*/_build/*" -not -path "*/target/*" -not -path "*/dist/*" -not -path "*/bower_components/*" -not -path "*/tmp/*")
#   eval "$1='${matching_files}'"
# }

# npm install -g cloc
function cloc {
  command cloc . --exclude-dir=.git,log,node_modules,Godeps,elm-stuff,deps,_build,target,dist,vendor,bower_components,tmp,deploy,distroot,Deps --exclude-lang=XML
}

function loc {
  if [ -z "$1" ] || [ "$1" == "all" ]; then
    loc js "$2"
    loc ls "$2"
    loc coffee "$2"
    loc c "$2"
    loc cpp "$2"
    loc cs "$2"
    loc cc "$2"
    loc java "$2"
    loc scala "$2"
    loc jsx "$2"
    loc sh "$2"
    loc sol "$2"
    loc ex "$2"
    loc exs "$2"
    loc erl "$2"
    loc go "$2"
    loc rs "$2"
    loc hs "$2"
    loc elm "$2"
    loc rb "$2"
    loc py "$2"
    loc html "$2"
    loc md "$2"
    loc css "$2"
    #loc xml "$2"
    loc json "$2"
  else
    IFS=$'\n'

    local files=$(find . -name "*.${1}" -not -path "*/.git/*" -not -path "*/log/*" -not -path "*/node_modules/*" -not -path "*/assets/*" -not -path "*/Godeps/*" -not -path "*/elm-stuff/*" -not -path "*/deps/*" -not -path "*/_build/*" -not -path "*/target/*" -not -path "*/dist/*" -not -path "*/vendor/*" -not -path "*/bower_components/*" -not -path "*/tmp/*" -not -path "*/deploy/*" -not -path "*/distroot/*" -not -path "*/Deps/*")
    # local files=''
    # source_code files "$1"

    if [ -n "$files" ]; then
      printf "${GREEN}${1}${NC}\n"
      if [ "$2" == "total" ]; then
        local total=$(wc -l $files | grep "total")
        if [ -n "$total" ]; then
          echo $total
        else
          wc -l $files
        fi
      else
        wc -l $files
      fi
      echo
    fi

    unset IFS
  fi
}

function stats {
  local tempdir=$(mktemp -d)
  if [ -d ".git" ]; then
    gitstats . "$tempdir"
    open "$tempdir/authors.html"
  else
    printf "${RED}Not a git repo...${NC}\n"
  fi
}

function loct {
  loc "all" "total"
}

# alias deb="DEBUG=true"

# function diag {
#   echo "DIAGNOSTICS for the project: to implement"
# }

function replace {
  if [[ -z "$1" || -z "$2" || -z "$3" ]]; then
    printf "${YELLOW}Usage:${NC} replace file.txt original replacement\n"
  elif [ ! -f "$1" ]; then
    printf "${YELLOW}No such file${NC}\n"
  elif [ ! -w "$1" ]; then
    if macos; then
      printf "${YELLOW}Copy this:${NC} sudo sed -i '' \"s/${2}/${3}/g\" \"$1\"\n"
    else
      printf "${YELLOW}Copy this:${NC} sudo sed -i \"s/${2}/${3}/g\" \"$1\"\n"
    fi
  else
    if macos; then
      sed -i '' "s/${2}/${3}/g" "$1"
    else
      sed -i "s/${2}/${3}/g" "$1"
    fi
  fi
}

alias di="find . -type d"

function php {
  if [ -z "$1" ]; then
    # Interactive shell
    command php -a
  elif [ -f "$1" ]; then
    # Execute file
    command php "$1"
    echo
  elif [ -n "$1" ]; then
    # params
    command php $@
  #else
  #  echo "No such file: $1"
  fi
}

function a {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    echo "a [term] [context_lines]"
    echo "a --[lang] [term] [context_lines]"
  else
    clear && printf '\e[3J' # completely clear the terminal

    if [ -n "$2" ] && [[ $1 == *--* ]]; then
      if [ -n "$3" ]; then
        command ack "$1" -i -Q -C "$3" -- "$2"
      else
        command ack "$1" -i -Q -- "$2"
      fi
    # if [[ $@ == *--* ]]; then
    #   # ack --ruby something
    #   command ack -i -Q "$@"
    else
      # -k flag to say "Only search the files that ack recognizes the types for"
      if [ -n "$2" ]; then
        command ack -i -k -Q -C "$2" -- "$1"
      else
        command ack -i -k -Q -- "$@"
      fi
      #command ack -i -k -Q -- $@
      # there were problems with -- $Q with: ack "Refresh to" -C 3
      # look below
    fi
  fi
}

function j {
  if [ -z "$@" ]; then
    calc
  else
    awk "BEGIN{print $*}"
  fi
}

function = {
  echo "$@" | bc -l
}

# also: calc (brew install calc)

alias kk='nano ~/k.txt'

function tun {
  local config=~/.ngrok-config.yml
  if [ -z "$1" ]; then
    printf "${YELLOW}cat ${config}${NC}\n\n"
    cat "$config"
  else
    ~/Install/ngrok/bin/ngrok -config="$config" start "$1"
  fi
}

function readable {
  if [ -z "$1" ]; then
    echo "usage: readable [server]"
    echo "usage: readable ."
  elif [ "$1" == "." ]; then
    chmod -R ugo+r .
  else
    ssh "$1" "chmod -R ugo+r /var/www"
    echo "ssh"
  fi
}

function compare {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}compare dir1 dir2${NC}\n"
    printf "${GREEN}compare --size-only dir1 dir2${NC}\n"
  else
    local sizeonly=""
    if [ "$1" == "--size-only" ]; then
      sizeonly="--size-only"
      printf "${YELLOW}Sizeonly...${NC}\n"
      shift
    fi

    local params="-n -rli --delete $sizeonly"
    # -n = dry run
    #-rlptgoD
    rsync $params --exclude="._*" "$1"/ "$2"/
  fi
}

# stable project - using a git worktree feature:
# https://git-scm.com/docs/git-worktree
# so projects under ~/Projects/stable are actually a stable checkouts of projects elsewhere
function stable {
  if [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "stable . ${GRAY}checkout stable version of the project in ~/Projects/stable${NC}\n"
    printf "stable [project] ${GRAY}move to stable project${NC}\n"
  elif [ "$1" == "." ]; then
    local project="${PWD##*/}"
    local target="$HOME/Projects/stable/$project"

    if [ -d "$target" ]; then

      if [ -f ~/Projects/backups/nuke.rb ]; then
        printf "${YELLOW}${target} already exists...${NC}\n"
        #~/Projects/backups/nuke.rb "$target"
        rm -rf "$target"
      else
        printf "${RED}${target} already exists...${NC}\n"
        printf "Please execute: ${RED}rm -rf ${target}${NC} manually\n"
        return
      fi
    fi

    git worktree prune

    if git rev-parse --quiet --verify stable > /dev/null; then
      git branch -d stable
    fi

    git worktree add -b stable "$target" master

    printf "${GREEN}\nNow copying some things over (copy more manually if needed):${NC}\n"

    if [ -d data ]; then
      printf "${YELLOW}data...${NC}\n"
      cp -r data "$target/"
      printf "${GREEN}ok${NC}\n"
    fi

    if [ -d node_modules ]; then
      printf "${YELLOW}node_modules...${NC}\n"
      cp -r node_modules "$target/"
      printf "${GREEN}ok${NC}\n"
    fi

    echo
    printf "${MAGENTA}Project stabilified in ${target}${NC}\n"

  else
    awesome_cd ~/Projects/stable "$1"
  fi
}

# function ss {
#   local dir="`pwd`"
#   p "$1"
#   if [ ! "$dir" == "`pwd`" ]; then
#     subl -n .
#   fi
# }

function sn {
  local dir="`pwd`"
  n "$1"
  if [ ! "$dir" == "`pwd`" ]; then
    subl -n .
  fi
}

function pog {
  p "$1"
  og
}
#!/bin/bash

function lint {
  ~/Misc/CodeLintEslint/node_modules/eslint/bin/eslint.js "$@" -c ~/Misc/CodeLintEslint/.eslintrc.json --resolve-plugins-relative-to ~/Misc/CodeLintEslint

  # maybe implement looking for local linter first ... (probably not needed)
  # if [ ! -f ./node_modules/.bin/eslint ] || [ ! -f ./.eslintrc.json ]; then
  # ...
  # fi
}

function pretty {
  local opts=" "

  if [ "$1" == "c" ]; then
    shift
    opts="-c"
  fi

  if [ "$1" == "l" ]; then
    shift
    opts="-l"
  fi

  if [ "$1" == "write" ] || [ "$1" == "w" ]; then
    shift
    opts="--write"
  fi

  ~/Misc/CodeLintEslint/node_modules/prettier/bin-prettier.js --config ~/Misc/CodeLintEslint/prettier.config.js --plugin-search-dir ~/Misc/CodeLintEslint "$opts" "$@"
}
#!/bin/bash

function conf {

  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    echo

    printf "${GREEN}pi:${NC} sudo raspi-config\n"
    printf "${GREEN}wifi:${NC} /etc/wpa_supplicant/wpa_supplicant.conf\n"
    printf "${GREEN}dietpi:${NC} /DietPi/dietpi.txt\n"
    printf "${GREEN}net:${NC} /etc/network/interfaces\n"
    printf "${GREEN}sshd:${NC} /etc/ssh/sshd_config\n"
    printf "${GREEN}lighttpd:${NC} /etc/lighttpd/lighttpd.conf\n"
    printf "${GREEN}haproxy:${NC} /etc/haproxy/haproxy.cfg\n"
    printf "${GREEN}dnsmasq:${NC} /etc/dnsmasq.conf\n"
    printf "${GREEN}hostapd:${NC} /etc/hostapd/hostapd.conf\n"
    printf "${GREEN}alsa:${NC} /usr/share/alsa/alsa.conf\n"
    printf "${GREEN}fstab:${NC} /etc/fstab\n"
    printf "${GREEN}mpd:${NC} /etc/mpd.conf || ~/.mpdconf\n"
    printf "${GREEN}samba:${NC} /etc/samba/smb.conf\n"
    printf "${GREEN}syncthing:${NC} ~/.config/syncthing/config.xml\n"
    printf "${GREEN}munin:${NC} /etc/munin/munin.conf\n"
    printf "${GREEN}munin-node:${NC} /etc/munin/munin-node.conf\n"
    printf "${GREEN}mosquitto:${NC} /etc/mosquitto/mosquitto.conf ${GRAY}${NC}\n"

    return
  fi

  declare -a opts=(
    "pi"
    "wifi"
    "dietpi"
    "net"
    "sshd"
    "lighttpd"
    "haproxy"
    "dnsmasq"
    "hostapd"
    "ap"
    "alsa"
    "fstab"
    "mpd"
    "samba"
    "syncthing"
    "munin"
    "munin-node"
    "mosquitto"
  )

  local matching_opt=''
  opts_matcher matching_opt "$1" "${opts[@]}"
  if [ $? -ne 0 ]; then # error
    printf "${RED}Unknown package${NC}\n"
    return
  fi

  shift

  case "$matching_opt" in

    pi)
      sudo raspi-config
      ;;

    wifi)
      wifi_setup "from_conf" "$@"
      ;;

    dietpi)
      sudo nano /DietPi/dietpi.txt
      ;;

    net)
      local conf="/etc/network/interfaces"

      if [ -f "${conf}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf}${NC}\n"
        sudo nano "${conf}"
      else
        printf "${RED}no networking config file found${NC}\n"
        return
      fi
      ;;

    sshd)
      local conf="/etc/ssh/sshd_config"

      if [ -f "${conf}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf}${NC}\n"
        sudo nano "${conf}"
      else
        printf "${RED}no sshd config file found${NC}\n"
        return
      fi
      ;;

    lighttpd)
      local conf="/etc/lighttpd/lighttpd.conf"

      if [ -f "${conf}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf}${NC}\n"
        sudo nano "${conf}"
      else
        printf "${RED}no lighttpd config file found${NC}\n"
        return
      fi
      ;;

    haproxy)
      local conf="/etc/haproxy/haproxy.cfg"

      if [ -f "${conf}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf}${NC}\n"
        sudo nano "${conf}"
      else
        printf "${RED}no haproxy config file found${NC}\n"
        return
      fi
      ;;

    dnsmasq)
      local conf="/etc/dnsmasq.conf"

      if [ -f "${conf}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf}${NC}\n"
        sudo nano "${conf}"
      else
        printf "${RED}no dnsmasq config file found${NC}\n"
        return
      fi
      ;;

    hostapd)
      printf "${YELLOW}Please use ${GREEN}conf ap${NC}\n"
      ;;

    ap)
      local conf="/etc/hostapd/hostapd.conf"

      if [ -f "${conf}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf}${NC}\n"
        sudo nano "${conf}"
      else
        printf "${RED}no hostapd config file found${NC}\n"
        return
      fi
      ;;

    alsa)
      local conf="/usr/share/alsa/alsa.conf"

      if [ -f "${conf}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf}${NC}\n"
        sudo nano "${conf}"
      else
        printf "${RED}no alsa config file found${NC}\n"
        return
      fi
      ;;

    fstab)
      local conf="/etc/fstab"

      if [ -f "${conf}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf}${NC}\n"
        sudo nano "${conf}"
      else
        printf "${RED}no fstab config file found${NC}\n"
        return
      fi
      ;;

    mpd)
      local conf="/etc/mpd.conf"
      local conf2="$HOME/.mpdconf"

      if [ -f "${conf}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf}${NC}\n"
        sudo nano "${conf}"
      elif [ -f "${conf2}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf2}${NC}\n"
        nano "${conf2}"
      else
        printf "${RED}no mpd config file found${NC}\n"
        return
      fi
      ;;

    samba)
      local conf="/etc/samba/smb.conf"

      if [ -f "${conf}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf}${NC}\n"
        sudo nano "${conf}"
      else
        printf "${RED}no samba config file found${NC}\n"
      fi
      ;;

    syncthing)
      local conf="$HOME/.config/syncthing/config.xml"
      local conf2="$HOME/Library/Application Support/Syncthing/config.xml"

      if [ -f "${conf}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf}${NC}\n"
        nano "${conf}"
      elif [ -f "${conf2}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf2}${NC}\n"
        nano "${conf2}"
      else
        printf "${RED}no syncthing config file found${NC}\n"
      fi
      ;;

    munin)
      local conf="/etc/munin/munin.conf"

      if [ -f "${conf}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf}${NC}\n"
        sudo nano "${conf}"
      else
        printf "${RED}no munin config file found${NC}\n"
      fi
      ;;

    munin-node)
      local conf="/etc/munin/munin-node.conf"

      if [ -f "${conf}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf}${NC}\n"
        sudo nano "${conf}"
      else
        printf "${RED}no munin-node config file found${NC}\n"
      fi
      ;;

    mosquitto)
      local conf="/etc/mosquitto/mosquitto.conf"

      if [ -f "${conf}" ]; then
        printf "${CYAN}Editing ${YELLOW}${conf}${NC}\n"
        sudo nano "${conf}"
      else
        printf "${RED}no mosquitto config file found${NC}\n"
      fi
      ;;

  esac
}

function wifi_setup {
  local conf="/etc/wpa_supplicant/wpa_supplicant.conf"

  local instr="wifi_setup"
  if [ "$1" == "from_conf" ]; then
    instr="conf wifi"
    shift
  fi

  if [ -f "${conf}" ]; then
    if [ -n "$1" ]; then
      wpa_passphrase "$@"
      return
    fi

    sudo nano "${conf}"
    printf "${MAGENTA}Never provide password in cleartext.\n${YELLOW}Use ${GREEN}${instr} [SSID]${NC} to generate encrypted password\n"
  else
    printf "${conf} ${RED}not found${NC}\n"
    return
  fi
}


function slog {

  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    echo

    printf "${GREEN}lighttpd|light: ${GRAY}/var/log/lighttpd/error.log${NC} \n"
    printf "${GREEN}haproxy: ${GRAY}root; tail -f /var/log/haproxy.log${NC}\n"
    # printf "${GREEN}sshd:${NC} /etc/ssh/sshd_config\n"
    # printf "${GREEN}alsa:${NC} /usr/share/alsa/alsa.conf\n"
    printf "${GREEN}mpd:${NC} /var/log/mpd/mpd.log\n"
    # printf "${GREEN}samba:${NC} /etc/samba/smb.conf\n"
    printf "${GREEN}mosquitto:${NC} /var/log/mosquitto/mosquitto.log ${GRAY}${NC}\n"

    return
  fi

  declare -a opts=(
    "dmt"
    "mpd"
    "lighttpd"
    "haproxy"
    "munin"
    "munin-node"
    "mosquitto"
  )

  local matching_opt=''
  opts_matcher matching_opt "$1" "${opts[@]}"
  if [ $? -ne 0 ]; then # error
    return
  fi

  shift

  case "$matching_opt" in
    dmt)
      dmt_log "$@"
      ;;

    mpd)
      tail -f /var/log/mpd/mpd.log
      ;;

    lighttpd)

      local conf="/etc/lighttpd/lighttpd.conf"

      if [ -f "${conf}" ]; then
        tail -f /var/log/lighttpd/error.log
      else
        printf "${RED}no lighttpd found${NC}\n"
        return
      fi

      ;;

    haproxy)

      local conf="/etc/haproxy/haproxy.cfg"

      if [ -f "${conf}" ]; then
        printf "Execute: ${MAGENTA}root; tail -f /var/log/haproxy.log${NC}\n"
      else
        printf "${RED}no haproxy found${NC}\n"
        return
      fi

      ;;

    mosquitto)

      local log="/var/log/mosquitto/mosquitto.log"

      if [ -f "${log}" ]; then
        printf "tail -f ${YELLOW}${log}${NC}\n"
        tail -f "$log"
      else
        printf "${RED}log not found${NC}\n"
      fi

      ;;

    munin)

      local log="/var/log/munin/munin-update.log"

      if [ -f "${log}" ]; then
        printf "tail -f ${YELLOW}${log}${NC}\n"
        tail -f "$log"
      else
        printf "${RED}log not found${NC}\n"
      fi

      ;;

    munin-node)

      local log="/var/log/munin/munin-node.log"

      if [ -f "${log}" ]; then
        printf "tail -f ${YELLOW}${log}${NC}\n"
        tail -f "$log"
      else
        printf "${RED}log not found${NC}\n"
      fi

      ;;

  esac
}
#!/bin/bash

############### Ports and Processes

# what is listening on port
function port {

  if [ "$1" == "-h" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}port${NC} ${GRAY}list all open ports${NC}\n"
    printf "${GREEN}port [num]${NC} ${GRAY}show the process that uses port [num]${NC}\n"
    printf "${GREEN}port [proc]${NC} ${GRAY}list all open ports held by specified process grep string${NC}\n"
    return
  fi

  if [[ "$1" =~ ^[0-9]+$ ]]; then
    lsof -i :$1
  elif [ -n "$1" ]; then
    if macos; then
      sudo lsof -i | grep "$1"
    else
      netstat -l -p | grep "$1"
    fi
  else
    if macos; then
      sudo lsof -i
    else
      netstat -l -p
    fi
  fi
}

function killport {
  port $1 | awk '{print $2}' | xargs kill -9
}

function proc {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}proc [process]${NC} ${GRAY}search all processes that match the term${NC}\n"
    return
  fi

  ps aux | grep -v "command -v openssl >/dev/null" | grep -v " grep " | grep -i --color=auto "$@"
  # grep -v "command -v openssl >/dev/null" ==> get rid of really big output when using over ssh, this process output includes big public key which often matches our grepping stuff
}

function killall {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}killall [term]${NC} ${GRAY}kills *all processes* matching the search term${NC}\n"
    return
  fi

  local proc=$(ps -ef | grep "${1}" | grep -v "command -v openssl >/dev/null" | grep -v grep | awk '{print $2}')

  if [ -n "$proc" ]; then
    echo "$proc" | xargs kill -9
    printf "${CYAN}Killed process ${proc}${NC}\n"
  else
    printf "${GRAY}No such process: ${1}${NC}\n"
  fi
  # grep -v "command -v openssl >/dev/null" ==> get rid of really big output when using over ssh, this process output includes big public key which often matches our grepping stuff
}

function port2 {
  lsof -n -i4UDP:$1
}

# list all the executable files in folder
function exe {
  if macos; then
    find . -type f -perm +111 -print
  else
    find . -type f -executable -print
  fi
}

function sr {
  if [ -z "$1" ]; then
    screen -r
  else
    screen -D "$1" > /dev/null 2>&1
    screen -r "$1"
  fi
}

function ss {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}ss [screen]${NC}\n"
  else
    screen -S "$1"
  fi
}

# se - "Screen execute"
# executes commands (separated by comma) in background screen
function se {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
      printf "${GREEN}se [cmd]${NC} ${GRAY}executes command in background screen which exits when command finishes${NC}\n"
      printf "${GREEN}se [cmd1], [cmd2], [cmd3]${NC} ${GRAY}executes multiple commands in background screen - must use comma and not semicolon!${NC}\n"
      printf "${GREEN}se -n [screen_name] [cmd]${NC} ${GRAY}executes command in a named screen which *doesn't* exit when command finishes${NC}\n"
      printf "${GREEN}se [cmd], p${NC} ${GRAY}sends push notification to mobile phone when command finishes${NC}\n"
      printf "${GREEN}se -n [screen_name] [cmd], p${NC} ${GRAY}same as above only in named screen which remains when command(s) finish${NC}\n"
  else
    if [ "$1" == '-n' ]; then
      local name="$2"
      local msg="$(hostname): <$name> finished."
      shift
      shift
    fi

    if [[ "$1" =~ ^[0-9]+ ]] ; then
      local delay="$1"
      shift
    fi

    local cmd=$(echo "$@" | sed 's/,/;/g')

    if [ -n "$delay" ]; then
      cmd="timer $delay; $cmd"
    fi

    cmd=$(echo "$cmd" | sed 's/; p$/;p/')

    if [[ "$cmd" =~ ";p"$ ]]; then
      cmd=$(echo "$cmd" | sed 's/;p$//')
      if [ -z "$msg" ]; then
        local msg="$(hostname): <${cmd}> finished."
      fi
      cmd="${cmd}; push_notify \"${msg}\""
    fi

    if [ -n "$name" ]; then
      cmd="${cmd}; exec bash"
    fi

    printf "${GREEN}Executing in background screen:\n${YELLOW}${cmd}${NC}\n"

    cmd="if [ -f ~/.bash_aliases ]; then . ~/.bash_aliases; fi; ${cmd}"

    if [ -z "$name" ]; then
      local name="dmt_task"
    fi

    screen -S "$name" -dm bash -c "$cmd"
  fi
}

function killport {
  port $1 | awk '{ print $2 }' | xargs kill -9
}


alias dup="docker-compose up -d"

function dc {
  docker container $@
}

#
#!/bin/bash

#######
# git #
#######
#alias gx="gitx"
alias _good="git bisect good"
alias _bad="git bisect bad"

function good {
  if [[ $@ == *--* ]]; then
    command good "$@";
  else
    echo "Last week stats:"
    echo
    command good --email=david.krmpotic@gmail.com --days=7;
  fi
}


alias gsu="git submodule update --init"
alias gst="git stash"
alias gsa="git stash apply"
alias gl='git pull'
#alias gp='git push'
#alias gpm='git push origin master'
#alias fpm='git push origin +master'
alias ga='git add'
alias gba='git branch -v -a'
alias glf="git fetch && git reset --hard origin/master"
alias glast="git show HEAD"

function latest_tag {
  local latest_tag=$(git describe --tags `git rev-list --tags --max-count=1`)
  git checkout $latest_tag
}

function gp {
  local branch=$(git rev-parse --abbrev-ref HEAD)
  git push origin $branch
}

function fp {
  local branch=$(git rev-parse --abbrev-ref HEAD)
  git push origin +$branch
  # if [ "$branch" == "master" ]; then
  # else
  #   printf "${RED}Not on master${NC}\n"
  # fi
}

function af {
  aa
  fp
  # local branch=$(git rev-parse --abbrev-ref HEAD)
  # if [ "$branch" == "master" ]; then
  #   aa
  #   git push origin +master
  # else
  #   printf "${RED}Not on master${NC}\n"
  # fi
}

alias afd="aa && fp && dep"

function gb {
  if [ -z "$1" ]; then
    git branch -v
  else
    git diff master "origin/${1}" --name-status
  fi
}

function gd {
  if [ -n "$1" ]; then
    run_on_file "$1" "git diff" '*'
  else
    git diff
  fi
}

alias clean='echo -n "Really clean this directory?";
  read yorn;
  if test "$yorn" = "y"; then
     rm -f \#* *~ .*~ *.bak .*.bak  *.tmp .*.tmp core a.out;
     echo "Cleaned.";
  else
     echo "Not cleaned.";
  fi'


alias clone="git clone"

function cclone {
  local tmp
  if macos; then
    tmp=$(mktemp -t git)
  else
    tmp=$(mktemp)
  fi

  local repo_name

  git clone "$@" --progress 2>&1 | tee $tmp
  repo_name=$(awk -F\' '/Cloning into/ {print $2}' $tmp)
  rm $tmp
  cd "$repo_name"
}

function amend {
  if [ -n "$1" ]; then
    git add "$1"
  fi
  git commit --amend --no-edit
}

alias am=amend

function depa {
  read -r -p "Amend all and deploy. Sure? [Y/n] " response
  if [[ ! $response =~ ^([nN])$ ]]
  then
    git add .
    git commit --amend --no-edit
    echo
    dep
  fi
}

alias share_git='git update-server-info & ruby -run -e httpd -- -p 5000 .git'

function pick {
  if [ -n "$1" ]; then
    git cherry-pick "$1"
  else
    git cherry-pick @{-1}
  fi
}

function changed {
  if ! $(git rev-parse --is-inside-work-tree > /dev/null 2>&1); then
    >&2 printf "${RED}Not a git repository${NC}\n"
    return 1
  fi

  local branch=$(git rev-parse --abbrev-ref HEAD)

  if [ "$1" == "help" ]; then
    echo "Usage:"
    printf "${YELLOW}changed${NC} - changes summary since the last pull\n"
    printf "${YELLOW}changed .${NC} - changes since the last pull\n"
    printf "${YELLOW}changed path/file${NC} - same as above, just for file\n"
    printf "${YELLOW}changed HEAD~10..HEAD${NC} - changes between two commits\n"
    printf "${YELLOW}changed [sha (previous!)]..HEAD${NC} - similar\n"
  elif [ -z "$1" ]; then
    git diff --stat $branch@{1} $branch
  elif [ "$1" == '.' ]; then
    git diff $branch@{1} $branch # all changes
  elif [ "$1" == 'local' ]; then
    git log @{push}.. # stuff that would get pushed with "git push"
  else
    grep -qv "\.\." <<< $1
    if [ ! $? -eq 0 ]; then
      git diff --pretty="format:" --name-only "$1" #| sort | uniq | awk "{print $url $0}"
    else
      local matching_file=''
      get_matching_file matching_file "$1"
      matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

      if [ ! -f "$matching_file" ]; then
        return
      fi

      printf "${YELLOW}git diff ${branch}@{1} ${branch} ${matching_file}${NC}\n"

      git diff $branch@{1} $branch "$matching_file"
    fi
  fi
}

# http://pastebin.com/k8WryYxM
# ----------------------------

function git_repo {
  local root=$(git rev-parse --show-toplevel || echo ".")
  local cwd="`pwd`"
  cd $root
  local origin=$(git remote -v | grep origin | grep push | sed 's/origin//g' | sed 's/git@github.com://g' | sed 's/https:\/\/github.com\///g' | sed 's/.git (push)//g' | sed 's/ (push)//g' | xargs)
  cd $cwd
  eval "$1=$origin"
}

# Opens Github project in browser from command line
# og - opens current branch
# og [branch] - opens selected branch
# og copy - copies to clipboard
# og commits - opens commits tab
# by davidhq
function og {
  if ! $(git rev-parse --is-inside-work-tree > /dev/null 2>&1); then
    >&2 printf "${RED}Not a git repository${NC}\n"
    return 1
  fi

  local repo=''
  git_repo repo

  local origin="https://github.com/${repo}"
  local branch=$(git rev-parse --abbrev-ref HEAD)

  if [ "$1" == 'copy' ]; then
    # copy to clipboard
    printf "${YELLOW}Copied: ${NC}${origin}\n"
    echo $origin | tr -d '\n' | pbcopy # chomp before copy
  elif [ "$1" == 'commits' ]; then
    # open commits tab
    open "${origin}/commits/${branch}"
  elif [ "$1" == 'npm' ]; then
    # open commits tab
    open "https://www.npmjs.com/package/$(name)"
  elif [ -n "$1" ]; then
    open "${origin}/tree/${1}"
  elif [ "$branch" != "master" ]; then
    open "${origin}/tree/${branch}"
  else
    open $origin
  fi
}

alias ogc="og copy"

# Usage inside a git repository:
# gc utils/file.js
# to get:
# https://github.com/[user]/[repo]/blob/[branch]/utils/file.js
# copied to clipboard and printed on the command line (you can use newest iTerm2 to being able to click on urls from terminal with CMD+click)
function gc {
  if ! $(git rev-parse --is-inside-work-tree > /dev/null 2>&1); then
    >&2 printf "${RED}Not a git repository${NC}\n"
    return 1
  fi

  local repo=''
  git_repo repo

  if [ -z "$1" ]; then
    echo "Usage: gc folder/file.txt"
    echo "copied github url to clipboard"
    local repo=''
    git_repo repo
    local origin="https://github.com/${repo}"
    echo $origin | tr -d '\n' | pbcopy # chomp before copy
  else
    local matching_file=''
    get_matching_file matching_file "$1"
    matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

    if [ ! -f "$matching_file" ]; then
      return
    fi

    local repo_root=$(git rev-parse --show-toplevel || echo ".")
    local file_path=$(readlink -f "$matching_file" | tr -d '\n')

    local branch=$(git rev-parse --abbrev-ref HEAD)
    local url_cluttered="https://github.com/${repo}/blob/${branch}/${file_path}"
    local url=$(echo $url_cluttered  | sed "s#${repo_root}/##")

    echo $url | tr -d '\n' | pbcopy
    printf "Clipboard: ${YELLOW}$url${NC}\n"
  fi
}

# ----------------------------

function log {
  if [ -n "$1" ]; then
    slog "$1"
    return
  fi

  if [ -d ".git" ]; then
    clear
    git log -5
    # if [ -z "$1" ]; then
    #   git log -3
    # else
    #   git log -"$1"
    # fi
  else
    printf "${RED}Not a git repository${NC}\n"
  fi
}

# open app log
function lg {
  if [ -f ".log" ]; then
    `cat .log`
  else
    if [ -z "$1" ]; then
      if macos; then
        if [ -f 'log/development.log' ]; then
          tail -n 20 -f log/development.log
        elif [ -f 'log/error.log' ]; then
          tail -n 20 -f log/error.log
        else
          puts "No log files"
        fi
      else
        if [ -f 'log/production.log' ]; then
          tail -n 20 -f log/production.log
        elif [ -f 'log/nginx.access.log' ]; then
          tail -n 20 -f log/nginx.access.log
        else
          puts "No log files"
        fi
      fi
    else
      if [ "$1" == "apache" ]; then
        tail -n 20 -f /var/log/apache2/error_log
      elif [ "$1" == "nginx" ]; then
        tail -n 20 -f /var/log/nginx/error.log
      # else # lg th mak
      #   local parserScript=~/Projects/scripts/ssh_parse_host
      #   if [ ! -f "$parserScript" ] && [ -f /var/projects/scripts/ssh_parse_host ]; then
      #     parserScript="/var/projects/scripts/ssh_parse_host"
      #   fi
      #   local server=$("$parserScript" "$1")
      #   ssh "$server" "if [ -d /var/www/${2}/current/log ]; then tail -n 20 -f /var/www/${2}/current/log/production.log; elif [ -f /var/www/${2}/log/nginx.access.log ]; then tail -n 20 -f /var/www/${2}/log/nginx.access.log; else tail -n 20 -f /var/www/${2}/log/production.log; fi"
      fi
    fi
  fi
}

function com {
  if [ "$1" == "-m" ]; then
    shift
  fi
  git commit -m "$@"
}

function coma {
  if [ "$1" == "-m" ]; then
    shift
  fi
  git add .
  git add . -u
  git commit -m "$@"
}

function comv {
  git add .
  git commit -v
}

function add {
  if [ -n "$1" ]; then
    run_on_file "$1" "git add" '*'
  else
    git add -p
  fi
}

function addp {
  if [ -n "$1" ]; then
    run_on_file "$1" "git add -p" '*'
  else
    git add -p
  fi
}

alias rh='git reset HEAD'
alias open_last_commit="git reset --soft HEAD^1"
alias last_commit=open_last_commit

#alias gp_amend="git add . && git commit --amend && fp"
alias cdr='cd $(git rev-parse --show-toplevel || echo ".")'

function gco {
  if [ -z "$1" ]; then
    git checkout master
  else
    git checkout $1
  fi
}

function st {
  if [ -d ".svn" ]; then
    svn status
  else
    git status
  fi
}

# function reb {
#    git rebase -i HEAD~"$1"
# }

alias i5='git commit -m "moo" && git stash && git rebase -i HEAD~5 && git stash apply'
alias i10='git commit -m "moo" && git stash && git rebase -i HEAD~10 && git stash apply'

# http://openmonkey.com/articles/2009/07/fast-github-clone-bash-function
function ghclone {
  gh_url=${1:-`pbpaste`}
  co_dir=${HOME}/Projects/source/$(echo $gh_url | sed -e 's/^git:\/\/github.com\///; s/\//-/; s/\.git$//')

  if [ -d $co_dir ]; then
    cd $co_dir && git pull origin master
  else
    git clone "${gh_url}" "${co_dir}" && cd "${co_dir}"
  fi
}

function aa {
  #read -r -p "Amend ALL to last commit? [Y/n] " response
  #if [[ ! $response =~ ^([nN])$ ]]
  #then
    git add .
    git commit --amend --no-edit
  #fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~ 💡🚀🎸 FULL EDITION ~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#!/bin/bash

function make_index {
  node "$DMT_NODE_CORE/dmt-index/index.js" "$@"
}

# can also do:
# [some long process_with_text_result] | push_notify
# in background: se "space|push_notify"
function push_notify {
  local push_notifier="$DMT_NODE_CORE/dmt-notify/lib/apn.js"

  if [ -f "$push_notifier" ]; then
    # if stdin is passed to nodejs script (happens automatically),
    # it is considered as a message, given argument is ignored
    if [ -z "$1" ]; then
      node "$push_notifier"
    else
      node "$push_notifier" "$1"
    fi
  else
    printf "${RED}Cannot push message${NC}\n"
  fi
}

function magic {
  node "$DMT_NODE_CORE/magic-window/index.js" "$@"
}

function net_scan {
  local cmd="${DMT_NODE_CORE}/dmt-net/index.js"

  if [ -f "$cmd" ]; then
    node "$cmd" "$@"
  else
    printf "${RED}dmt-net package not installed, please install${NC}\n"
  fi
}
#!/bin/bash

function npm_unlink {
  if [ -z "$1" ]; then
    echo "Usage: npm_unlink [package]"
  else
    ~/Projects/scripts/npm_executables "$1" "unlink"
    local dir="/usr/local/lib/node_modules/${1}"
    if [ -d "$dir" ] || [ -L "$dir" ]; then
      rm -rf "$dir"
      if [ "$2" != 'silent' ]; then
        printf "${YELLOW}Unlinked ${1}${NC}\n"
      fi
    else
      if [ "$2" != 'silent' ]; then
        printf "${YELLOW}${1} already unlinked${NC}\n"
      fi
    fi
  fi
}

function nig {

  npm install -g "$@"

  # if this package is already installed in ~/Install/npm, we install the new version there as well so it can be switched to with "stable"
  # local install_dir="${HOME}/Install/npm/${1}"
  # if [ -d "$install_dir" ]; then
  #   printf "${MAGENTA}Package <$1> exists in ~/Install/npm, installing new version there as well...${NC}\n"
  #   npm_install_global_special "$1"
  # else
  #   npm install -g "$1"
  #   lib --path "/usr/local/lib/node_modules/$1"
  # fi
}

alias reset_npm="rm -rf node_modules; npm cache clean; npm install"

# can also run "npm version" to get V8 version and other things
function ver {
  if [ -f "./package.json" ]; then
    printf "${YELLOW}Version in package.json:${NC}\n"
    cat package.json | grep version |

    printf "${YELLOW}Published version:${NC}\n"
    printf " "
    npm view . version
  fi
}

function ver2 {
  printf "${YELLOW}ver pub${NC}\n"
  ver pub
}

function forever_executable {
  local loc1="$DMT_NODE_CORE/.common-deps/node_modules/forever/bin/forever"
  local loc2="$HOME/n/bin/forever"
  local loc3="/usr/local/bin/forever"

  local _result=''

  if [ -f "$loc1" ]; then
    _result="$loc1"
  elif [ -f "$loc2" ]; then
    _result="$loc2"
  elif [ -f "$loc3" ]; then
    _result="$loc3"
  else
    printf "${RED}npm package forever not found${NC}\n"
  fi

  eval "$1='$_result'"
}

function forever {
  local forever_cmd
  forever_executable forever_cmd

  if [ -n "$forever_cmd" ]; then
    "$forever_cmd" "$@"
  fi
}

function fs {
  local forever_cmd
  forever_executable forever_cmd

  if [ -n "$forever_cmd" ]; then
    if [ -z "$1" ] && [ -f "forever/production.json" ]; then
      printf "${YELLOW}forever start index.js${NC}\n"
      NODE_ENV=production "$forever_cmd" start forever/production.json
    else
      run_on_file "$1" "$forever_cmd start" '*.js' force
    fi
  fi
}

function fl {
  local forever_cmd
  forever_executable forever_cmd
  if [ -n "$forever_cmd" ]; then
    "$forever_cmd" list
  fi
}

function fr {
  local forever_cmd
  forever_executable forever_cmd
  if [ -n "$forever_cmd" ]; then
    "$forever_cmd" restartall
  fi
}
#!/bin/bash

function rpc {
  if [ -z "$1" ]; then
    echo "Usage:"
    echo "rpc '{\"jsonrpc\":\"2.0\",\"method\":\"web3_clientVersion\",\"params\":[],\"id\":232367}'"
  else
    curl -X POST --data "$1" http://localhost:8545
  fi
}

function y {
  declare -a topics=(
    "diagnostics"
    "doorbell"
    "lantern"
    "alarm"
    "house"
  )

  local matching_topic=''
  opts_matcher matching_topic "$1" "${topics[@]}"
  if [ $? -ne 0 ]; then # error
    printf "${RED}Unknown mqtt topic $1${NC}\n"
    return
  fi

  shift
  local msg="$1"
  if [ -n "$msg" ]; then
    printf "${GREEN}Publish: ${NC}$matching_topic ■ $msg\n"
    pub "$matching_topic" "$msg"
  else
    printf "${RED}Missing message for ${MAGENTA}${matching_topic} ...${NC}\n"
  fi
}

function get_ssid {
  if macos; then
    local __ssid="$(/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -I | awk '/ SSID/ {print substr($0, index($0, $2))}')"
  else
    local __ssid="$(iwgetid -r)"
  fi
  eval "$1='${__ssid}'"
}

# 70:0f:57:12:01:b7 --> 70:f:57:12:1:b7
function normalize_mac {
  local cmd="sed"
  if macos; then
    cmd="gsed"
  fi
  local __mac=$(echo "$2" | tr '[:upper:]' '[:lower:]' | $cmd -r -e 's/\b0([0-9]|[a-f])/\1/g')
  eval "$1='${__mac}'"
}

# https://stackoverflow.com/questions/14600466/how-to-ping-mac-address-in-linux
function mac_ping {

  if [ -z "$1" ]; then
    printf "${RED}Must specify mac address${NC}\n"
    return
  fi

  local network=192.168.0.1/24
  #if [ "$#" -ne 1 ]; then echo Usage example: $0 aa:bb:cc:dd:ee:ff; exit 2; fi;
  nmap -sP -T4 $network >& /dev/null

  if macos; then
    local ip=$(arp -n | grep -i $1 | awk ' { print $1 }')
  else
    local ip=$(ip -4 n show | grep -i $1 | awk ' { print $1 }')
  fi

  ping $ip -n -q -c 2 -i 0.2 -w 1 >& /dev/null

  if [ $? -eq 0 ]; then
      echo Device is online \($ip\)
  else
      echo Device is offline
      exit 1
  fi;
}

# for debugging purposes for now!!
function gateway_ip {
  ip -4 route list | head -1 | cut -d' ' -f3
}

function gateway_mac {
  local _gatewayMac=''
  get_gateway_mac _gatewayMac

  printf "${YELLOW}$_gatewayMac${NC}\n"
}
# ---- for debugging purposes for now!!

function get_mac {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}get_mac [ip]${NC} ${GRAY}${NC}\n"
    return
  fi

  local ip="$2"

  ping -c 1 "$ip" > /dev/null

  local __mac=$(ip neigh | grep "${ip} " | grep "[0-9a-f]:" | head -1 | cut -d' ' -f5) #| tr '[A-F]' '[a-f]')
  # | grep "REACHABLE"

  #printf "${GREEN}MAC: ${NC}$mac\n"

  local __normalized_mac=''
  normalize_mac __normalized_mac "$__mac"

  eval "$1='$__normalized_mac'"
}

#todo: implement without using "ip" on mac.. if not possible, then document this homebrew dep....
# gateway ip on mac: route -n get default
#local gateway_ip=$(ip -4 route list | head -1 | cut -d' ' -f3)
#local mac=$(ip neigh | grep "${gateway_ip} " | grep "[0-9a-f]:" | cut -d' ' -f5 | head -1) #| tr '[A-F]' '[a-f]')
#local mac=$(ip neigh | grep "$(ip -4 route list 0/0 | head -1 | cut -d' ' -f3) " | cut -d' ' -f5 | head -1)
# on mac: do arp -a
#
# https://askubuntu.com/questions/605306/how-do-i-get-the-mac-address-of-my-router

function get_gateway_mac {
  # todo: ping once ? probably useful....... but for now there were no problems
  local gateway_ip=$(ip -4 route list | head -1 | cut -d' ' -f3)
  if [[ "$gateway_ip" =~ [0-9]\. ]]; then # we can also get "wlan0" if working as access point
    local _normalized_mac=''
    get_mac _normalized_mac "$gateway_ip"
    eval "$1='$_normalized_mac'"
  fi
  #printf "${GREEN}Normalized: ${NC}$normalized_mac\n"
}

function net {
  if [ "$1" == "-h" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}net scan${NC} ${GRAY}todo${NC}\n"
    printf "${GREEN}net send${NC} ${GRAY}todo${NC}\n"
    printf "${GREEN}net receive${NC} ${GRAY}todo${NC}\n"
    return
  fi

  # default is scan
  if [ -z "$1" ]; then
    net_scan "$@"
    return
  fi

  # check for prerequisite - netcat
  if [ "$1" == "send" ] || [ "$1" == "receive" ]; then
    which nc > /dev/null 2>&1

    if [ $? -ne 0 ]; then
      if macos; then
        printf "${RED}netcat is not installed, please install and try again${NC}\n"
        return
      else
        printf "${MAGENTA}netcat is missing, installing...${NC}\n"
        sudo apt-get -y install netcat
      fi
    fi
  fi

  case "$1" in
    scan )
      net_scan "$@"
      ;;

    receive )
      if macos; then
        printf "${RED}Receive not working on macos - (todo)${NC}\n"
        #nc -l localhost 1238 | tar xv
      else
        printf "${GREEN}IP:${NC}\n"
        myip
        printf "${GREEN}Waiting to receive in ${YELLOW}$(pwd)${GREEN} ...${NC}\n"
        nc -q 1 -l -p 1238 | tar xv
      fi
      ;;

    send )
      if [ -z "$2" ]; then
        printf "${RED}Host missing, please specify host: ${GREEN}net send [host]${NC}\n"
        return
      fi

      local host="$2"

      if [ "$host" == "ap" ]; then
        host="192.168.1.1"
      fi

      printf "${MAGENTA}Sending to ${GREEN}${2}${MAGENTA} ...${NC}\n"
      if macos; then
        tar cv . | nc "$host" 1238
      else
        tar cv . | nc -q 1 "$host" 1238
      fi
      ;;

    *)
      net_scan "$@"
      ;;
  esac
}

function get_current_device {
  local __device_id=''

  if [ -f "$DMT_DEVICE_FILE" ]; then
    def_reader __device_id "$DMT_DEVICE_FILE" "device"
  fi

  eval "$1='$__device_id'"
}

function get_current_network {
  local __network_id=''

  # try explicitly defined networkId inside device.def first:
  if [ -f "$DMT_DEVICE_FILE" ]; then
    def_reader __network_id "$DMT_DEVICE_FILE" "network"
  fi

  # otherwise detect the current network via gatewayMac address:
  if [ -z "$__network_id" ]; then
    local _result=''
    network_def_reader _result __network_id "host"
  fi

  eval "$1='$__network_id'"
}

# known (but not critical) shortcomings:
# location: home
#   gatewayMac: 22:38:e4:cc:f7:80
#   mpdPlayer:
#     host: player.local
#
# gatewayMac has to appear above host: .....
# otherwise parser won't be able to match it correctly since it scans from top to bottom
function network_def_reader {
  local entry="$3"

  local _gatewayMac=''
  get_gateway_mac _gatewayMac

  if [ -z "$_gatewayMac" ]; then
    #printf "${RED}Cannot get gateway mac address${NC}\n\n"
    return
  fi

  local gateway_matched=false

  local DMT_NETWORKS_FILE="$DMT_PATH/user/def/networks.def"

  IFS=$'\n' read -d '' -r -a lines < "$DMT_NETWORKS_FILE"

  local _result=''
  local _network=''

  IFS=$'\n'

  for line in ${lines[@]}; do
    unset IFS

    line=$(echo "${line}" | xargs) # trim whitespace

    # Handle comments

    if [[ $line =~ ^\s*"#" ]]; then # comment is a whole line, ignore
      continue
    fi

    # if not, ignore after # character

    local fillInToken="%@@%" # string that is unlikely to occur

    line=$(echo "$line" | sed "s/ /${fillInToken}/g")
    local arr=(${line/\#/ }) # split on \#
    line=$(echo ${arr[0]} | sed "s/${fillInToken}/ /g")

    # ---- end comment handing

    if [[ $line =~ ^network\: ]]; then
      local arr=($(echo $line | sed "s/network:/network@/" | tr "@" "\n")) # replace ":" with "@" because ":" appears all over mac address defined in gatewayMac
      local current_network=$(echo "${arr[@]:1}" | xargs) # trim whitespace
    fi

    if [[ $line =~ ^gatewayMac\: ]]; then
      local arr=($(echo $line | sed "s/gatewayMac:/gatewayMac@/" | tr "@" "\n")) # replace ":" with "@" because ":" appears all over mac address defined in gatewayMac
      local gatewayMac=$(echo "${arr[@]:1}" | xargs) # trim whitespace

      local normalized_mac=''
      normalize_mac normalized_mac "$gatewayMac"

      if [ "$normalized_mac" == "$_gatewayMac" ]; then
        gateway_matched=true
        _network="$current_network"
      fi
    elif [[ $line =~ ^$entry\: ]] && $gateway_matched; then
      local arr=($(echo "$line" | tr ":" "\n"))
      _result=$(echo "${arr[@]:1}" | xargs) # trim whitespace
    elif [[ $line =~ ^network\: ]]; then
      gateway_matched=false # we reset the match on next record
    fi
  done

  eval "$1='$_result'"
  eval "$2='$_network'"
}
#!/bin/bash

function build_essential {
  sudo apt-get update
  sudo apt-get -y install build-essential tar unzip curl git screen ntp zip tree lsof colordiff rsync
}

function build_essential_full {
  sudo apt-get update
  sudo apt-get -y install build-essential zlib1g-dev libpcre3 libpcre3-dev libbz2-dev libssl-dev libreadline-dev tar unzip curl git screen dh-autoreconf make pkg-config cmake lsof ntp highlight net-tools zip tree lsof colordiff rsync
}

function gpio {

  declare -a opts=(
    "export"
    "read"
    "write"
  )

  if [ -z "$1" ] || [ "$1" == "-h" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}gpio export [pin] [in|*out]${NC} ${GRAY}${NC}\n"
    printf "${GREEN}gpio read [pin]${NC} ${GRAY}read from pin${NC}\n"
    printf "${GREEN}gpio write [pin] [val]${NC} ${GRAY}write value to pin${NC}\n"
    return
  fi

  local matching_opt=''
  opts_matcher matching_opt "$1" "${opts[@]}"
  if [ $? -ne 0 ]; then # error
    printf "Use -h to see valid options\n\n"
    return
  fi

  shift

  case "$matching_opt" in

    export)
      local pin="$1"
      local direction="$2"
      if [ -z "$direction" ]; then
        direction="out"
      fi

      printf "${GRAY}Node: there might be some ephemereal errors, not sure why, in that case try again ...:${NC}\n\n"

      sudo echo "$pin" > /sys/class/gpio/unexport
      sudo echo "$pin" > /sys/class/gpio/export

      sudo echo "$direction" > "/sys/class/gpio/gpio${pin}/direction"

      printf "Exported pin ${YELLOW}${pin}${NC}, direction: ${MAGENTA}${direction}${NC}\n"
      ;;

    read)
      local pin="$1"
      local val=$(sudo cat /sys/class/gpio/gpio${pin}/value)
      local color="$GRAY"
      if [ "$val" == "1" ]; then
        color="$GREEN"
      fi
      printf "Pin ${YELLOW}${pin}${NC} has value ${color}${val}${NC}\n"
      ;;

    write)
      local pin="$1"
      local val="$2"
      local color="$GRAY"
      if [ "$val" == "1" ]; then
        color="$GREEN"
      fi
      if [ -n "$val" ]; then
        printf "Writing ${color}${val}${NC} to pin ${YELLOW}${pin}${NC}\n"
        sudo echo "$val" > /sys/class/gpio/gpio${pin}/value
      else
        printf "${RED}Missing value${NC}\n"
      fi
      ;;
  esac
}

#######################################
### DEVICE DISCOVERY AND NETWORKING ###
#######################################

function get_remote_device_ip_and_name_and_user_and_network {
  local userAndDevice="$8"

  # check for user, ex: pi@host
  if [[ "$userAndDevice" =~ \@ ]]; then
    local arr=(${userAndDevice/\@/ }) # split on @
    local deviceName="${arr[@]:1}" # take everything except first el
    local argUser=${arr[0]} # normal element access echo ${arr[1]}
  else
    local deviceName="$userAndDevice"
  fi

  # we passed in the bare ip addres:
  # for example: q pi@192.168.0.80
  if [[ "$deviceName" =~ [0-9]\.[[:digit:]] ]]; then # ip
    local _ip="$deviceName"

    if [ -n "$argUser" ]; then
      local _user="$argUser"
    fi

  else # for example: q dpanel, q root@dpanel etc.

    local resolverPath
    getDMTDeviceResolverPath resolverPath

    local result=$(node "$resolverPath" "$deviceName")
    local _dmt_device=true

    # ip
    local line=$(echo "$result" | grep "ip:")
    local arr=(${line/\:/ })
    local _ip=${arr[1]}

    # globalIp
    line=$(echo "$result" | grep "globalIp:")
    arr=(${line/\:/ })
    local _global_ip=${arr[1]}

    # globalSSHPort
    line=$(echo "$result" | grep "globalSSHPort:")
    arr=(${line/\:/ })
    local _global_ssh_port=${arr[1]}

    if [ -z "$_global_ssh_port" ]; then
      _global_ssh_port="22"
    fi

    # name
    line=$(echo "$result" | grep "name:")
    arr=(${line/\:/ })
    local _name=${arr[@]:1}

    # user
    line=$(echo "$result" | grep "user:")
    arr=(${line/\:/ })
    local _user=${arr[1]}

    # override if we passed the user with device name to this function
    if [ -n "$argUser" ]; then
      _user="$argUser"
    fi

    # network
    line=$(echo "$result" | grep "network:")
    arr=(${line/\:/ })
    local _network=${arr[1]}

    if [ -z "$_ip" ]; then

      if [ -n "$result" ]; then
        printf "${GRAY}All def files have to parse without error for device resolver to work${NC}\n"
        printf "${RED}Device resolver returned error:${NC}\n"
        printf "${GRAY}$result${NC}\n"
        return
      fi

      _dmt_device=false
      printf "${CYAN}Trying most recent network scan information ...${NC}\n"
      local lastScanResolverPath
      getLastScanSearchScriptPath lastScanResolverPath

      result=$(node "$lastScanResolverPath" "$deviceName")

      # ip
      line=$(echo "$result" | grep "ip:")
      arr=(${line/\:/ })
      _ip=${arr[1]}

      # name
      line=$(echo "$result" | grep "name:")
      arr=(${line/\:/ })
      _name=${arr[@]:1}

      if [ -n "$_name" ]; then
        printf "${GRAY}Detected ${CYAN}${_name}${GRAY} at ${NC}${_ip}${NC}\n"
      fi
    else
      printf "${CYAN}Resolved static ip for ${MAGENTA}${deviceName} ${CYAN}from device.def${NC}\n"
    fi

  fi

  if [ -n "$_ip" ]; then
    eval "$1='$_ip'"
    eval "$2='$_global_ip'"
    eval "$3='$_global_ssh_port'"
    eval "$4='$_name'"
    eval "$5='$_user'"
    eval "$6='$_network'"
    eval "$7='$_dmt_device'"
  fi
}

function getip {
  if [ -z "$1" ]; then
    if macos; then
      ifconfig en0 | grep broadcast
    else
      ip addr show eth0 | grep scope | grep -P 'inet \d+.\d+\.\d+\.\d+'
      ip addr show wlan0 | grep scope | grep -P 'inet \d+.\d+\.\d+\.\d+'
    fi
  else
    if [ -n "$2" ]; then
      printf "${RED}Only accepts exactly one search term, not more!${NC}\n"
      return
    fi

    local ip
    local globalIp
    local globalSSHPort
    local name
    local user
    local network
    local is_dmt_device
    get_remote_device_ip_and_name_and_user_and_network ip globalIp globalSSHPort name user network is_dmt_device "$1"
    if [ -n "$ip" ]; then
      echo
      if $is_dmt_device; then
        printf "${GREEN}Device name: ${MAGENTA}$name${NC} 💡${NC}\n"
      else
        printf "${GREEN}Device name: ${YELLOW}$name${NC} ${GRAY}(from devices.json & lastScan.json)${NC}\n"
      fi

      printf "${GREEN}IP:${NC} ${ip}\n"

      if [ -n "$globalIp" ]; then
        printf "${GREEN}Global IP:${NC} ${globalIp}\n"
      fi

      printf "${GRAY}Reading mac address ...${NC}\n"
      local normalized_mac=''
      get_mac normalized_mac "$ip"
      if [ -n "$normalized_mac" ]; then
        printf "${GREEN}MAC:${NC} ${normalized_mac}\n"
      fi

      echo
      pi "$ip"

      if ! $is_dmt_device; then
        echo
        printf "${GRAY}All possible matches:${NC}\n"
        net_scan --last "$1"
      fi
    else
      printf "${RED}Cannot find ip for ${CYAN}${1}${NC}\n"
    fi
  fi
}

function q {
  if [ -z "$1" ]; then
    exit
    return
  fi

  if [ "$1" == "-h" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}q [host]${NC} ${GRAY}logins to the host device specified in matching device.def or via devices.json & lastScan.json${NC}\n"
    printf "${GREEN}q${NC} ${GRAY}exit current session${NC}\n"
  fi

  # --- ap start ---

  local AP_IP="192.168.1.1"
  local ap_with_user

  if [ "$1" == "ap" ]; then
    ap_with_user="root@${AP_IP}"
  fi

  if [[ "$1" =~ @ap ]]; then
    ap_with_user=$(echo "$1" | sed "s/@ap/@${AP_IP}/g" )
  fi

  if [ -n "$ap_with_user" ]; then
    printf "${GREEN}Connecting to ${CYAN}${ap_with_user} ${GREEN}...${NC}\n"
    ssh "$ap_with_user"
    return
  fi

  # --- ap end ---

  if [ "$1" == "reset" ]; then
    if [ -z "$2" ]; then
      printf "${YELLOW}Usage:${NC}\n"
      printf "${GREEN}dmt reset [host/ip]${NC} ${GRAY}resets ssh security warning for this host/ip${NC}\n"
      return
    fi

    ssh-keygen -f "$HOME/.ssh/known_hosts" -R "$2"
    return
  fi

  local host_with_user=''
  local ssh_port=''
  get_full_host host_with_user ssh_port "$1"
  if [ -n "$host_with_user" ]; then
    if [ -z "$ssh_port" ]; then
      ssh "$host_with_user"
    else
      ssh "$host_with_user" -p "$ssh_port"
    fi
  else
    printf "${RED}No matching host found${NC}\n"
  fi

  # only digits
  # for easy using of ssh tunnels to elsewhere
  # if [[ $1 =~ ^[0-9]+$ ]]; then
  #   ssh localhost -p "$1"
  #   return
  # fi

  #ssh "$host" #| grep -v "Warning: Permanently added" | grep -v "The programs included with the Debian" | grep -v "the exact distribution terms for each program are described" | grep -v "individual files in /usr/share/doc" | grep -v "Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY" | grep -v "permitted by applicable law"
}

function get_full_host() {
  local ip
  local globalIp
  local __globalSSHPort
  local name
  local user
  local network
  local is_dmt_device

  # IMPORTANT METHOD :::
  get_remote_device_ip_and_name_and_user_and_network ip globalIp __globalSSHPort name user network is_dmt_device "$3"

  if [ -n "$ip" ]; then
    if [ -z "$user" ]; then
      user='root'
    fi

    # local normalized_mac=''
    # get_mac normalized_mac "$ip"
    # printf "${GREEN}MAC:${NC} ${normalized_mac}\n"

    local defaultSSHPort="22"

    if [ -z "$globalIp" ]; then
      local __host="${user}@${ip}"
      eval "$1='$__host'"
      eval "$2='$defaultSSHPort'"
    elif [ "$ip" == "$globalIp" ]; then
      if [ -n "$__globalSSHPort" ]; then
        local __host="${user}@${globalIp}"
        eval "$1='$__host'"
        eval "$2='$__globalSSHPort'"
      else
        local __host="${user}@${globalIp}"
        eval "$1='$__host'"
        eval "$2='$defaultSSHPort'"
      fi
    else
      local current_network_id=''
      get_current_network current_network_id
      if [ -n "$current_network_id" ] && [ -n "$network" ] && [ "$current_network_id" == "$network" ]; then
        #printf "Network id: ${MAGENTA}${current_network_id}${NC}\n"
        #printf "${MAGENTA}globalIp was also found but using local ip since we are on the same network as target host${NC}\n"
        local __host="${user}@${ip}"
        eval "$1='$__host'"
        eval "$2='$defaultSSHPort'"
      else
        if [ -n "$__globalSSHPort" ]; then
          local __host="${user}@${globalIp}"
          eval "$1='$__host'"
          eval "$2='$__globalSSHPort'"
        else
          local __host="${user}@${globalIp}"
          eval "$1='$__host'"
          eval "$2='$defaultSSHPort'"
        fi
      fi
    fi
  fi
}

function getDMTDeviceResolverPath {
  local _deviceResolverPath="${DMT_NODE_CORE}/dmt-controller/cli/deviceResolve.js"
  eval "$1='$_deviceResolverPath'"
}

function getLastScanSearchScriptPath {
  local _lastScanSearchPath="${DMT_NODE_CORE}/dmt-net/lib/net-scanner/lastScanSearch.js"
  eval "$1='$_lastScanSearchPath'"
}
#!/bin/bash

########### ESP8226 ###########

function get_highest_version_subdir {
  local dir="$2"

  if [ ! -d "$dir" ]; then
    printf "${dir} ${RED}directory is missing${NC}\n"
    return
  fi

  local cwd="`pwd`"
  cd "$dir"

  local __highest

  for entry in *
  do
    if [ -d "$entry" ]; then
      if [ -z "$__highest" ]; then
        __highest="$entry"
      else
        vercomp "$entry" "$__highest"

        if [ "$?" == 1 ]; then
          __highest="$entry"
        fi

        # case $? in
        #     0) op='=';;
        #     1) op='>';;
        #     2) op='<';;
        # esac
      fi
    fi
  done

  cd "$cwd"

  eval "$1='${__highest}'"
}

# esptool -vv -cd ck -cb 115200 -cp /dev/cu.SLAB_USBtoUART -ca 0x00000 -cf /var/folders/8l/7gg0cdz556x6shrd9n42kf140000gn/T/arduino_build_444147/lights.ino.bin
function esp {
  # local ftdi1="/dev/tty.SLAB_USBtoUART"
  # local ftdi2="/dev/tty.wchusbserial1420"

  local ftdi1="/dev/cu.SLAB_USBtoUART"
  local ftdi2="/dev/cu.wchusbserial1420"

  local ftdi=$ftdi1

  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    echo "esp [command] [arguments]"
    echo
    printf "${YELLOW}Commands:${NC}\n"
    printf "${GREEN}help${NC}\n"
    printf "${GREEN}erase${NC}\n"
    printf "${GREEN}flash${NC} ${GRAY}[file.bin] [slow|fast] (default=slow)${NC}\n"
    printf "${GREEN}upload${NC} ${GRAY}[file.bin] [ip]${NC}\n"
  else

    declare -a opts=(
      "help"
      "flash"
      "erase"
      "upload"
    )

    local matching_opt=''
    opts_matcher matching_opt "$1" "${opts[@]}"
    if [ $? -ne 0 ]; then # error
      return
    fi

    shift

    # LOCATE ESPTOOL
    local esp_tool_parent_path="$HOME/Library/Arduino15/packages/esp8266/tools/esptool"
    local highest=''
    get_highest_version_subdir highest "$esp_tool_parent_path"
    local esp_tool_path="${esp_tool_parent_path}/${highest}/esptool"
    if [ ! -f "$esp_tool_path" ]; then
      printf "${esp_tool_path} ${RED}file is missing${NC}\n"
      return
    fi

    case "$matching_opt" in
      help)
        "$esp_tool_path" -h
        ;;

      erase)
          printf "esp tool : ${MAGENTA}$esp_tool_path${NC}\n"
          printf "ftdi: ${MAGENTA}$ftdi${NC}\n"
          "$esp_tool_path" -vv -cp "$ftdi" -ce
          ;;

      flash)
          if [ -z "$1" ]; then
            printf "${RED}Please specify firmware file${NC}\n"
            return
          fi
          if [ ! -f "$1" ]; then
            printf "${RED}Firmware file doesn't exist${NC}\n"
            return
          fi
          local baudrate=57600
          if [ "$3" == "fast" ]; then
            baudrate=115200
            echo "FAST"
          fi
          printf "esp tool : ${MAGENTA}$esp_tool_path${NC}\n"
          printf "ftdi: ${MAGENTA}$ftdi${NC}\n"
          printf "baudrate: ${MAGENTA}$baudrate${NC}\n"
          "$esp_tool_path" -vv -cp "$ftdi" -cb "$baudrate" -ca 0x0 -cf "$1"
          ;;

      upload)
          # LOCATE ESPOTA
          local esp_path="$HOME/Library/Arduino15/packages/esp8266/hardware/esp8266"
          local highest=''
          get_highest_version_subdir highest "$esp_path"
          local esp_ota_path="${esp_path}/${highest}/tools/espota.py"
          if [ ! -f "$esp_ota_path" ]; then
            printf "${esp_ota_path} ${RED}file is missing${NC}\n"
            return
          fi

          if [ -z "$1" ]; then
            printf "${RED}Please specify firmware file and ip address${NC}\n"
            return
          fi
          # if [ ! -f "$2" ]; then
          #   printf "${RED}Firmware file doesn't exist${NC}\n"
          #   return
          # fi
          if [ -z "$2" ]; then
            printf "${RED}Please specify an ip address${NC}\n"
            return
          fi
          local file="$1"
          local ip="$2"

          local matching_file=''
          get_matching_file matching_file "$file"
          matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

          if [ ! -f "$matching_file" ]; then
            printf "${RED}Firmware file not found based on $file${NC}\n"
            return
          fi

          printf "esp ota : ${MAGENTA}$esp_ota_path${NC}\n"
          printf "file    : ${MAGENTA}$matching_file${NC}\n"
          printf "ip      : ${MAGENTA}$ip${NC}\n"

          python "$esp_ota_path" -d -i $ip -p 8266 --auth= -f "$matching_file"
          ;;

      esac

    fi
}


# source:
# https://stackoverflow.com/a/4025065/458177

vercomp () {
    if [[ $1 == $2 ]]
    then
        return 0
    fi
    local IFS=.
    local i ver1=($1) ver2=($2)
    # fill empty fields in ver1 with zeros
    for ((i=${#ver1[@]}; i<${#ver2[@]}; i++))
    do
        ver1[i]=0
    done
    for ((i=0; i<${#ver1[@]}; i++))
    do
        if [[ -z ${ver2[i]} ]]
        then
            # fill empty fields in ver2 with zeros
            ver2[i]=0
        fi
        if ((10#${ver1[i]} > 10#${ver2[i]}))
        then
            return 1
        fi
        if ((10#${ver1[i]} < 10#${ver2[i]}))
        then
            return 2
        fi
    done
    return 0
}

testvercomp() {
    vercomp $1 $2
    case $? in
        0) op='=';;
        1) op='>';;
        2) op='<';;
    esac
    if [[ $op != $3 ]]
    then
        echo "FAIL: Expected '$3', Actual '$op', Arg1 '$1', Arg2 '$2'"
    else
        echo "Pass: '$1 $op $2'"
    fi
}

run_testvercomp() {
  # Run tests
  # argument table format:
  # testarg1   testarg2     expected_relationship
  echo "The following tests should pass"
  while read -r test
  do
      testvercomp $test
done << EOF
1            1            =
2.1          2.2          <
3.0.4.10     3.0.4.2      >
4.08         4.08.01      <
3.2.1.9.8144 3.2          >
3.2          3.2.1.9.8144 <
1.2          2.1          <
2.1          1.2          >
5.6.7        5.6.7        =
1.01.1       1.1.1        =
1.1.1        1.01.1       =
1            1.0          =
1.0          1            =
1.0.2.0      1.0.2        =
1..0         1.0          =
1.0          1..0         =
EOF

  echo "The following test should fail (test the tester)"
  testvercomp 1 1 '>'
}



# https://github.com/espressif/esptool
# did not work on newer models of sonoff basic
# function esp_old {
#   local ftdi1="/dev/tty.SLAB_USBtoUART"
#   local ftdi2="/dev/tty.wchusbserial1420"

#   local ftdi=$ftdi1

#   if [ -z "$1" ]; then
#     printf "${YELLOW}Usage:${NC}\n"
#     echo "esp [command] [arguments]"
#     echo
#     printf "${YELLOW}Commands:${NC}\n"
#     printf "${GREEN}mac${NC}\n"
#     printf "${GREEN}erase${NC}\n"
#     printf "${GREEN}flash${NC} ${GRAY}[file.bin] [slow|fast] (default=slow)${NC}\n"
#     printf "${GREEN}upload${NC} ${GRAY}[file.bin] [ip]${NC}\n"
#   else

#     declare -a opts=(
#       "mac"
#       "flash"
#       "erase"
#       "upload"
#     )

#     local matching_opt=''
#     opts_matcher matching_opt "$1" "${opts[@]}"
#     if [ $? -ne 0 ]; then # error
#       return
#     fi

#     shift

#     # https://github.com/espressif/esptool
#     # pip install esptool
#     local esp_tool_path="$HOME/Desktop/esptool/esptool.py"

#     case "$matching_opt" in
#       mac)
#           printf "esp tool : ${MAGENTA}$esp_tool_path${NC}\n"
#           printf "ftdi: ${MAGENTA}$ftdi${NC}\n"
#           "$esp_tool_path" -p "$ftdi" --chip auto read_mac
#           ;;

#       erase)
#           printf "esp tool : ${MAGENTA}$esp_tool_path${NC}\n"
#           printf "ftdi: ${MAGENTA}$ftdi${NC}\n"
#           "$esp_tool_path" -p "$ftdi" erase_flash
#           ;;

#       flash)
#           if [ -z "$1" ]; then
#             printf "${RED}Please specify firmware file${NC}\n"
#             return
#           fi
#           if [ ! -f "$1" ]; then
#             printf "${RED}Firmware file doesn't exist${NC}\n"
#             return
#           fi
#           local baudrate=57600
#           if [ "$3" == "fast" ]; then
#             baudrate=115200
#             echo "FAST"
#           fi
#           printf "esp tool : ${MAGENTA}$esp_tool_path${NC}\n"
#           printf "ftdi: ${MAGENTA}$ftdi${NC}\n"
#           printf "baudrate: ${MAGENTA}$baudrate${NC}\n"
#           "$esp_tool_path" -p "$ftdi" -b "$baudrate" write_flash 0x0 "$1"
#           ;;

#       upload)
#           local esp_path="$HOME/Library/Arduino15/packages/esp8266/hardware/esp8266"
#           local exec_count=$(find "$esp_path" -type f -name "espota.py" | wc -l)

#           if [ $exec_count == 1 ]; then
#             local esp_ota_path=$(find "$esp_path" -type f -name "espota.py")
#           elif [ $exec_count == 0 ]; then
#             printf "${RED}Missing espota.py under $esp_path${NC}\n"
#             return
#           else
#             printf "${RED}Multiple espota.py:${NC}\n"
#             find "$esp_path" -type f -name "espota.py"
#             printf "${YELLOW}Which one is correct?${NC}\n"
#             return
#           fi

#           if [ -z "$1" ]; then
#             printf "${RED}Please specify firmware file and ip address${NC}\n"
#             return
#           fi
#           # if [ ! -f "$2" ]; then
#           #   printf "${RED}Firmware file doesn't exist${NC}\n"
#           #   return
#           # fi
#           if [ -z "$2" ]; then
#             printf "${RED}Please specify an ip address${NC}\n"
#             return
#           fi
#           local file="$1"
#           local ip="$2"

#           local matching_file=''
#           get_matching_file matching_file "$file"
#           matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

#           if [ ! -f "$matching_file" ]; then
#             printf "${RED}Firmware file not found based on $file${NC}\n"
#             return
#           fi

#           printf "esp ota : ${MAGENTA}$esp_ota_path${NC}\n"
#           printf "file    : ${MAGENTA}$matching_file${NC}\n"
#           printf "ip      : ${MAGENTA}$ip${NC}\n"

#           python "$esp_ota_path" -d -i $ip -p 8266 --auth= -f "$matching_file"

#           # if [ -f "$HOME/Install/esp8266/tools/espota.py" ]; then
#           #   printf "ip: ${MAGENTA}$ip${NC}\n"
#           #   printf "file: ${MAGENTA}$file${NC}\n"
#           #   $HOME/Install/esp8266/tools/espota.py -d -i "$ip" -p 8266 --auth= -f "$file"
#           # else
#           #   printf "$HOME/Install/esp8266/tools/espota.py ${RED}not found${NC}\n"
#           # fi
#           ;;

#       esac

#     fi
# }
#!/bin/bash

# SEARCH THIS MACHINE OR SOME OTHER MACHINE (LIST)
#
# search @this terms (shorter: search terms) → searches this device ("general" share which needs to be defined)
# search @this/books terms → searches this device ("books" share which needs to be defined)

# search @device1 terms → searches device1 ("general" share)
# search @device1/books terms → searches books on device1

# search @device1 @device2 @device3 terms → searches device1, device2 and device3 ("general" share on each device) and returns aggregate results

function search {
  local searchCmd="$DMT_NODE_CORE/dmt-search/cli/search.js"

  if [ ! -f "$searchCmd" ]; then # dmt shell before v1.0.79 :::
    searchCmd="$DMT_NODE_CORE/dmt-controller/cli/search.js"
  fi

  node "$searchCmd" "$@"
}

function s {
  search "$@"
}

# SEARCH ALL

# just a shortcut to search all local catalogs (@this/catalogs is a normal share defined on local device with the name "catalogs"
# -- it contains a list of catalogs which are saved locally on the device)

function search_all {
  search "@this/catalogs" "$@"
}

function sall {
  search_all "$@"
}

function walksearch {
  local walksearch=''
  platform_bin_command walksearch "walksearch"
  if [ -z "$walksearch" ]; then
    return
  fi
  "$walksearch" "$@"
}

function walkdir {
  local walkdir=''
  platform_bin_command walkdir "walkdir"
  if [ -z "$walkdir" ]; then
    return
  fi

  "$walkdir" "$@"
}

function update_catalogs {

  printf "${RED}Red Warning ('_') ignores not yet implemented, whole ~ is being indexed...${NC}\n"

  local device_name=''
  get_current_device device_name
  if [ -z "$device_name" ]; then
    printf "${RED}Device name not found in device.def or device.def not found ${NC}\n"
    return
  fi

  local CATALOGS_PATH="$HOME/.dmt/user/catalogs/${device_name}"
  mkdir -p "$CATALOGS_PATH"

  if [ -f "${CATALOGS_PATH}/catalog_in_progress.txt" ]; then
    rm "${CATALOGS_PATH}/catalog_in_progress.txt"
  fi

  local walkdir=''
  platform_bin_command walkdir "walkdir"
  if [ -z "$walkdir" ]; then
    return
  fi

  printf "${YELLOW}Updating or creating catalog...${NC}\n"

  time "$walkdir" ~ | grep -v -i ".DS_Store" | grep -v -i "cache" > "${CATALOGS_PATH}/catalog_in_progress.txt"

  if [ -f "${CATALOGS_PATH}/catalog_in_progress.txt" ]; then
    local cwd="`pwd`"
    cd "$CATALOGS_PATH"

    local cat_name="${device_name}.catalog"

    mv "catalog_in_progress.txt" "${cat_name}.txt"
    zip "${cat_name}.zip" "${cat_name}.txt"

    cd "$cwd"
  fi
}
#!/bin/bash

function jazz {
  mpvc play http://us4.internet-radio.com:8266/stream
}

function rock {
  mpvc play http://198.58.98.83:8258/stream
}

function v {
  m "vid" "$@"
}

function m {
  declare -a opts=(
    "help"

    "search"

    "play"
    "pause"
    "stop"
    "next"

    "volume"
    "status"
    "list"

    "add"
    "insert"
    "insplay" # insert-play
    "bump" # moves song to the next position

    "shuffle"
    "cut"
    "paste"

    "forward"
    "backward"
    "goto"

    "limit"

    "spaced"
    "unspaced"
  )

  if [ "$1" == "-h" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}${opts[@]}${NC}\n"
    return
  fi

  local video=false

  ## TODO: FIX... instead of "m vid" , pass on the @media=[mediaType] parameter !!
  if [ "$1" == "vid" ]; then
    video=true
    shift
  fi

  # m [command] @hosts [terms]
  local command=''

  if [[ "$1" != @* ]]; then
    command="$1"
    shift
  fi

  #-----------#-----------#----------- A BIT OF DUPLICATE CODE FROM function dmt
  local hosts=""

  local args
  IFS=' ' read -r -a args <<< "$@"

  for arg in "${args[@]}"
  do
    if [ "$arg" == "@all" ]; then
      local network_id=''
      get_current_network network_id
      if [ -n "$network_id" ]; then
        # extract host from @ symbol but replace @all with the name of current network !
        hosts="${hosts} @@$network_id"
        shift
      fi
    elif [[ "$arg" == @* ]] && [[ ! "$arg" =~ = ]]; then # @count=200 etc. these should not be treated as hostnames
      hosts="${hosts} ${arg}"
      shift
    fi
  done

  hosts=$(echo "$hosts" | xargs) # remove trailing whitespace
  #-----------#-----------#-----------

  local matching_opt=''
  opts_matcher matching_opt "no_warning" "${command}" "${opts[@]}"
  if [ $? -ne 0 ]; then # error
    matching_opt="play" # default command when none specified
  fi

  local playerCmd="$DMT_NODE_CORE/dmt-player/cli/media.js"

  if [ ! -f "$playerCmd" ]; then # dmt shell before v1.0.79 :::
    playerCmd="$DMT_NODE_CORE/dmt-controller/cli/music.js"
  fi

  if $video; then

    if [ -z "$hosts" ]; then
      node "$playerCmd" "${matching_opt}" "$@" "@media=video"
    else
      node "$playerCmd" "${hosts}" "${matching_opt}" "$@" "@media=video"
    fi

  else

    if [ -z "$hosts" ]; then
      node "$playerCmd" "${matching_opt}" "$@"
    else
      node "$playerCmd" "${hosts}" "${matching_opt}" "$@"
    fi

  fi
}

function save_alsa {
  alsactl --file ~/.config/asound.state store
}

function restore_alsa {
  alsactl --file ~/.config/asound.state restore
}

function mpvc {
  local script="$DMT_SCRIPTS/mpv_control"
  if [ -f "$script" ]; then
    "$script" "$@"
  else
    printf "${RED}missing ${script}${NC}\n"
  fi
}

function pl {
  play "$@"
}



function soundtest {
  if is_rpi; then
    printf "${GREEN}Soundtest ${MAGENTA}0.${NC}\n"
    aplay "$DMT_PATH/etc/sounds/soundtest/music.wav"
  fi

  which mpv > /dev/null 2>&1

  if [ ! $? -eq 0 ]; then
    printf "${MAGENTA}mpv is missing, please install it....${NC}\n"
    printf "${GRAY}debian linux / raspberrypi${NC} → ${GREEN}sudo apt-get install mpv${NC}\n"
    printf "${GRAY}macos${NC} → ${GREEN}brew install mpv${NC}\n"
    printf "${GRAY}windows${NC} → ${YELLOW}?${NC}\n"
    return
  fi

  #printf "${GREEN}Soundtest ${MAGENTA}1.${NC}\n"
  #mpv --no-video "$DMT_PATH/etc/sounds/soundtest/music.mp3"

  printf "${GREEN}Soundtest ${MAGENTA}1.${NC}\n"
  node "$DMT_NODE_CORE/dmt-controller/lib/player/localMusicPlayer.js"
}


function videotest {
  # if is_rpi; then
  #   printf "${GREEN}Soundtest ${MAGENTA}0.${NC}\n"
  #   aplay "$DMT_PATH/etc/sounds/soundtest/music.wav"
  # fi

  which mpv > /dev/null 2>&1

  if [ ! $? -eq 0 ]; then
    printf "${MAGENTA}mpv is missing, please install it....${NC}\n"
    printf "${GRAY}debian linux / raspberrypi${NC} → ${GREEN}sudo apt-get install mpv${NC}\n"
    printf "${GRAY}macos${NC} → ${GREEN}brew install mpv${NC}\n"
    printf "${GRAY}windows${NC} → ${YELLOW}?${NC}\n"
    return
  fi

  #printf "${GREEN}Videotest ${MAGENTA}1.${NC}\n"
  #mpv "$DMT_PATH/etc/videos/videotest/video.mp4"

  printf "${GREEN}Videotest ${MAGENTA}1.${NC}\n"
  node "$DMT_NODE_CORE/dmt-controller/lib/player/localVideoPlayer.js"
}
#!/bin/bash

# *************************************************************
# Easy deploy with rsync and custom pre and post-deploy hooks *
# *************************************************************

# Command line API:

# dep                 - deploys according to local .deploy file
# dep [user@host]     - deploys according to local .deploy file except that targets are ignored and replaced with target [user@host]
#                       if .deploy file is not present, simple rsync is used to copy the directory over
# dep [.deploy_file]  - deploys according to custom deploy file
# dep [.deploy_file] [user@host]  - similar to above, overwrites targets specified in deploy file

# .deploy file structure, two possibilities:

# 1)

# Multi-deploy:
# Example .deploy:
# ----------------
# project: path1
# project: path2
# project: path3

# This will deploy each project according to its .deploy file, paths can be relative

# 2)

# Otherwise:

# You just need .deploy file with target (ex: user@server.com:/home/dir)
# and (optional) additional targets in subsequent lines
# AFTER COMES AN EMPTY LINE, then (optional):
#
# source: which directory to deploy, default: ./
# pre_local: cmd1 # run locally before rsync (prevent this with --no-pre)
# post_local: cmd1 # run locally after rsync
# pre_remote: cmd1 # run on server before rsync
# post_remote: cmd1 # run on server after rsync

# Example:
# --------
# sol:/var/projects/home-panel
# pi@living-room.local:/var/projects/home-panel
#   [!!!! BLANK LINE !!!!]
# source: dist
# overwrite: false
#
# pre_local: npm run build
#
# post_local: remote -h pi@hpanel.local "kiosk_reload"
# post_local: remote -h pi@lpanel.local "kiosk_reload"
#
# Explanation:
# source: [dir]
# deploy this subdirectory only
# overwrite: false
# refuse to execute sync if it would overwrite anything

# .deployignore

# It is recommended to have general $DMT_PATH/etc/.deployignore with contents similar to this:
# .deploy
# .deployignore
# .DS_Store
# .coolsync
# .git
# .gitignore
# log

# You can also have a local .deployignore file for each project to list additional files to ignore

function dep_rsync {

  # parse arguments: --dry, --no-pre, --no-delete, [deploy_file], [target]
  # can be only one argument! (no need for more)

  local dry=""

  if [ "$1" == "--dry" ]; then
    dry="$1"
    shift
  fi

  local no_pre=""

  if [ "$1" == "--no-pre" ]; then
    no_pre="$1"
    shift
  fi

  local no_delete=""

  if [ "$1" == "--no-delete" ]; then
    no_delete="$1"
    shift
  fi

  local full_delete=""

  # delete excluded files on target as well if present
  if [ "$1" == "--full-delete" ]; then
    full_delete="$1"
    shift
  fi

  # determine the deploy file
  local deploy_file=""
  if [ -f "$1" ]; then
    deploy_file="$1"
    shift
  elif [ -f ".deploy" ]; then
    deploy_file=".deploy"
  fi

  # target overwrites whatever is set in .deployfile
  local target_arg=""
  if [ -n "$1" ]; then
    target_arg="$1"
  fi

  # we allow deploying without deploy file if target is provided in command line, we just do rsync in this case
  if [ -z "$target_arg" ] && [ ! -f "$deploy_file" ]; then
    printf "${RED}Missing deploy file${NC}\n"
    return
  fi

  if [ -n "$deploy_file" ]; then
    # handle meta-deploy
    local first_line=`head -n 1 ${deploy_file}`
    local prefix="project: "
    if [[ "$first_line" = *$prefix* ]]; then
      local IFS=$'\n' # default is " " and then array is not correctly constructed when there is spaces in filenames
      printf "${MAGENTA}Multi-project deploy:${NC}\n"
      local lines=$(sed -e '/^$/,$d' ${deploy_file})
      grep -i "^${prefix}" "$deploy_file" | while read -r line ; do
        unset IFS
        local cwd="`pwd`"
        printf "\n${CYAN}■ ${line}${NC}\n"
        cd "${line#$prefix}"
        dep "$@"
        cd "$cwd"
      done

      return
    fi

    # PRE-DEPLOY: local
    if [ "$no_pre" != "--no-pre" ]; then
      local prefix="pre_local: "
      while read -r line; do
        eval "${line#$prefix}"
        if [ $? -ne 0 ]; then
          printf "\n${RED}dep error: ${GRAY}pre_local: ${NC}${line#$prefix} ${RED}failed${NC}\n"
          printf "${MAGENTA}Deploy stopped.${NC}\n"
          if [ -f /usr/bin/osascript ]; then
            /usr/bin/osascript -e "display notification \"${line#$prefix} was not successful\" with title \"Deploy failed\""
          fi
          return 1
        fi
      done < <(grep -i "^${prefix}" "$deploy_file")
    fi
  fi

  local IFS=$'\n' # default is " " and then array is not correctly constructed when there is spaces in filenames

  if [ -n "$target_arg" ]; then
    local targets="$target_arg"
  else
    # read all targets - until first blank line (or eof)
    local targets=$(sed -e '/^$/,$d' ${deploy_file})
  fi

  for target in ${targets} ; do

    local source_dir="`pwd`"/

    if [ -n "$deploy_file" ]; then
      # overwrite: false
      # refuse to sync if anything would be overwritten
      local prefix="overwrite: "
      while read -r line; do
        if [ "${line#$prefix}" == "false" ]; then
          comp "$source_dir" "$target"
          if [ $? -ne 0 ]; then
            echo
            printf "${RED}Deploy cancelled because some files at ${YELLOW}$target ${RED}would be deleted or overwritten${NC}\n"
            printf "${RED}and ${YELLOW}overwrite: false ${RED}option is active in ${YELLOW}$deploy_file ${RED}file.${NC}\n"
            echo
            printf "${GREEN}Please copy (or delete) target-only files or files with content different between source and target to source and try again.${NC}\n"
            return 1
          fi
        fi
      done < <(grep -i "^${prefix}" "$deploy_file")
    fi

    unset IFS

    # split on colon, example: user@server:/home/dir
    arr=($(echo $target | tr ":" "\n"))
    local server=${arr[0]}
    local remote_dir=${arr[1]}

    if [ -n "$deploy_file" ]; then
      # PRE-DEPLOY: remote
      local prefix="pre_remote: "
      grep -i "^${prefix}" "$deploy_file" | while read -r line ; do
        local cmd="${line#$prefix}"
        remote --silent -h "$server" "$cmd"
        #eval "ssh $server 'bash -ic \"$cmd\"' < /dev/null > /dev/null"
      done
    fi

    # DEPLOY

    if [ -n "$deploy_file" ]; then
      # read if different source directory from where out deploy file is, is specified
      while read -r line ; do
        local subdir=$(echo $line | sed 's/source: //g') # missing case insensitive
        source_dir="${source_dir}${subdir}"
      done < <(grep -i "^source:" "$deploy_file") # while loop written in this way makes possible to change the variable (source_dir), otherwise it is run in a subshell
    fi

    printf "\n${MAGENTA}Deploying ${YELLOW}$source_dir${NC} ${MAGENTA}→ ${GREEN}$target${NC}\n"

    fixperm "$source_dir" # I think it doesn't work on symlinks though!

    if [ "$dry" == "--dry" ]; then
      printf "${CYAN}[dep] Dry run ...${NC}\n"
    fi

    #printf "${MAGENTA}Syncing...${NC}\n"
    dirsync $dry $no_delete $full_delete "$source_dir" "$target"

    # cannot get correct $? out of rsync to know if it failed
    # if [ $? -eq 0 ]; then
    #   printf "${GREEN}Success!!!!${NC}\n"
    # else
    #   printf "${RED}FAIL${NC}\n"
    #   return
    # fi

    # POST-DEPLOY: remote
    if [ -n "$deploy_file" ]; then
      local prefix="post_remote: "
      grep -i "^${prefix}" "$deploy_file" | while read -r line ; do
        local cmd="${line#$prefix}"
        remote --silent -h "$server" "$cmd"
        #eval "ssh $server 'bash -ic \"$cmd\"' < /dev/null > /dev/null"
      done
    fi
  done

  # POST-DEPLOY: local
  if [ -n "$deploy_file" ]; then
    local prefix="post_local: "
    while read -r line ; do
      eval "${line#$prefix}"
      if [ $? -ne 0 ]; then
        printf "\n${RED}dep error: ${GRAY}post_local: ${NC}${line#$prefix} ${RED}failed${NC}\n"
        printf "${MAGENTA}Deploy stopped.${NC}\n"
        if [ -f /usr/bin/osascript ]; then
          /usr/bin/osascript -e "display notification \"${line#$prefix} was not successful\" with title \"Deploy failed\""
        fi
        return
      fi
    done < <(grep -i "^${prefix}" "$deploy_file")
  fi

  if $failed; then
    return
  fi

  printf "\n${GREEN}✓ deploy finished.${NC}\n"
}

function dep {
  if [ -f ./truffle.js ]; then
    truffle deploy --reset
    # deploy target (manual from cli or from ./.deploy file)
  else
    dep_rsync "$@"
  fi
}

# Deploy and purge cache

function remote {
  local silent=false

  if [ "$1" == "--silent" ]; then
    silent=true
    shift
  fi

  local server=""
  local ssh_port="22"

  if [ "$1" == "--host" ] || [ "$1" == "-h" ]; then
    server="$2"
    shift
    shift

    if [ "$1" == "--port" ]; then
      ssh_port="$2"
      shift
      shift
    fi
  elif [ -n "$1" ] && [ -f "./.deploy" ]; then
    target=$(head -n 1 ./.deploy)

    # split on colon, example: user@server:/home/dir
    arr=($(echo $target | tr ":" "\n"))
    local server="${arr[0]}"
    local remote_dir="${arr[1]}"

    printf "Targeting host ${YELLOW}$server${NC} specified in ${YELLOW}./deploy${NC} file ...\n"
  fi

  if [ -z "$server" ] || [ -z "$1" ]; then
    printf "${MAGENTA}Runs the command on remote server (passed via -h argument or specified in .deploy file)${NC}\n\n"
    printf "${YELLOW}Usage:${NC}\n"
    printf "remote -h host [command] [args] ${GRAY}(runs command on host)${NC}\n"
    printf "remote [command] [args] ${GRAY}(.deploy file is needed to determine the host)${NC}\n"
    printf "remote serve ${GRAY}(starts node.js server via forever/production.js script)${NC}\n"

    return
  fi

  if [ "$1" == "serve" ]; then
    if [ -f "./.deploy" ]; then
      if [ -f "forever/production.json" ]; then
        remote "cd \"$remote_dir\"; NODE_ENV=production forever start forever/production.json"
        return
      else
        printf "${RED}Missing forever/production.json locally, presumed also on server${NC}\n"
      fi
    else
      printf "${RED}.deploy file needed for this functionality${NC}\n"
    fi
  else
    printf "Executing ${GREEN}$@${NC} on ${YELLOW}$server${NC}... "
    #printf "${YELLOW}Warning: environment variables passed as part of command are evaluated locally${NC}\n"
    local cmd="ssh $server -p ${ssh_port} 'bash -ic \"$@\"' < /dev/null"
    if $silent; then
      cmd="${cmd} > /dev/null"
    else
      echo
      echo
    fi
    # https://stackoverflow.com/questions/9393038/ssh-breaks-out-of-while-loop-in-bash
    eval "$cmd" 2>&1 | grep -v "Pseudo-terminal will not be allocated" | grep -v "Inappropriate ioctl for device" | grep -v "no job control in this shell" | grep -v "Warning: Permanently added" | grep -v "The programs included with the Debian" | grep -v "the exact distribution terms for each program are described" | grep -v "individual files in /usr/share/doc" | grep -v "Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY" | grep -v "permitted by applicable law"
    printf "${GREEN}done.${NC}\n"
  fi
}

# Specify permanent ignores in $DMT_PATH/etc/.deployignore and per-project in ./.deployignore
function dirsync {

  if [ -z "$1" ] || [ -z "$2" ]; then
    printf "${YELLOW}Usage:${NC}\n\n"
    printf "${GREEN}dirsync dir1 dir2${NC}\n"
    printf "${GREEN}dirsync --dry dir1 dir2${NC} ${GRAY}(simulate)${NC}\n"
    printf "${GREEN}dirsync --total${NC} ${GRAY}(ignoring every .deployignore file and copying everything)${NC}\n"
    printf "${GREEN}dirsync --compress dir1 dir2${NC} ${GRAY}(compress - use over internet, but not LAN)${NC}\n"
    printf "${GREEN}dirsync --checksum dir1 dir2${NC} ${GRAY}(use when timestamps on target are different but contents is likely same... This will sync & equalize timestamps, it's slow though but still probably faster than copying files over for no reason)${NC}\n"
    printf "${GREEN}dirsync --symlinks dir1 dir2${NC} ${GRAY}(copy symlink contents, not just symlinks)${NC}\n"
    printf "${GREEN}dirsync --no-delete dir1 dir2${NC} ${GRAY}(don't delete files on destination)${NC}\n"
    printf "${GREEN}dirsync --full-delete dir1 dir2${NC} ${GRAY}(delete ignored files on target as well)${NC}\n"
    printf "${GREEN}dirsync --port [port] dir1 dir2${NC} ${GRAY}(specify if non-default ssh port)${NC}\n"
  else

    local dmt_with_user=false
    local dry=""
    local total=false
    local compress=""
    local checksum=""
    local symlinks=""
    local no_ignore=false
    local no_delete=false
    local full_delete=false
    local ssh_port

    for arg in "$@"
    do
      case "$arg" in
        "--dmt_with_user" )
          dmt_with_user=true
          shift
          ;;
        "--dry" )
          dry="--dry-run"
          printf "${GRAY}--dry-run: simulated run with no effects...${NC}\n"
          shift
          ;;
        "--total" )
          total=true
          shift
          ;;
        "--compress" )
          compress="-z"
          printf "${GRAY}--compress: Compressing contents...${NC}\n"
          shift
          ;;
        "--checksum" )
          checksum="--checksum"
          printf "${GRAY}--checksum: Checksum...${NC}\n"
          shift
          ;;
        "--symlinks" )
          symlinks="-L"
          printf "${GRAY}--symlinks: Copy symlink contents, not just symlinks...${NC}\n"
          shift
          ;;
        "--no-ignore" )
          no_ignore=true
          printf "${GRAY}--no-ignore: Full rsync copy, all ignored files too...${NC}\n"
          shift
          ;;
        "--no-delete" )
          no_delete=true
          printf "${GRAY}--no-delete: Not deleting files on destination...${NC}\n"
          shift
          ;;
        "--full-delete" ) # delete excluded files on target as well if present
          full_delete=true
          printf "${GRAY}--full-delete: Delete ignored files on target as well...${NC}\n"
          shift
          ;;
        "--port" )
          shift
          ssh_port="$1"
          shift
          ;;
      esac
    done

    # --size-only ?

    # if [ ! -d "$1" ]; then
    #   printf "${RED}Source directory $1 doesn't exist${NC}\n"
    #   return
    # fi
    # if [ ! -d "$2" ]; then
    #   printf "${RED}Target directory $2 doesn't exist${NC}\n"
    #   return
    # fi

    #local params="-azL $checksum $dry --progress --delete"
    # --protect-args :: https://unix.stackexchange.com/questions/104618/how-to-rsync-over-ssh-when-directory-names-have-spaces
    # haven't encountered a problem here yet (only in a backup script where directory name had a space in argument), not sure if the problem would apply here: todo - check
    # just in case, we include this option because it doesn't hurt
    local params="-a $symlinks $checksum $dry --protect-args --progress --exclude .DS_Store"

    if ! $no_delete ; then
      params="${params} --delete"
    fi

    if $full_delete ; then
      params="${params} --delete-excluded"
    fi

    if macos && [ `which rsync` != "/usr/local/bin/rsync" ]; then
      printf "${YELLOW}Warning: using old version of rsync (where spaces in filenames can cause issues).${NC}\n"
      printf "${CYAN}Fix:${NC} brew install rsync\n"
    else
      params="${params} --protect-args"
    fi

    # printf "From: ${GREEN}$1${NC}\n"
    # printf "To: ${GREEN}$2${NC}\n"

    #local params="-azL --progress"

    #rsync $params "$1"/ "$2"/
    # fast rsync! arcfour is the weakest encyption but you have to enable it on the server! --
    # ssh -Q cipher localhost | paste -d , -s   --> list all the ciphers
    # add to /etc/ssh/sshd_config:
    # Ciphers 3des-cbc,blowfish-cbc,cast128-cbc,arcfour,arcfour128,arcfour256,aes128-cbc,aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se,aes128-ctr,aes192-ctr,aes256-ctr,aes128-gcm@openssh.com,aes256-gcm@openssh.com,chacha20-poly1305@openssh.com
    # more: http://mgalgs.github.io/2014/10/22/enable-arcfour-and-other-fast-ciphers-on-recent-versions-of-openssh.html
    # restart:
    # sudo service ssh restart
    #rsync $params -e "ssh -T -c arcfour -o Compression=no -x" "$1"/ "$2"/

    # Second best option - and when using from wireless to wireless device, MAKE SURE EITHER one (laptop or RPi) is on a cable!! This will make the biggest difference
    # https://gist.github.com/KartikTalwar/4393116
    printf "${GREEN}Syncing...${NC}\n"

    local e_params="ssh"
    if [ -n "$ssh_port" ]; then
      e_params="${e_params} -p ${ssh_port}"
    fi
    e_params="${e_params} -T -o Compression=no -x" # optimized for LAN !!

    local grep_ignore="Warning: Permanently added"

    # ****
    # **** updating or installing .dmt framework to another device
    # ****
    if [ -f "./shell/.bash_general" ]; then
      # we exclude .gitignore mainly because if not, it can hang around inside various node_modules (that have been deleted)
      # and then we get things like:
      # Syncing...
      # sending incremental file list
      # cannot delete non-empty directory: core/node/.common-deps/node_modules/event-stream/node_modules/optimist
      # cannot delete non-empty directory: core/node/.common-deps/node_modules/event-stream/node_modules/optimist
      # cannot delete non-empty directory: core/node/.common-deps/node_modules/event-stream/node_modules
      # cannot delete non-empty directory: core/node/.common-deps/node_modules/event-stream/node_modules
      rsync $params --exclude-from <(cat $DMT_PATH/etc/.deployignore | grep -v ".deployignore$" | grep -v ".gitignore$") --exclude-from <(cat ./.deployignore) -e "$e_params" "$1"/ "$2"/ 2>&1 | grep -v "$grep_ignore"
      return
    fi

    if $total; then
      rsync $params  -e "$e_params" "$1"/ "$2"/ 2>&1 | grep -v "$grep_ignore"
      return
    fi

    if [ -f "$DMT_PATH/etc/.deployignore" ] && ! $no_ignore ; then
      params="${params} --exclude-from $DMT_PATH/etc/.deployignore"
    fi

    if [ -f "./.deployignore" ] && ! $no_ignore; then
      params="${params} --exclude-from ./.deployignore"
    fi

    rsync $params -e "$e_params" "$1"/ "$2"/ 2>&1 | grep -v "$grep_ignore"

    echo
  fi
}

function comp {
  # warning: some duplication (see below) - this shouldn't change often, so we judge simplicity is worth it in this case
  local matches=$(diff -rq "$1" "$2" | grep -v -e ".DS_Store" -e ".stfolder" -e ".stignore" -e ".deploy" -e ".deployignore" | grep -vF "Only in $1" | wc -l)

  if [ $matches -eq 0 ]; then
    return 0
  else
    printf "${MAGENTA}Files different or only present on target:${NC}\n\n"
    # warning: duplication (see above)
    diff -rq "$1" "$2" | grep -v -e ".DS_Store" -e ".stfolder" -e ".stignore" -e ".deploy" -e ".deployignore" | grep -vF "Only in $1" | sort
    echo
    printf "${MAGENTA}Files only present on source:${NC}\n\n"
    # warning: duplication (see above)
    diff -rq "$1" "$2" | grep -v -e ".DS_Store" -e ".stfolder" -e ".stignore" -e ".deploy" -e ".deployignore" | grep -F "Only in $1" | sort
    return 1
  fi
}

#!/bin/bash

# Reload the environment
function rel2 {
  if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
  fi
  if [ -f ~/.bashrc ]; then
    . ~/.bashrc
  fi
  if [ -f ~/.bash_profile ]; then
    . ~/.bash_profile
  fi
}

function update {

  if [ "$1" == '-h' ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}dmt${NC} ${GRAY}${NC}\n"
    printf "${GREEN}rust${NC} ${GRAY}${NC}\n"
    printf "${GREEN}geth${NC} ${GRAY}${NC}\n"
    printf "${GREEN}swarm${NC} ${GRAY}${NC}\n"
    printf "${GREEN}parity${NC} ${GRAY}${NC}\n"
    return
  fi

  declare -a opts=(
    "dmt"
    "rust"
    "geth"
    "swarm"
    "parity"
  )

  if [ -z "$1" ]; then
    arg="dmt"
  else
    arg="$1"
    shift
  fi

  local matching_opt=''
  opts_matcher matching_opt "$arg" "${opts[@]}"
  if [ $? -ne 0 ]; then # error
    return
  fi

  case "$matching_opt" in
    dmt)
      dmt update "$@"
      ;;

    rust)
      update_rust "$@"
      ;;

    geth)
      update_geth "$@"
      ;;

    swarm)
      update_swarm "$@"
      ;;

    parity)
      update_parity  "$@"
      ;;
  esac
}

function install_n {
  curl -L https://git.io/n-install | bash
  echo "Now quit session and login again, then install 'n v8.11.3'"
}

# ----------------------------- APPLICATIONS -----------------------------

# ETHEREUM

function cdgeth {
  cd "$GOPATH/src/github.com/ethereum/go-ethereum"
}

function cdgo {
  cd "$GOPATH/src"
}

function pull_geth {
  cdgeth
  git pull
  latest_tag
}

function update_geth {
  if [ ! -d "$GOPATH/src/github.com/ethereum/go-ethereum" ]; then
    printf "${MAGENTA}geth not installed, installing [please wait] ...${NC}\n"
    go get -d github.com/ethereum/go-ethereum
    update_geth # checkout the latest tag now and compile
  else
    pull_geth
    go install -v ./cmd/geth
  fi
}

function update_swarm {
  pull_geth
  go install -v ./cmd/swarm
}

function install_node {
  curl -L https://git.io/n-install | bash
}

function install_parity {
  echo "If it doesn't compile on some machine (for example Digital Ocean droplet), compile elsewhere and copy ./target/release/parity binary over..."
  if [ -d "$HOME/parity-ethereum" ]; then
    printf "${RED}~/Install/parity directory already exists${NC}\n"
  else
    local cwd="`pwd`"
    mkdir -p ~/Install
    cd ~/Install

    sudo apt-get install -y libudev-dev cmake

    git clone https://github.com/paritytech/parity-ethereum.git
    update_parity
    cd "$cwd"
  fi
}

# https://github.com/paritytech/parity-ethereum/tree/stable
function update_parity {
  local cwd="`pwd`"
  cd ~/Install/parity-ethereum
  git fetch
  git reset --hard origin/stable
  #echo "1.27.0" > rust-toolchain
  cargo build --release --features final
  #printf "${YELLOW}set rust version 1.27.0, change this value in update_parity function if build failed${NC}\n"
  cd "$cwd"
}

function install_rust {
  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
}

function update_rust {
  rustup update
}


#!/bin/bash

# ------- ETHEREUM ----------
function ges {
  # rpccorsdomain is because of https://github.com/etherparty/explorer
  geth --rpc --rpcapi "db,eth,net,web3,personal" --ipcpath $HOME/Library/Ethereum/geth.ipc --rpccorsdomain "http://localhost:8000" $@
}

function gel {
  geth --light --rpc --rpcapi "db,eth,net,web3,personal"
}

function swarm_up {
  if [ -f "$1" ]; then
    swarm --bzzapi http://192.168.0.122:8500 up "$1"
  else
    printf "${RED}File doesn't exist${NC}\n"
  fi
}

# still not ok, Mist tries connect to this
function gesbg {
  # rpccorsdomain is because of https://github.com/etherparty/explorer
  geth --port 30305 --port 8547 --ipcdisable #--rpc --rpcapi "db,eth,net,web3,personal"
}

alias pes='parity --warp --port 30304 --rpcport 8600'

#alias ges='geth --password ~/Projects/ethereum/password --unlock "0x6b2474fb5b7203acc098f5186e6bf5beacde9364" --datadir "$HOME/Projects/ethereum/data/playground" --rpc --rpcapi "db,eth,net,web3,personal" --ipcpath $HOME/Library/Ethereum/geth.ipc'
function ge {
  printf "${YELLOW}loadScript('console.js')${NC}\n"
  geth --jspath "$HOME/Projects/ethereum/scripts" attach
}
#alias ge='geth --ipcpath "$HOME/Projects/ethereum/data/playground/geth.ipc" attach'

function mew {
  open ~/Install/mew_stable/index.html
}

function keystore {
  if macos; then
    cd ~/Library/Ethereum/keystore
  else
    cd ~/.ethereum/keystore
  fi
}

alias keystore2="cd ~/Library/Application\ Support/io.parity.ethereum/keys/ethereum"


#!/bin/bash

function ap {
  local script="$DMT_SCRIPTS/setup_ap"
  if [ -f "$script" ]; then
    sudo "$script" "$@"
  else
    printf "${RED}missing ${script}${NC}\n"
  fi
}

function part {
  local script="$DMT_SCRIPTS/part"
  if [ -f "$script" ]; then
    sudo "$script" "$@"
  else
    printf "${RED}missing ${script}${NC}\n"
  fi
}

function fix_chromium {
  if is_rpi; then
    rm -rf /home/pi/.config/chromium/Singleton*
    printf "${GREEN}Fixed ${GRAY}'This profile appears to be in use by another Chromium process' ${GREEN}problem.${NC}\n"
  else
    printf "${RED}Error: must be on RPi${NC}\n"
  fi
}

function monitor_on {
#     /opt/vc/bin/tvservice --preferred
  # Hack to enable virtual terminal nr 7 again:
  # COMMENT: does not work from a call of a script :: move to bash files
  chvt 6
  chvt 7

  ## sometimes it needs a seconds push :/
  chvt 6
  chvt 7
}

function monitor_off {
    /opt/vc/bin/tvservice --preferred
    #/opt/vc/bin/tvservice --off
}

function rpi_temp {
  /opt/vc/bin/vcgencmd measure_temp
}

function mon {
  if [ "$1" == '-h' ]; then
    printf "${MAGENTA}Control Raspberry Pi monitor output${NC}\n"
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}mon off${NC} ${GRAY}turn monitor off${NC}\n"
    printf "${GREEN}mon on${NC} ${GRAY}turn monitor back on${NC}\n"
    return
  fi

  if is_rpi; then

    if [ -z "$1" ] || [ "$1" == "on" ]; then
      monitor_on
      return
    fi

    monitor_off
  else
    printf "${RED}✖ Error: Only works on Raspberry Pi${NC}\n"
    mon -h
  fi
}
#!/bin/bash

DMT_CLI="$DMT_NODE_CORE/dmt-controller/cli/dmt.js"

# circle !
function o {
  dmt "$@"
}

function dmt {
  if [ -z "$1" ] || [ "$1" == "help" ] || [ "$1" == "version" ]; then
    printf "${MAGENTA}      ∞ DMT ∞${NC}\n"
    printf "${CYAN}Freedom to imagine${NC}\n"
    #printf "${CYAN}${NC}\n"
    echo
  fi

  # dmt [command] @hosts [terms]
  local command=''

  if [[ "$1" != @* ]]; then
    command="$1"
    shift
  fi

  # extract host from @ symbol but replace @all with the name of current network !
  local hosts=""

  local args
  IFS=' ' read -r -a args <<< "$@"

  for arg in "${args[@]}"
  do
    if [ "$arg" == "@all" ]; then
      local network_id=''
      get_current_network network_id
      if [ -n "$network_id" ]; then
        hosts="${hosts} @@$network_id"
        shift
      fi
    elif [[ "$arg" == @* ]] && [[ ! "$arg" =~ = ]]; then # @attr=val should not be treated as hostnames
      hosts="${hosts} ${arg}"
      shift
    fi
  done

  hosts=$(echo "$hosts" | xargs) # remove trailing whitespace

  declare -a opts=(
    "help"
    "test"
    "status"
    "version"
    "device"
    "services"
    "next"
    "core"
    "update"
    "debug"
    "renew"
    "remove"
    "log"
    "logfg"
    "install"
    "start"
    "startfg"
    "restart"
    "restart2"
    "stop"
    "link"
    "checklink"
    "unlink"
    "relink"
    "deactivate"
    "remove"
    "bin"
    "music"
    "search"
  )

  if dev_machine; then
    declare -a opts_admin=(
      "cd"
    )

    opts=("${opts[@]}" "${opts_admin[@]}")
  fi

  local matching_opt=''
  opts_matcher matching_opt "$command" "${opts[@]}"
  if [ $? -ne 0 ]; then # error
    if [ -z "$hosts" ]; then
      printf "Try ${GREEN}dmt help${NC} as well.\n"
      if [ -z "$1" ] && [ -n "$proc" ] ; then
        echo
        printf "${CYAN}This device info:${NC}\n\n"
        if [ ! -f "$DMT_DEVICE_FILE" ]; then
          printf "${RED}Reminder ● ${GRAY}you still need to configure this device ● ${CYAN}please run → \n\n${GREEN}  dmt device select${NC}\n\n"
          return
        fi
      fi
    fi

    if [ -z "$1" ]; then
      matching_opt="plain"
    else
      return
    fi
  fi

  local dmt_proc_pid=''
  local dmt_fg_bg=''
  get_dmt_proc_pid dmt_proc_pid dmt_fg_bg

  local proc_manager=$(ps -ef | grep "dmt-proc" | grep "manager.js" | grep -v "command -v openssl >/dev/null" | grep -v grep | awk '{print $2}')

  if [ -z "$hosts" ]; then # if we're targeting remote hosts, information about our own local process is irrelevant
    if [ "$matching_opt" != "next" ] && [ "$matching_opt" != "start" ] && [ "$matching_opt" != "startfg" ] && [ "$matching_opt" != "debug" ] && [ "$matching_opt" != "device" ]; then
      if [ -n "$dmt_proc_pid" ]; then
        printf "${WHITE}dmt-proc${NC} seems to be running with ${YELLOW}pid ${dmt_proc_pid}${NC}\n"
      elif [ "$matching_opt" != "stop" ] && [ "$matching_opt" != "restart" ]; then
        printf "⚠️  ${WHITE}dmt-proc${NC} ${RED}does not seem to be running${NC} ${YELLOW}→ use${NC} ${GREEN}dmt start${NC} 🚀\n"
        if [ -n "$proc_manager" ]; then
          printf ".... ${GREEN}looks like dmt process manager is currently (re)starting ${WHITE}dmt-proc${NC} ....\n"
        fi
      fi
      echo
    fi
  fi
  # ----

  case "$matching_opt" in
    plain)
      #echo "plain"
      # printf "${MAGENTA}Enabled aliasing:${NC}\n"
      # printf "${GREEN}✓${NC} 1) search and play${NC}\n"
      # printf "${GREEN}✓${NC} 2) networking${NC}\n"
      # printf "${RED}✖${NC} 3) extended aliases${NC}\n"
      # echo
      # printf "${GREEN}Enable group:${NC} dmt enable_al [num] ${WHITE}| ${RED}Disable group:${NC} ${GRAY}dmt disable_al [num]${NC}\n"
      node "$DMT_CLI" help "$@"
      ;;

    help)
      dmt_help

      echo
      printf "${MAGENTA}Available rpc methods: ${NC}\n\n"

      if [ -n "$hosts" ]; then
        node "$DMT_CLI" "${hosts}" help "$@"

        dmt_help_explain_rpc
      else
        if [ -z "$dmt_proc_pid" ]; then
          printf "${RED}None${NC}\n"
          echo
          printf "Please type ${GREEN}dmt start${NC} to start ${MAGENTA}dmt-proc${NC}.\n"
        else
          node "$DMT_CLI" help "$@"

          dmt_help_explain_rpc
        fi
      fi
      ;;

    test)
      if [ -n "$hosts" ]; then
        node "$DMT_CLI" "${hosts}" test "$@"
      else
        if [ -n "$dmt_proc_pid" ]; then
          node "$DMT_CLI" test "$@"
        fi
      fi
      ;;

    debug)
      local markerfile="$DMT_STATE/.debug-mode"
      if [ -z "$1" ] || [ "$1" == "on" ] || [ "$1" == "enable" ]; then
        if [ -f "$markerfile" ]; then
          printf "${GRAY}✓ Debug mode was already enabled${NC}\n"
        else
          touch "$markerfile"
          printf "${GREEN}✓ ${YELLOW}Debug mode ⚙️  enabled${NC}\n"
        fi

        printf "\n${MAGENTA}Micro-Debugging options:${NC}\n"

        printf "\nEdit ${YELLOW}${markerfile}${NC} file to increase debug log level (one line, one category like ${GREEN}mpv${NC}, ${GREEN}lan${NC} etc.) ${GRAY}⚠️  This will get lost when you execute ${GREEN}dmt debug off${GRAY}.${NC}\n"
        printf "\nTo make it more permanent, add this to device.def ${GRAY}(command:${NC} ${GREEN}dev edit${NC}${GRAY})${NC}:\n"
        printf "${MAGENTA}debug:${NC}\n"
        printf "  ${MAGENTA}log: ${GRAY}mpv${NC}\n"
        printf "  ${MAGENTA}log: ${GRAY}lan${NC}\n"
        printf "  ${MAGENTA}log: ${GRAY}...${NC}\n"
        printf "\n⚠️  ${GRAY}This, however, requires ${GREEN}dmt restart${GRAY} while editing the ${YELLOW}.debug-mode${GRAY} file does not.${NC}\n"

        echo

        printf "${MAGENTA}Options:${NC}\n"
        printf "${MAGENTA}--------${NC}\n\n"

        printf "${GREEN}mpv${NC} ${GRAY}enables mpv process logging into ~/.dmt/log/mpv.log (requires dmt restart ${NC}while other commands do not!${NC})${NC}\n"
        printf "${GREEN}mpv-ipc${NC} ${GRAY}enables debug messages between ${MAGENTA}dmt-process${NC} ${GRAY}and${NC} ${CYAN}mpv${NC} ${GRAY}process${NC}\n"
        printf "${GREEN}ws${NC} ${GRAY}enables debug messages about websocket connections (port 7780 -- metagui)${NC}\n"
        printf "${GREEN}lan${NC} ${GRAY}enables debug messages about lanbus${NC}\n"
        printf "${GREEN}mqtt-sent${NC} ${GRAY}enables debug messages about sent mqtt messages${NC}\n"
        printf "${GREEN}mqtt-received${NC} ${GRAY}enables debug messages about received mqtt messages${NC}\n"
        printf "${GREEN}beats${NC} ${GRAY}todo${NC}\n"
      fi

      if [ "$1" == "off" ] || [ "$1" == "disable" ] || [ "$1" == "stop" ]; then
        if [ -f "$markerfile" ]; then
          rm "$markerfile"
          printf "${CYAN}Debug mode disabled${NC}\n"
        else
          printf "${GRAY}Debug mode was already disabled${NC}\n"
        fi
      fi
      ;;

    search)
      if [ -n "$hosts" ]; then
        search "${hosts}" "$@"
      else
        search "$@"
      fi
      ;;

    music)
      if [ -n "$hosts" ]; then
        m "${hosts}" "$@"
      else
        m "$@"
      fi
      ;;

    services)
      if [ -n "$hosts" ]; then
        node "$DMT_CLI" "${hosts}" services "$@"
      else
        node "$DMT_CLI" services "$@"
      fi
      ;;

    version)
      dmt_version
      ;;

    device)
      dmt_device "$@"
      ;;

    next)
      dmt_next
      ;;

    update) # updates the whole folder, doesn't restart the service
      dmt_update "$@"
      ;;

    renew) # updates the whole folder and restarts the service
      dmt_renew "$@"
      ;;

    remove)
      dmt_remove
      ;;

    install)
      dmt_install "$@"
      ;;

    deactivate)
      dmt_deactivate
      ;;

    link)
      local cwd="`pwd`"
      cd "$DMT_NODE_CORE/.scripts"
      ./symlink_dmt_deps
      cd "$cwd"
      ;;

    unlink)
      local cwd="`pwd`"
      cd "$DMT_NODE_CORE/.scripts"
      ./symlink_dmt_deps "remove"
      cd "$cwd"
      ;;

    checklink)
      local cwd="`pwd`"
      cd "$DMT_NODE_CORE/.scripts"
      ./symlink_dmt_deps "check"
      cd "$cwd"
      ;;

    relink) #rarely used, usually "dmt link" is enough for this purpose as well... use "dmt relink" only if suddenly symlinks should point somewewhere else... if just some new symlinks have to be added, there is no need to unlink first, the symlinking script (dmt link) will add what's missing
      dmt unlink
      dmt link
      ;;

    start)
      if report_dmt_running "$dmt_proc_pid" "$dmt_fg_bg"; then
        return
      fi

      symlink_if_unlinked
      #copy_core_bootscripts
      compile_gui_if_missing

      printf "${CYAN}DMT PROCESS${NC} ${MAGENTA}is starting...${NC}\n\n"
      "${DMT_PATH}/etc/onboot/daemons" start

      # see if process is actually running
      local dmt_proc_pid=''
      local dmt_fg_bg=''
      get_dmt_proc_pid dmt_proc_pid dmt_fg_bg

      if [ -n "$dmt_proc_pid" ]; then
        printf "\n${CYAN}dmt-proc${NC} ${GRAY}should now be running, use ${GREEN}dmt log ${GRAY}to see events and information.${NC}\n"
      else
        printf "\n${RED}Problem starting ${CYAN}dmt-proc${RED}, please use ${GREEN}dmt logfg ${RED}to determine the reason${NC}\n"
      fi
      ;;

    startfg) # START FOREGROUND
      if report_dmt_running "$dmt_proc_pid" "$dmt_fg_bg"; then
        return
      fi

      symlink_if_unlinked
      #copy_core_bootscripts
      compile_gui_if_missing

      printf "${MAGENTA}dmt-proc${NC} ${WHITE}is starting in ${CYAN}foreground${NC} ...\n\n"
      node --trace-warnings --experimental-modules "${DMT_NODE_CORE}/dmt-controller/daemons/dmt-proc.js"  --fg # --fg: only for informative purposes to signal that we ran it in foreground as opposed to daemonizing (dmt start)
      ;;

    stop)
      local dmt_proc_pid=''
      local dmt_fg_bg=''
      get_dmt_proc_pid dmt_proc_pid dmt_fg_bg


      if [[ $dmt_fg_bg == 'fg' ]]; then
        printf "${MAGENTA}dmt-proc${NC} ${RED}is already running in 'foreground'${NC}, it was started with ${CYAN}dmt startfg${NC} in another terminal tab.\n"
        printf "${YELLOW}Please go to the other terminal tab and press ${GREEN}CTRL+C${NC}\n"
        echo
        printf "You can also use ${GREEN}sudo kill -9 ${dmt_proc_pid}${NC} to kill the process now.\n"
        return
      fi

      if [ -n "$dmt_proc_pid" ]; then
        printf "${CYAN}DMT PROCESS${NC} ${MAGENTA}is stopping...${NC}\n\n"
        "${DMT_PATH}/etc/onboot/daemons" stop
      else
        printf "${YELLOW}dmt-proc is not currently running ...${NC}\n"
      fi
      ;;

    restart)
      symlink_if_unlinked
      #copy_core_bootscripts
      compile_gui_if_missing

      printf "${CYAN}DMT PROCESS${NC} ${MAGENTA}is restarting...${NC}\n\n"
      "${DMT_PATH}/etc/onboot/daemons" restart
      if [ $? -eq 0 ]; then
        #printf "\n${CYAN}dmt-proc${NC} ${GRAY}restarted, use ${GREEN}dmt log ${GRAY}to see events and information.${NC}\n"
        # see if process is actually running
        local dmt_proc_pid=''
        local dmt_fg_bg=''
        get_dmt_proc_pid dmt_proc_pid dmt_fg_bg

        if [ -n "$dmt_proc_pid" ]; then
          printf "\n${CYAN}dmt-proc${NC} ${GRAY}restarted, use ${GREEN}dmt log ${GRAY}to see events and information.${NC}\n"
        else
          printf "\n${RED}Problem restarting ${CYAN}dmt-proc${RED}, please use ${GREEN}dmt logfg ${RED}to determine the reason${NC}\n"
        fi
      fi
      ;;

    log) # requestion to the service to get latest few log lines
      dmt_log "$@"
      ;;

    logfg) # show log in foreground and keep it updated
      dmt_log fg "$@"
      ;;

    # undocumented:

    flash)
      dmt_flash "$@"
      ;;

    bin)
      dmt_bin "$@"
      ;;

    cd)
      dmt_cd
      ;;

  esac
}

function get_dmt_proc_pid {
  # space in " dmt-proc" is required
  local proc=$(ps -ef | grep " dmt-proc" | grep -v "eslint" | grep -v "manager.js" | grep -v "command -v openssl >/dev/null" | grep -v grep | awk '{print $2}')
  local procFG=$(ps -ef | grep "dmt-controller/daemons/dmt-proc.js" | grep -v "eslint" | grep -v "command -v openssl >/dev/null" | grep -v grep | awk '{print $2}')

  if [ -n "$proc" ]; then
    #ps -ef | grep " dmt-proc" | grep -v "manager.js" | grep -v "command -v openssl >/dev/null" | grep -v grep
    eval "$1='$proc'"
    eval "$2='bg'"
  fi

  # dmt process running in foreground
  if [ -n "$procFG" ]; then
    #ps -ef | grep "dmt-controller/daemons/dmt-proc.js" | grep -v "command -v openssl >/dev/null" | grep -v grep
    eval "$1='$procFG'"
    eval "$2='fg'"
  fi
}

function report_dmt_running {
  local dmt_proc_pid="$1"
  local fg_bg="$2"

  if [ -n "$dmt_proc_pid" ]; then
    local fg_bg_msg=""
    if [ "$fg_bg" == 'fg' ]; then
      fg_bg_msg="${MAGENTA}in foreground${NC} "
    fi
    printf "${WHITE}dmt-proc${NC} ${GREEN}seems to already be running ${fg_bg_msg}with ${YELLOW}pid ${dmt_proc_pid}${NC}\n"
    return 0
  fi

  return 1
}

# warning: duplicated in ~/.dmt/etc/onboot/daemons
function save_dmt_state {
  local dmt_cli="${DMT_NODE_CORE}/dmt-controller/cli/dmt.js"
  if [ -f "$dmt_cli" ]; then
    node "$dmt_cli" save_state
  fi
}

function dmt_device {
  declare -a opts=(
    "cd"
    "select"
    "def"
    "edit"
  )

  if [ -z "$1" ] || [ "$1" == "-h" ]; then
    local device_name=''
    get_current_device device_name

    if [ -n "$device_name" ]; then
      printf "${CYAN}Device name: 💡 ${MAGENTA}${device_name}${NC}\n\n"
    else
      printf "${GRAY}This device is ${RED}unnamed 🤔${GRAY}, please name it by running ${GREEN}dmt device select${GRAY} (or shorter: ${GREEN}dev sel${GRAY}).${NC}\n\n"
      return
    fi

    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}cd${NC} ${GRAY}move to directory with curent device's configuration${NC}\n"
    printf "${GREEN}select${NC} ${GRAY}select configuration for this device from existing configurations or create a new configuration and assign it to this device${NC}\n"
    printf "${GREEN}def${NC} ${GRAY}shows parsed device.def definition in json format${NC}\n"
    printf "${GREEN}edit${NC} ${GRAY}edit current device's device.def${NC}\n"
    return
  fi

  local matching_opt=''
  opts_matcher matching_opt "$1" "${opts[@]}"

  shift

  case "$matching_opt" in
    cd)
      device_helper cd
      ;;

    edit)
      device_helper edit
      ;;

    select)
      local script="$DMT_SCRIPTS/setup_device"
      if [ -f "$script" ]; then
        "$script" "$@"
      fi
      ;;

    def)
      printf "${YELLOW}Showing device definition in json format (parsed from .def):${NC}\n"
      local cli="$DMT_NODE_CORE/dmt-controller/cli/device.js"
      if [ -n "$hosts" ]; then
        node "$cli" "${hosts}" "$@"
      else
        node "$cli" "$@"
      fi
      ;;
  esac
}

function dev {
  dmt_device "$@"
}

function device {
  dmt_device "$@"
}

function device_helper {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}cd${NC} ${GRAY}${NC}\n"
    printf "${GREEN}edit${NC} ${GRAY}${NC}\n"
    printf "${GREEN}list${NC} ${GRAY}${NC}\n"
    printf "${GREEN}ping${NC} ${GRAY}${NC}\n"
  else
    declare -a opts=(
      "cd"
      "edit"
      "list"
      "ping"
    )

    local matching_opt=''
    opts_matcher matching_opt "$1" "${opts[@]}"
    if [ $? -ne 0 ]; then # error
      printf "${YELLOW}Use ${GREEN}help ${YELLOW}for more options${NC}\n\n"
      #matching_opt="aaa" # default
    fi

    shift

    case "$matching_opt" in
      cd)
        if [ -z "$1" ]; then
          AWESOME_SILENCE=true awesome_cd ~/.dmt/user/devices
          if [ $? -eq 0 ] && [ -d "this/def" ]; then
            cd "this/def"
          fi
        else
          AWESOME_SILENCE=true awesome_cd ~/.dmt/user/devices "$1"

          if [ $? -eq 0 ]; then
            if [ -d "def" ]; then
              cd "def"
            fi
          else
            printf "${RED}not found${NC}\n"
          fi
        fi
        ;;

      edit)
        local dir="${DMT_USER_PATH}/devices/this"
        if [ -d "$dir" ]; then
          local file="${dir}/def/device.def"
          if [ -f "$file" ]; then
            e "$file"
          else
            echo $file
            printf "${RED}device.def file not found${NC}\n"
          fi
        else
          printf "${RED}Device is unknown${GRAY}, please select the definition file by using ${GREEN}dev select${GRAY}, then try again.${NC}\n"
        fi
        ;;

      list)
        for_all_devices "list"
        ;;

      ping)
        for_all_devices
        ;;
    esac
  fi
}

function state {

  if [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}state${NC} ${GRAY}show program state${NC}\n"
    printf "${GREEN}state [store]${NC} ${GRAY}show a specific store state (controller, player etc.)${NC}\n"
    printf "${GREEN}state [store].[key]${NC} ${GRAY}ex.: player.playlist, controller.weather${NC}\n"
    printf "${GREEN}state purge${NC} ${GRAY}delete program state${NC}\n"
    return
  fi

  local DMT_STATE_FILE="$DMT_PATH/state/program.json"

  if [ -f "$DMT_STATE_FILE" ]; then
    if [ "$1" == "purge" ]; then
      if [ -f "$DMT_STATE_FILE" ]; then
        #dmt stop
        rm "$DMT_STATE_FILE"
        printf "${GREEN}purged dmt state${NC}\n"
        #dmt start
      fi
    else
      if [ -n "$1" ]; then
        cat "${DMT_STATE_FILE}" | jq ".$1"
      else
        cat "${DMT_STATE_FILE}" | jq
      fi
    fi
  else
    printf "${YELLOW}dmt state not found on disk${NC}\n"
  fi
}

function gui_build_all {
  local cwd="`pwd`"

  local base_dir="$DMT_PATH/core/node/dmt-gui/gui-frontend-core"

  cd "$base_dir"

  for component in *; do
    if [ -d "$component" ] && [ "$component" != "common_assets" ]; then
      cd $component
      if [ -f "package.json" ]; then
        npm run build
      else
        printf "${GREEN}Gui component ${YELLOW}${component}${NC} ${GREEN}not buildable in isolation, it was probably (hopefuly) included from some other components...${NC}\n"
      fi
    fi
    cd "$base_dir"
  done

  cd "$cwd"
}

function gui_send_action_to_frontend {
  local action="$1"
  local payload
  if [ -n "$2" ]; then
    #action="${action}:${2}"
    payload="$2"
  fi
  node "${backendDir}/ws_servers/index.js" localhost "$action" gui "$payload"
}

function gui {
  local dir="$DMT_PATH/core/node/dmt-gui/gui-frontend-core"
  local backendDir="$DMT_PATH/core/node/dmt-gui/gui-backend"

  local option="$1"

  if [ -z "$option" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}gui cd [gui]${NC} ${GRAY}${NC}\n"
    printf "${GREEN}gui run [gui]${NC} ${GRAY}${NC}\n"
    printf "${GREEN}gui build${NC} ${GRAY}build all GUIs${NC}\n"
    printf "${GREEN}gui build [gui]${NC} ${GRAY}${NC}\n"
    printf "${GREEN}gui reload${NC} ${GRAY}send request to frontend via websocket requesting refresh of current url${NC}\n"
    printf "${GREEN}gui reload [view]${NC} ${GRAY}reloads the specified gui view (home, player, debug etc.)${NC}\n"
    printf "${GREEN}gui switch [ip]${NC} ${GRAY}switches gui to specified IP (todo: use deviceId instead of ip)${NC}\n"
    printf "${GREEN}gui debug${NC} ${GRAY}shows debugging info for current gui issues troubleshooting${NC}\n"
    return
  fi

  shift

  case "$option" in
    cd)
      awesome_cd "$dir" "$1"
      if [ $? -eq 0 ] && [ -d "src" ]; then
        cd "src"
      fi
      ;;

    reload)
      local view="$1"
      gui_send_action_to_frontend "reload" "$view"
      ;;

    switch)
      local ip="$1"
      gui_send_action_to_frontend "switch" "$ip"
      ;;

    run)
      symlink_if_unlinked

      if [ -z "$1" ]; then
        gui run app
      elif [ "$1" == "." ]; then
        npm run dev
      else
        awesome_cd "$dir" "$1"
        if [ $? -eq 0 ]; then
          npm run dev
        fi
      fi
      ;;

    build)
      symlink_if_unlinked

      if [ -z "$1" ]; then
        gui build app
        #gui_build_all
        return
      fi

      awesome_cd "$dir" "$1"
      if [ $? -eq 0 ]; then
        npm run build
      fi
      ;;

    debug)
      echo "TODO"
      ;;

    *)
      awesome_cd "$dir" "$option"
      ;;
  esac
}

function dmt_log {
  local foreground=false

  if [ "$1" == "-h" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}dmt log${NC} ${GRAY}get last 10 log lines on this machine${NC}\n"
    printf "${GREEN}dmt @host log${NC} ${GRAY}get last 10 log lines for remote machine${NC}\n"
    printf "${GREEN}dmt logfg${NC} ${GRAY}local log in foreground (updates are visible as they come)${NC}\n"
    return
  fi

  local logfile="$DMT_PATH/log/dmt.log"

  if [ "$1" == "fg" ]; then
    # ISSUE: 1) dmt logfg 2) COMMAND+K (clear screen) 3) renew device.. 4) PROBLEM: even older log messages will be shown
    tail -f -n 100 "$logfile"
  else
    if [ -n "$hosts" ]; then
      node "$DMT_CLI" "${hosts}" log "$@"
    else
      node "$DMT_CLI" log "$@"
    fi
  fi
}

function dmt_help {
  printf "${YELLOW}Basic info:${NC}\n"
  printf "${GREEN}dmt help ${GRAY}shows this help screen${NC}\n"
  #printf "${GREEN}dmt docs ${MAGENTA}shows documentation in a browser${NC}\n"
  printf "${GREEN}dmt version ${GRAY}shows dmt version — v$(cat "$DMT_PATH/.version")${NC}\n"
  printf "${GREEN}dmt device ${GRAY}device configuration and information${NC}\n"

  echo
  printf "${YELLOW}Clone to more of your devices:${NC}\n"
  printf "${GREEN}dmt next ${GRAY}gets the latest code from The Source (dmt-system.com)${NC}\n"
  printf "${GREEN}dmt update [host] ${GRAY}or ${GREEN}dmt install [host] ${GRAY}clones dmt to another machine of yours (via SSH)${NC}\n"
  printf "${GREEN}dmt deactivate ${GRAY}deactivates shell but keep it present (to get it back just do ${CYAN}./install${GRAY})${NC}\n"
  printf "${GREEN}dmt remove ${GRAY}self-destroys on this machine (except the user definitions and data)${NC}\n"
  printf "From another machine: ${MAGENTA}curl [thisMachineIp]:1111 | bash ${GRAY}replicates ~/.dmt directory (without ~/.dmt/user) from this to another machine${NC}\n"
  echo
  printf "${MAGENTA}dmt-proc ${YELLOW}management:\n${NC}"
  printf "${CYAN}■ services will not persist after reboot — ${MAGENTA}use the docs${CYAN} to easily configure this.${NC}"
  echo
  printf "${GREEN}dmt start ${GRAY}starts the background process ${MAGENTA}(dmt-proc)${NC} 💡🚀🎸${NC}\n"
  printf "${GREEN}dmt startfg ${GRAY}(only used in special cases when testing or developing) starts the services in current terminal (foreground) and quits when terminal is closed${NC}\n"
  printf "${GREEN}dmt stop ${GRAY}stops the process${NC}\n"
  printf "${GREEN}dmt restart ${GRAY}restarts the process${NC}\n"
  printf "${GREEN}dmt logfg ${GRAY}shows log in current tab (to get last few lines use ${GREEN}dmt log${GRAY} - makes a rpc call, see below)${NC}\n"
}

function dmt_help_explain_rpc {
  echo
  printf "${CYAN}A general example of using a rpc method either on localhost or some other device:${NC}\n"
  echo
  printf "${GREEN}dmt info ${GRAY}gets information about current device${NC}\n"
  printf "${GREEN}dmt @hostOrIp info ${GRAY}gets information about a device on local network${NC}\n"
  # printf "${GREEN}dmt @@remoteIpOrHost info ${GRAY}gets information about remote device on the other side of router WAN port${NC}\n"
  echo
  printf "${GRAY}You can do the same with all other rpc methods listed above.${NC}\n"
}

function dmt_version {
  printf "${MAGENTA}v$(cat "$DMT_PATH/.version")${NC}\n\n"
  local NUM=$(cat $HOME/.bash_aliases | grep function | wc -l | xargs)
  printf "${WHITE}${NUM} bash functions ${GRAY}\nin ~/.bash_aliases${NC}\n"
}

function get_dmt_source {
  local _gatewayMac=''
  get_gateway_mac _gatewayMac

  if [ "$_gatewayMac" == "$LOCAL_DMT_SOURCE_MAC" ]; then
    eval "$1='local'"
    #printf "${GREEN}LOCAL${NC}\n"
  else
    eval "$1='global'"
    #printf "${MAGENTA}GLOBAL${NC}\n"
  fi
  #printf "${YELLOW}$_gatewayMac${NC}\n"
}

function stop_dmt_if_running {
  local dmt_proc_pid=''
  local dmt_fg_bg=''
  get_dmt_proc_pid dmt_proc_pid dmt_fg_bg

  if [ -n "$dmt_proc_pid" ]; then
    dmt stop
  fi
}

function dmt_next {
  if dev_machine; then
    printf "${RED}Prevented on dev machine${NC}\n"
    return
  fi

  stop_dmt_if_running

  local before_next_backup_dir="$HOME/.dmt-backup-before-next"

  if [ -d "$before_next_backup_dir" ]; then
    printf "${RED}Aborting due to existing directory - ${before_next_backup_dir} ${NC}\n"
    return
  fi

  if [ -d "$DMT_PATH" ]; then
    printf "${YELLOW}Moving $DMT_PATH to ${before_next_backup_dir}...${NC}\n"
    mv "$DMT_PATH" "$before_next_backup_dir"
  fi

  cd "$HOME"

  # local dmt_source=''
  # get_dmt_source dmt_source

  # BUGGY! when you run it on the local source machine itself, it will do and say nonsense
  # if [ $dmt_source == 'local' ]; then
  #   printf "${GREEN}Fetching from ${YELLOW}${LOCAL_DMT_SOURCE_ENDPOINT}${NC} ...\n\n"
  #   curl "$LOCAL_DMT_SOURCE_ENDPOINT" | bash
  # else
    printf "${CYAN}Fetching from ${MAGENTA}dmt-system.com${NC} ...\n\n"
    curl -L dmt-system.com/get | bash
  # fi

  if [ -d "$DMT_PATH" ]; then
    if [ -d "$DMT_PATH/user" ] && [ -d "$before_next_backup_dir/user" ]; then
      rm -rf "$DMT_PATH/user"
      printf "${YELLOW}Moving ${before_next_backup_dir}/user to ${DMT_PATH} ...${NC}\n"
      mv "$before_next_backup_dir/user" "$DMT_PATH"
    fi

    if [ -d "$DMT_PATH/state" ] && [ -d "$before_next_backup_dir/state" ]; then
      rm -rf "$DMT_PATH/state"
      printf "${YELLOW}Moving ${before_next_backup_dir}/state to ${DMT_PATH} ...${NC}\n"
      mv "$before_next_backup_dir/state" "$DMT_PATH"
    fi

    if [ -d "$DMT_PATH/log" ] && [ -d "$before_next_backup_dir/log" ]; then
      rm -rf "$DMT_PATH/log"
      printf "${YELLOW}Moving ${before_next_backup_dir}/log to ${DMT_PATH} ...${NC}\n"
      mv "$before_next_backup_dir/log" "$DMT_PATH"
    fi

    printf "${YELLOW}Removing ${before_next_backup_dir}${NC}\n"
    rm -rf "$before_next_backup_dir"
  else
    printf "${RED}Problem installing dmt -- ~/.dmt does not exist${NC}\n"

    if [ -d "$before_next_backup_dir" ]; then
      printf "${MAGENTA}Restoring ${before_next_backup_dir} to ${DMT_PATH}${NC}\n"
      mv "$before_next_backup_dir" "$DMT_PATH"
    fi
  fi

  dmt start
}

function dmt_install {
  # multi install: dmt update dev1 dev2 ... devn
  if [ -n "$2" ]; then
    for dev in "$@"
    do
      dmt_install "$dev"
    done
    return
  fi

  local cwd="`pwd`"
  cd "$DMT_PATH"
  . ./install "from-dmt-install" "$@" # calling with . preserves the newly loaded env
  cd "$cwd"
}

function dmt_update {
  symlink_if_unlinked

  if [ -z "$1" ]; then
    if dev_machine; then
      printf "${RED}Prevented on dev machine${NC}\n"
    fi
  else
    #copy_core_bootscripts
    compile_gui_if_missing

    dmt_install "$@"
  fi
}

function u {
  dmt_update "$@"
}

function re {
  dmt_renew "$@"
}

function dmt_renew {
  symlink_if_unlinked

  # supports multi install: dmt renew dev1 dev2 ... devN
  if [ -z "$2" ]; then
    dmt_update "$1"
    restart_remote_device "$1"
  else
    #symlink_if_unlinked
    compile_gui_if_missing

    for device in "$@"
    do
      dmt_renew "$device"
    done
  fi
}

function dmt_remove {
  printf "${GRAY}Please copy and execute:${NC}\n\n"
  printf "1) ${GREEN}dmt deactivate${NC}\n"
  printf "2) ${RED}rm -rf ~/.dmt${NC}\n"
}

function restart_remote_device {
  local cmd="source ~/.dmt/etc/.bash_aliases_slim && se \\\"if [ -f ~/.dmt/user/devices/this/before-renew ]; then ~/.dmt/user/devices/this/before-renew; fi; if [ -f ~/.dmt/etc/deploy_hooks/before-renew ]; then ~/.dmt/etc/deploy_hooks/before-renew; fi; ~/.dmt/etc/onboot/daemons restart_and_notify_on_fail\\\""

  local host="$1"

  if [ "$host" == "ap" ]; then
    host="$DMT_AP_DEFAULT_HOST"
  else
    local matching_host=''
    local ssh_port=''
    get_full_host matching_host ssh_port "$host"
    if [ $? -ne 1 ]; then # not error
      host="$matching_host"
    fi
  fi

  if [ -n "$host" ]; then
    remote -h "$host" --port "$ssh_port" "$cmd"
  else
    printf "${RED}Unknown host${NC}\n"
  fi
  #fi
}

function dmt_deactivate {
  if dev_machine; then
    printf "${RED}Prevented on dev machine${NC}\n"
    return
  fi

  local backup_file="$HOME/.bash_aliases-backup-by-dmt"

  if [ -L "$LOGNAME_HOME/.bash_aliases" ] && [ "$(head -3 $LOGNAME_HOME/.bash_aliases | tail -1)" == "# DMT ALIASES" ]; then
    rm ~/.bash_aliases

    if [ -f "$backup_file" ]; then
      mv "$backup_file" ~/.bash_aliases
    fi

    printf "${MAGENTA}dmt${NC} ${CYAN}was unlinked${NC}, only the folder ${CYAN}~/.dmt${NC} remains and is not active in any way.\n"
    echo
    printf "${CYAN}To reinstall${NC}\n"
    printf "${GREEN}cd $HOME/.dmt${NC}\n"
    printf "${GREEN}./install${NC}\n"
    echo
    printf "${CYAN}To remove the unused directory${NC}\n"
    printf "${GREEN}rm -rf $HOME/.dmt${NC}\n"
    echo
    printf "${WHITE}If you want to confirm that dmt is uninstalled you have to first reload the shell.${NC}\n"
  else
    printf "${RED}dmt is not installed${NC}\n"
  fi
}

function dmt_cd {
  cd "$DMT_PATH"
}

function dmt_bin {
  declare -a opts=(
    "compile"
    "download"
  )

  if [ -z "$1" ] || [ "$1" == "-h" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    echo "${opts[@]}"
    return
  fi

  local matching_opt=''
  opts_matcher matching_opt "$1" "${opts[@]}"
  if [ $? -ne 0 ]; then # error
    printf "Use -h to see valid options\n\n"
    #matching_opt="aaa" # default
    return
  fi

  shift

  case "$matching_opt" in
    compile)
      if [ -d $DMT_RUST_CORE ]; then
        dmt_compile_bin
      else
        echo "rust core doesn't exists"
      fi
      ;;

    download)
      ;;
  esac
}

function dmt_compile_bin {
  local cwd="`pwd`"

  # todo: ... + generalize the process somehow....

  printf "${MAGENTA}$DMT_RUST_CORE/walkdir${NC}\n"
  if [ -d "$DMT_RUST_CORE/walkdir" ]; then
    cd "$DMT_RUST_CORE/walkdir"
    cargo build --release --example walkdir
    if [ "$?" -eq 0 ]; then
      mkdir -p "${DMT_PLATFORM_BIN}"
      # https://stackoverflow.com/questions/8139885/shellscript-action-if-two-files-are-different
      if ! cmp target/release/examples/walkdir "${DMT_PLATFORM_BIN}/walkdir" >/dev/null 2>&1; then
        printf "${GREEN}✓ Build successful, copying executable to ${DMT_PLATFORM_BIN}${NC}\n"
        cp target/release/examples/walkdir "${DMT_PLATFORM_BIN}"
      else
        printf "${CYAN}✓ Build successful but executable in ${DMT_PLATFORM_BIN} is already the newest version${NC}\n"
      fi
    fi
  fi

  echo

  printf "${MAGENTA}$DMT_RUST_CORE/walksearch${NC}\n"
  if [ -d "$DMT_RUST_CORE/walksearch" ]; then
    cd "$DMT_RUST_CORE/walksearch"
    cargo build --release
    if [ "$?" -eq 0 ]; then
      mkdir -p "${DMT_PLATFORM_BIN}"
      # https://stackoverflow.com/questions/8139885/shellscript-action-if-two-files-are-different
      if ! cmp target/release/walksearch "${DMT_PLATFORM_BIN}/walksearch" >/dev/null 2>&1; then
        printf "${GREEN}✓ Build successful, copying executable to ${DMT_PLATFORM_BIN}${NC}\n"
        cp target/release/walksearch "${DMT_PLATFORM_BIN}"
      else
        printf "${CYAN}✓ Build successful but executable in ${DMT_PLATFORM_BIN} is already the newest version${NC}\n"
      fi
    fi
  fi

  cd "$cwd"
}
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~ KEEP THESE AS LAST LINES ~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

if [ -f "$LOGNAME_HOME/.dmt/user/shell/.bash_user" ]; then
  . "$LOGNAME_HOME/.dmt/user/shell/.bash_user"
fi

if [ -f "$LOGNAME_HOME/.dmt/user/devices/this/shell/.bash_device" ]; then
  . "$LOGNAME_HOME/.dmt/user/devices/this/shell/.bash_device"
fi

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
